{
  "vertex": {
      "module": {
          "code": "struct ub_view {\n  /* @offset(0) */\n  matrix_model : mat4x4<f32>,\n  /* @offset(64) */\n  matrix_normal : mat3x3<f32>,\n  /* @offset(112) */\n  view_position : vec3<f32>,\n  /* @offset(128) */\n  light_globalAmbient : vec3<f32>,\n  /* @offset(140) */\n  textureBias : f32,\n  /* @offset(144) */\n  twoSidedLightingNegScaleFactor : f32,\n  /* @offset(148) */\n  exposure : f32,\n  /* @offset(160) */\n  material_diffuse : vec3<f32>,\n  /* @offset(172) */\n  material_gloss : f32,\n  /* @offset(176) */\n  material_emissive : vec3<f32>,\n  /* @offset(188) */\n  material_f0 : f32,\n  /* @offset(192) */\n  clusterMaxCells : i32,\n  /* @offset(196) */\n  clusterSkip : f32,\n  /* @offset(208) */\n  clusterCellsCountByBoundsSize : vec3<f32>,\n  /* @offset(224) */\n  clusterTextureSize : vec3<f32>,\n  /* @offset(240) */\n  clusterBoundsMin : vec3<f32>,\n  /* @offset(256) */\n  clusterBoundsDelta : vec3<f32>,\n  /* @offset(272) */\n  clusterCellsDot : vec3<f32>,\n  /* @offset(288) */\n  clusterCellsMax : vec3<f32>,\n  /* @offset(304) */\n  clusterCompressionLimit0 : vec2<f32>,\n  /* @offset(312) */\n  shadowAtlasParams : vec2<f32>,\n}\n\nstruct ub_mesh {\n  /* @offset(0) */\n  matrix_viewProjection : mat4x4<f32>,\n}\n\n@group(0) @binding(0) var<uniform> x_26 : ub_view;\n\nvar<private> dModelMatrix : mat4x4<f32>;\n\nvar<private> vertex_position : vec3<f32>;\n\nvar<private> dPositionW : vec3<f32>;\n\n@group(1) @binding(0) var<uniform> x_58 : ub_mesh;\n\nvar<private> dNormalMatrix : mat3x3<f32>;\n\nvar<private> vertex_normal : vec3<f32>;\n\nvar<private> vPositionW : vec3<f32>;\n\nvar<private> vNormalW : vec3<f32>;\n\n@group(1) @binding(1) var lightsTextureFloat : texture_2d<f32>;\n\n@group(1) @binding(2) var lightsTextureFloat_sampler : sampler;\n\n@group(1) @binding(3) var lightsTexture8 : texture_2d<f32>;\n\n@group(1) @binding(4) var lightsTexture8_sampler : sampler;\n\n@group(0) @binding(1) var areaLightsLutTex1 : texture_2d<f32>;\n\n@group(0) @binding(2) var areaLightsLutTex1_sampler : sampler;\n\n@group(0) @binding(3) var areaLightsLutTex2 : texture_2d<f32>;\n\n@group(0) @binding(4) var areaLightsLutTex2_sampler : sampler;\n\n@group(0) @binding(5) var clusterWorldTexture : texture_2d<f32>;\n\n@group(0) @binding(6) var clusterWorldTexture_sampler : sampler;\n\nvar<private> gl_Position : vec4<f32>;\n\nfn getModelMatrix_() -> mat4x4<f32> {\n  let x_30 : mat4x4<f32> = x_26.matrix_model;\n  return x_30;\n}\n\nfn getPosition_() -> vec4<f32> {\n  var localPos : vec3<f32>;\n  var posW : vec4<f32>;\n  var screenPos : vec4<f32>;\n  let x_35 : mat4x4<f32> = getModelMatrix_();\n  dModelMatrix = x_35;\n  let x_40 : vec3<f32> = vertex_position;\n  localPos = x_40;\n  let x_43 : mat4x4<f32> = dModelMatrix;\n  let x_44 : vec3<f32> = localPos;\n  posW = (x_43 * vec4<f32>(x_44.x, x_44.y, x_44.z, 1.0f));\n  let x_53 : vec4<f32> = posW;\n  dPositionW = vec3<f32>(x_53.x, x_53.y, x_53.z);\n  let x_60 : mat4x4<f32> = x_58.matrix_viewProjection;\n  let x_61 : vec4<f32> = posW;\n  screenPos = (x_60 * x_61);\n  let x_63 : vec4<f32> = screenPos;\n  return x_63;\n}\n\nfn getWorldPosition_() -> vec3<f32> {\n  let x_66 : vec3<f32> = dPositionW;\n  return x_66;\n}\n\nfn getNormal_() -> vec3<f32> {\n  var tempNormal : vec3<f32>;\n  let x_74 : mat3x3<f32> = x_26.matrix_normal;\n  dNormalMatrix = x_74;\n  let x_77 : vec3<f32> = vertex_normal;\n  tempNormal = x_77;\n  let x_78 : mat3x3<f32> = dNormalMatrix;\n  let x_79 : vec3<f32> = tempNormal;\n  return normalize((x_78 * x_79));\n}\n\nfn main_1() {\n  let x_90 : vec4<f32> = getPosition_();\n  gl_Position = x_90;\n  let x_95 : vec3<f32> = getWorldPosition_();\n  vPositionW = x_95;\n  let x_97 : vec3<f32> = getNormal_();\n  vNormalW = x_97;\n  return;\n}\n\nstruct main_out {\n  @builtin(position)\n  gl_Position : vec4<f32>,\n  @location(0)\n  vPositionW_1 : vec3<f32>,\n  @location(1)\n  vNormalW_1 : vec3<f32>,\n}\n\n@vertex\nfn main(@location(0) vertex_position_param : vec3<f32>, @location(1) vertex_normal_param : vec3<f32>) -> main_out {\n  vertex_position = vertex_position_param;\n  vertex_normal = vertex_normal_param;\n  main_1();\n  return main_out(gl_Position, vPositionW, vNormalW);\n}\n"
      },
      "entryPoint": "main",
      "buffers": [
          {
              "attributes": [
                  {
                      "shaderLocation": 0,
                      "offset": 0,
                      "format": "float32x3"
                  },
                  {
                      "shaderLocation": 1,
                      "offset": 12,
                      "format": "float32x3"
                  },
                  {
                      "shaderLocation": 5,
                      "offset": 24,
                      "format": "float32x2"
                  }
              ],
              "arrayStride": 32,
              "stepMode": "vertex"
          }
      ]
  },
  "primitive": {
      "topology": "triangle-list",
      "cullMode": "none"
  },
  "depthStencil": {
      "format": "depth24plus-stencil8",
      "depthWriteEnabled": true,
      "depthCompare": "less-equal"
  },
  "multisample": {
      "count": 4
  },
  "layout": "auto",
  "fragment": {
      "module": {
          "code": "struct IridescenceArgs {\n  intensity : f32,\n  thickness : f32,\n}\n\nstruct ClearcoatArgs {\n  specularity : f32,\n  gloss : f32,\n  worldNormal : vec3<f32>,\n}\n\nstruct SheenArgs {\n  gloss : f32,\n  specularity : vec3<f32>,\n}\n\nstruct LitShaderArguments {\n  opacity : f32,\n  worldNormal : vec3<f32>,\n  albedo : vec3<f32>,\n  transmission : f32,\n  thickness : f32,\n  specularity : vec3<f32>,\n  gloss : f32,\n  metalness : f32,\n  specularityFactor : f32,\n  ao : f32,\n  emission : vec3<f32>,\n  lightmap : vec3<f32>,\n  lightmapDir : vec3<f32>,\n  iridescence : IridescenceArgs,\n  clearcoat : ClearcoatArgs,\n  sheen : SheenArgs,\n}\n\nstruct Coords {\n  coord0 : vec3<f32>,\n  coord1 : vec3<f32>,\n  coord2 : vec3<f32>,\n  coord3 : vec3<f32>,\n}\n\nstruct ClusterLightData {\n  halfWidth : vec3<f32>,\n  lightType : f32,\n  halfHeight : vec3<f32>,\n  lightIndex : i32,\n  position : vec3<f32>,\n  shape : f32,\n  direction : vec3<f32>,\n  falloffMode : f32,\n  color : vec3<f32>,\n  shadowIntensity : f32,\n  omniAtlasViewport : vec3<f32>,\n  range : f32,\n  cookieChannelMask : vec4<f32>,\n  shadowBias : f32,\n  shadowNormalBias : f32,\n  innerConeAngleCos : f32,\n  outerConeAngleCos : f32,\n  cookie : f32,\n  cookieRgb : f32,\n  cookieIntensity : f32,\n  mask : f32,\n}\n\nstruct ub_view {\n  /* @offset(0) */\n  matrix_model : mat4x4<f32>,\n  /* @offset(64) */\n  matrix_normal : mat3x3<f32>,\n  /* @offset(112) */\n  view_position : vec3<f32>,\n  /* @offset(128) */\n  light_globalAmbient : vec3<f32>,\n  /* @offset(140) */\n  textureBias : f32,\n  /* @offset(144) */\n  twoSidedLightingNegScaleFactor : f32,\n  /* @offset(148) */\n  exposure : f32,\n  /* @offset(160) */\n  material_diffuse : vec3<f32>,\n  /* @offset(172) */\n  material_gloss : f32,\n  /* @offset(176) */\n  material_emissive : vec3<f32>,\n  /* @offset(188) */\n  material_f0 : f32,\n  /* @offset(192) */\n  clusterMaxCells : i32,\n  /* @offset(196) */\n  clusterSkip : f32,\n  /* @offset(208) */\n  clusterCellsCountByBoundsSize : vec3<f32>,\n  /* @offset(224) */\n  clusterTextureSize : vec3<f32>,\n  /* @offset(240) */\n  clusterBoundsMin : vec3<f32>,\n  /* @offset(256) */\n  clusterBoundsDelta : vec3<f32>,\n  /* @offset(272) */\n  clusterCellsDot : vec3<f32>,\n  /* @offset(288) */\n  clusterCellsMax : vec3<f32>,\n  /* @offset(304) */\n  clusterCompressionLimit0 : vec2<f32>,\n  /* @offset(312) */\n  shadowAtlasParams : vec2<f32>,\n}\n\nstruct ub_mesh {\n  /* @offset(0) */\n  matrix_viewProjection : mat4x4<f32>,\n}\n\nvar<private> dAlpha : f32;\n\nvar<private> dBlendModeFogFactor : f32;\n\nvar<private> dLightDirW : vec3<f32>;\n\nvar<private> vPositionW : vec3<f32>;\n\nvar<private> dLightDirNormW : vec3<f32>;\n\nvar<private> dLightPosW : vec3<f32>;\n\n@group(0) @binding(0) var<uniform> x_462 : ub_view;\n\nvar<private> dNormalW : vec3<f32>;\n\nvar<private> dVertexNormalW : vec3<f32>;\n\nvar<private> dAlbedo : vec3<f32>;\n\nvar<private> dMetalness : f32;\n\nvar<private> dSpecularity : vec3<f32>;\n\nvar<private> dGlossiness : f32;\n\nvar<private> dEmission : vec3<f32>;\n\nvar<private> dSphereRadius : f32;\n\nvar<private> vNormalW : vec3<f32>;\n\n@group(0) @binding(3) var areaLightsLutTex2 : texture_2d<f32>;\n\n@group(0) @binding(4) var areaLightsLutTex2_sampler : sampler;\n\nvar<private> dLTCUV : vec2<f32>;\n\nvar<private> dLTCSpecFres : vec3<f32>;\n\nvar<private> dLTCCoords : Coords;\n\n@group(0) @binding(1) var areaLightsLutTex1 : texture_2d<f32>;\n\n@group(0) @binding(2) var areaLightsLutTex1_sampler : sampler;\n\nvar<private> dDiffuseLight : vec3<f32>;\n\nvar<private> dSpecularLight : vec3<f32>;\n\nvar<private> dViewDirW : vec3<f32>;\n\nvar<private> dReflDirW : vec3<f32>;\n\n@group(1) @binding(3) var lightsTexture8 : texture_2d<f32>;\n\n@group(1) @binding(1) var lightsTextureFloat : texture_2d<f32>;\n\n@group(0) @binding(5) var clusterWorldTexture : texture_2d<f32>;\n\nvar<private> dTBN : mat3x3<f32>;\n\nvar<private> pc_fragColor : vec4<f32>;\n\nvar<private> dReflection : vec4<f32>;\n\nvar<private> gl_FrontFacing : bool;\n\n@group(1) @binding(0) var<uniform> x_2599 : ub_mesh;\n\n@group(1) @binding(2) var lightsTextureFloat_sampler : sampler;\n\n@group(1) @binding(4) var lightsTexture8_sampler : sampler;\n\n@group(0) @binding(6) var clusterWorldTexture_sampler : sampler;\n\nvar<private> ccReflDirW : vec3<f32>;\n\nvar<private> dShadowCoord : vec3<f32>;\n\nvar<private> ccFresnel : f32;\n\nvar<private> ccReflection : vec3<f32>;\n\nvar<private> ccSpecularLight : vec3<f32>;\n\nvar<private> sSpecularLight : vec3<f32>;\n\nvar<private> sReflection : vec3<f32>;\n\nvar<private> lightProjectionMatrix : mat4x4<f32>;\n\nfn getViewDir_() {\n  let x_1883 : vec3<f32> = x_462.view_position;\n  let x_1884 : vec3<f32> = vPositionW;\n  dViewDirW = normalize((x_1883 - x_1884));\n  return;\n}\n\nfn getNormal_() {\n  let x_495 : vec3<f32> = dVertexNormalW;\n  dNormalW = x_495;\n  return;\n}\n\nfn getAlbedo_() {\n  dAlbedo = vec3<f32>(1.0f, 1.0f, 1.0f);\n  let x_501 : vec3<f32> = x_462.material_diffuse;\n  let x_502 : vec3<f32> = dAlbedo;\n  dAlbedo = (x_502 * x_501);\n  return;\n}\n\nfn getMetalness_() {\n  var metalness : f32;\n  metalness = 1.0f;\n  let x_506 : f32 = metalness;\n  dMetalness = x_506;\n  return;\n}\n\nfn getGlossiness_() {\n  dGlossiness = 1.0f;\n  let x_511 : f32 = x_462.material_gloss;\n  let x_512 : f32 = dGlossiness;\n  dGlossiness = (x_512 * x_511);\n  let x_514 : f32 = dGlossiness;\n  dGlossiness = (1.0f - x_514);\n  let x_516 : f32 = dGlossiness;\n  dGlossiness = (x_516 + 0.0000001f);\n  return;\n}\n\nfn getSpecularity_() {\n  dSpecularity = vec3<f32>(1.0f, 1.0f, 1.0f);\n  return;\n}\n\nfn getEmission_() {\n  dEmission = vec3<f32>(1.0f, 1.0f, 1.0f);\n  let x_521 : vec3<f32> = x_462.material_emissive;\n  let x_522 : vec3<f32> = dEmission;\n  dEmission = (x_522 * x_521);\n  return;\n}\n\nfn evaluateFrontend_() -> LitShaderArguments {\n  var x_litShaderArgs : LitShaderArguments;\n  getNormal_();\n  getAlbedo_();\n  getMetalness_();\n  getGlossiness_();\n  getSpecularity_();\n  getEmission_();\n  let x_532 : vec3<f32> = dNormalW;\n  x_litShaderArgs.worldNormal = x_532;\n  let x_535 : vec3<f32> = dAlbedo;\n  x_litShaderArgs.albedo = x_535;\n  let x_537 : f32 = dMetalness;\n  x_litShaderArgs.metalness = x_537;\n  let x_540 : vec3<f32> = dSpecularity;\n  x_litShaderArgs.specularity = x_540;\n  let x_542 : f32 = dGlossiness;\n  x_litShaderArgs.gloss = x_542;\n  let x_545 : vec3<f32> = dEmission;\n  x_litShaderArgs.emission = x_545;\n  let x_547 : LitShaderArguments = x_litShaderArgs;\n  return x_547;\n}\n\nfn getReflDir_vf3_vf3_f1_mf33_(worldNormal_14 : ptr<function, vec3<f32>>, viewDir_12 : ptr<function, vec3<f32>>, gloss_5 : ptr<function, f32>, tbn_1 : ptr<function, mat3x3<f32>>) {\n  let x_1888 : vec3<f32> = *(viewDir_12);\n  let x_1889 : vec3<f32> = *(worldNormal_14);\n  dReflDirW = normalize(-(reflect(x_1888, x_1889)));\n  return;\n}\n\nfn getMetalnessModulate_struct_LitShaderArguments_f1_vf3_vf3_f1_f1_vf3_f1_f1_f1_f1_vf3_vf3_vf3_struct_IridescenceArgs_f1_f11_struct_ClearcoatArgs_f1_f1_vf31_struct_SheenArgs_f1_vf311_(litShaderArgs : ptr<function, LitShaderArguments>) {\n  var dielectricF0 : vec3<f32>;\n  let x_552 : f32 = x_462.material_f0;\n  let x_554 : vec3<f32> = (*(litShaderArgs)).specularity;\n  dielectricF0 = (x_554 * x_552);\n  let x_556 : vec3<f32> = dielectricF0;\n  let x_558 : vec3<f32> = (*(litShaderArgs)).albedo;\n  let x_560 : f32 = (*(litShaderArgs)).metalness;\n  (*(litShaderArgs)).specularity = mix(x_556, x_558, vec3<f32>(x_560, x_560, x_560));\n  let x_565 : f32 = (*(litShaderArgs)).metalness;\n  let x_568 : vec3<f32> = (*(litShaderArgs)).albedo;\n  (*(litShaderArgs)).albedo = (x_568 * (1.0f - x_565));\n  return;\n}\n\nfn addAmbient_vf3_(worldNormal_13 : ptr<function, vec3<f32>>) {\n  let x_1878 : vec3<f32> = x_462.light_globalAmbient;\n  let x_1879 : vec3<f32> = dDiffuseLight;\n  dDiffuseLight = (x_1879 + x_1878);\n  return;\n}\n\nfn saturate_f1_(x_1 : ptr<function, f32>) -> f32 {\n  let x_348 : f32 = *(x_1);\n  return clamp(x_348, 0.0f, 1.0f);\n}\n\nfn LTC_Uv_vf3_vf3_f1_(N : vec3<f32>, V : vec3<f32>, roughness : f32) -> vec2<f32> {\n  var dotNV : f32;\n  var param_8 : f32;\n  var uv_4 : vec2<f32>;\n  param_8 = dot(N, V);\n  let x_629 : f32 = saturate_f1_(&(param_8));\n  dotNV = x_629;\n  let x_631 : f32 = dotNV;\n  uv_4 = vec2<f32>(roughness, sqrt((1.0f - x_631)));\n  let x_635 : vec2<f32> = uv_4;\n  uv_4 = ((x_635 * 0.984375f) + vec2<f32>(0.0078125f, 0.0078125f));\n  let x_641 : vec2<f32> = uv_4;\n  return x_641;\n}\n\nfn getLTCLightUV_f1_vf3_vf3_(gloss_1 : ptr<function, f32>, worldNormal_1 : ptr<function, vec3<f32>>, viewDir_1 : ptr<function, vec3<f32>>) -> vec2<f32> {\n  var roughness_1 : f32;\n  let x_900 : f32 = *(gloss_1);\n  let x_902 : f32 = *(gloss_1);\n  roughness_1 = max(((1.0f - x_900) * (1.0f - x_902)), 0.001f);\n  let x_907 : vec3<f32> = *(worldNormal_1);\n  let x_908 : vec3<f32> = *(viewDir_1);\n  let x_909 : f32 = roughness_1;\n  let x_910 : vec2<f32> = LTC_Uv_vf3_vf3_f1_(x_907, x_908, x_909);\n  return x_910;\n}\n\nfn getLTCLightSpecFres_vf2_vf3_(uv : ptr<function, vec2<f32>>, specularity_1 : ptr<function, vec3<f32>>) -> vec3<f32> {\n  var t2 : vec4<f32>;\n  let x_924 : vec2<f32> = *(uv);\n  let x_925 : vec4<f32> = textureSampleLevel(areaLightsLutTex2, areaLightsLutTex2_sampler, x_924, 0.0f);\n  t2 = x_925;\n  let x_928 : vec4<f32> = t2;\n  t2 = (x_928 * vec4<f32>(0.693103015f, 1.0f, 1.0f, 1.0f));\n  let x_932 : vec4<f32> = t2;\n  t2 = (x_932 + vec4<f32>(0.306897014f, 0.0f, 0.0f, 0.0f));\n  let x_934 : vec3<f32> = *(specularity_1);\n  let x_936 : f32 = t2.x;\n  let x_938 : vec3<f32> = *(specularity_1);\n  let x_941 : f32 = t2.y;\n  return ((x_934 * x_936) + ((vec3<f32>(1.0f, 1.0f, 1.0f) - x_938) * x_941));\n}\n\nfn calcLTCLightValues_f1_vf3_vf3_vf3_f1_vf3_f1_(gloss_2 : ptr<function, f32>, worldNormal_2 : ptr<function, vec3<f32>>, viewDir_2 : ptr<function, vec3<f32>>, specularity_2 : ptr<function, vec3<f32>>, clearcoatGloss : ptr<function, f32>, clearcoatWorldNormal : ptr<function, vec3<f32>>, clearcoatSpecularity : ptr<function, f32>) {\n  var param_12 : f32;\n  var param_13 : vec3<f32>;\n  var param_14 : vec3<f32>;\n  var param_15 : vec2<f32>;\n  var param_16 : vec3<f32>;\n  let x_949 : f32 = *(gloss_2);\n  param_12 = x_949;\n  let x_951 : vec3<f32> = *(worldNormal_2);\n  param_13 = x_951;\n  let x_953 : vec3<f32> = *(viewDir_2);\n  param_14 = x_953;\n  let x_954 : vec2<f32> = getLTCLightUV_f1_vf3_vf3_(&(param_12), &(param_13), &(param_14));\n  dLTCUV = x_954;\n  let x_957 : vec2<f32> = dLTCUV;\n  param_15 = x_957;\n  let x_959 : vec3<f32> = *(specularity_2);\n  param_16 = x_959;\n  let x_960 : vec3<f32> = getLTCLightSpecFres_vf2_vf3_(&(param_15), &(param_16));\n  dLTCSpecFres = x_960;\n  return;\n}\n\nfn sampleLightsTexture8_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_i1_(clusterLightData : ClusterLightData, index : ptr<function, i32>) -> vec4<f32> {\n  let x_1901 : i32 = *(index);\n  let x_1905 : vec4<f32> = textureLoad(lightsTexture8, vec2<i32>(x_1901, clusterLightData.lightIndex), 0i);\n  return x_1905;\n}\n\nfn bytes2float2_vf2_(data : ptr<function, vec2<f32>>) -> f32 {\n  let x_1893 : vec2<f32> = *(data);\n  return dot(x_1893, vec2<f32>(1.0f, 0.003921569f));\n}\n\nfn sampleLightTextureF_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_i1_(clusterLightData_1 : ClusterLightData, index_1 : ptr<function, i32>) -> vec4<f32> {\n  let x_1910 : i32 = *(index_1);\n  let x_1913 : vec4<f32> = textureLoad(lightsTextureFloat, vec2<i32>(x_1910, clusterLightData_1.lightIndex), 0i);\n  return x_1913;\n}\n\nfn decodeClusterLightCore_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_f1_(clusterLightData_2 : ptr<function, ClusterLightData>, lightIndex : ptr<function, f32>) {\n  var lightInfo : vec4<f32>;\n  var param_55 : i32;\n  var colorA : vec4<f32>;\n  var param_56 : i32;\n  var colorB : vec4<f32>;\n  var param_57 : i32;\n  var param_58 : vec2<f32>;\n  var param_59 : vec2<f32>;\n  var param_60 : vec2<f32>;\n  var lightPosRange : vec4<f32>;\n  var param_61 : i32;\n  var lightDir_Unused : vec4<f32>;\n  var param_62 : i32;\n  let x_1916 : f32 = *(lightIndex);\n  (*(clusterLightData_2)).lightIndex = i32(x_1916);\n  let x_1920 : ClusterLightData = *(clusterLightData_2);\n  param_55 = 0i;\n  let x_1922 : vec4<f32> = sampleLightsTexture8_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_i1_(x_1920, &(param_55));\n  lightInfo = x_1922;\n  let x_1924 : f32 = lightInfo.x;\n  (*(clusterLightData_2)).lightType = x_1924;\n  let x_1927 : f32 = lightInfo.y;\n  (*(clusterLightData_2)).shape = x_1927;\n  let x_1930 : f32 = lightInfo.z;\n  (*(clusterLightData_2)).falloffMode = x_1930;\n  let x_1933 : f32 = lightInfo.w;\n  (*(clusterLightData_2)).shadowIntensity = x_1933;\n  let x_1936 : ClusterLightData = *(clusterLightData_2);\n  param_56 = 1i;\n  let x_1938 : vec4<f32> = sampleLightsTexture8_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_i1_(x_1936, &(param_56));\n  colorA = x_1938;\n  let x_1940 : ClusterLightData = *(clusterLightData_2);\n  param_57 = 2i;\n  let x_1942 : vec4<f32> = sampleLightsTexture8_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_i1_(x_1940, &(param_57));\n  colorB = x_1942;\n  let x_1944 : vec4<f32> = colorA;\n  param_58 = vec2<f32>(x_1944.x, x_1944.y);\n  let x_1946 : f32 = bytes2float2_vf2_(&(param_58));\n  let x_1948 : vec4<f32> = colorA;\n  param_59 = vec2<f32>(x_1948.z, x_1948.w);\n  let x_1950 : f32 = bytes2float2_vf2_(&(param_59));\n  let x_1952 : vec4<f32> = colorB;\n  param_60 = vec2<f32>(x_1952.x, x_1952.y);\n  let x_1954 : f32 = bytes2float2_vf2_(&(param_60));\n  let x_1958 : f32 = x_462.clusterCompressionLimit0.y;\n  (*(clusterLightData_2)).color = (vec3<f32>(x_1946, x_1950, x_1954) * x_1958);\n  let x_1963 : f32 = colorB.z;\n  (*(clusterLightData_2)).cookie = x_1963;\n  let x_1967 : f32 = colorB.w;\n  (*(clusterLightData_2)).mask = x_1967;\n  let x_1970 : ClusterLightData = *(clusterLightData_2);\n  param_61 = 0i;\n  let x_1972 : vec4<f32> = sampleLightTextureF_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_i1_(x_1970, &(param_61));\n  lightPosRange = x_1972;\n  let x_1974 : vec4<f32> = lightPosRange;\n  (*(clusterLightData_2)).position = vec3<f32>(x_1974.x, x_1974.y, x_1974.z);\n  let x_1979 : f32 = lightPosRange.w;\n  (*(clusterLightData_2)).range = x_1979;\n  let x_1982 : ClusterLightData = *(clusterLightData_2);\n  param_62 = 1i;\n  let x_1984 : vec4<f32> = sampleLightTextureF_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_i1_(x_1982, &(param_62));\n  lightDir_Unused = x_1984;\n  let x_1985 : vec4<f32> = lightDir_Unused;\n  (*(clusterLightData_2)).direction = vec3<f32>(x_1985.x, x_1985.y, x_1985.z);\n  return;\n}\n\nfn getLightDirPoint_vf3_(lightPosW : ptr<function, vec3<f32>>) {\n  let x_430 : vec3<f32> = vPositionW;\n  let x_431 : vec3<f32> = *(lightPosW);\n  dLightDirW = (x_430 - x_431);\n  let x_434 : vec3<f32> = dLightDirW;\n  dLightDirNormW = normalize(x_434);\n  let x_437 : vec3<f32> = *(lightPosW);\n  dLightPosW = x_437;\n  return;\n}\n\nfn decodeClusterLightAreaData_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_(clusterLightData_4 : ptr<function, ClusterLightData>) {\n  var param_66 : i32;\n  var param_67 : i32;\n  let x_2008 : ClusterLightData = *(clusterLightData_4);\n  param_66 = 6i;\n  let x_2010 : vec4<f32> = sampleLightTextureF_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_i1_(x_2008, &(param_66));\n  (*(clusterLightData_4)).halfWidth = vec3<f32>(x_2010.x, x_2010.y, x_2010.z);\n  let x_2013 : ClusterLightData = *(clusterLightData_4);\n  param_67 = 7i;\n  let x_2015 : vec4<f32> = sampleLightTextureF_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_i1_(x_2013, &(param_67));\n  (*(clusterLightData_4)).halfHeight = vec3<f32>(x_2015.x, x_2015.y, x_2015.z);\n  return;\n}\n\nfn getLTCLightCoords_vf3_vf3_vf3_(lightPos : ptr<function, vec3<f32>>, halfWidth : ptr<function, vec3<f32>>, halfHeight : ptr<function, vec3<f32>>) -> Coords {\n  var coords_1 : Coords;\n  let x_834 : vec3<f32> = *(lightPos);\n  let x_835 : vec3<f32> = *(halfWidth);\n  let x_837 : vec3<f32> = *(halfHeight);\n  coords_1.coord0 = ((x_834 + x_835) - x_837);\n  let x_840 : vec3<f32> = *(lightPos);\n  let x_841 : vec3<f32> = *(halfWidth);\n  let x_843 : vec3<f32> = *(halfHeight);\n  coords_1.coord1 = ((x_840 - x_841) - x_843);\n  let x_846 : vec3<f32> = *(lightPos);\n  let x_847 : vec3<f32> = *(halfWidth);\n  let x_849 : vec3<f32> = *(halfHeight);\n  coords_1.coord2 = ((x_846 - x_847) + x_849);\n  let x_852 : vec3<f32> = *(lightPos);\n  let x_853 : vec3<f32> = *(halfWidth);\n  let x_855 : vec3<f32> = *(halfHeight);\n  coords_1.coord3 = ((x_852 + x_853) + x_855);\n  let x_858 : Coords = coords_1;\n  return x_858;\n}\n\nfn calcRectLightValues_vf3_vf3_vf3_(lightPos_2 : ptr<function, vec3<f32>>, halfWidth_2 : ptr<function, vec3<f32>>, halfHeight_2 : ptr<function, vec3<f32>>) {\n  var param_17 : vec3<f32>;\n  var param_18 : vec3<f32>;\n  var param_19 : vec3<f32>;\n  let x_964 : vec3<f32> = *(lightPos_2);\n  param_17 = x_964;\n  let x_966 : vec3<f32> = *(halfWidth_2);\n  param_18 = x_966;\n  let x_968 : vec3<f32> = *(halfHeight_2);\n  param_19 = x_968;\n  let x_969 : Coords = getLTCLightCoords_vf3_vf3_vf3_(&(param_17), &(param_18), &(param_19));\n  dLTCCoords = x_969;\n  return;\n}\n\nfn calcDiskLightValues_vf3_vf3_vf3_(lightPos_3 : ptr<function, vec3<f32>>, halfWidth_3 : ptr<function, vec3<f32>>, halfHeight_3 : ptr<function, vec3<f32>>) {\n  var param_20 : vec3<f32>;\n  var param_21 : vec3<f32>;\n  var param_22 : vec3<f32>;\n  let x_971 : vec3<f32> = *(lightPos_3);\n  param_20 = x_971;\n  let x_973 : vec3<f32> = *(halfWidth_3);\n  param_21 = x_973;\n  let x_975 : vec3<f32> = *(halfHeight_3);\n  param_22 = x_975;\n  calcRectLightValues_vf3_vf3_vf3_(&(param_20), &(param_21), &(param_22));\n  return;\n}\n\nfn getSphereLightCoords_vf3_vf3_vf3_(lightPos_1 : ptr<function, vec3<f32>>, halfWidth_1 : ptr<function, vec3<f32>>, halfHeight_1 : ptr<function, vec3<f32>>) -> Coords {\n  var f_1 : vec3<f32>;\n  var w : vec3<f32>;\n  var h_2 : vec3<f32>;\n  var param_9 : vec3<f32>;\n  var param_10 : vec3<f32>;\n  var param_11 : vec3<f32>;\n  let x_862 : vec3<f32> = *(halfWidth_1);\n  let x_864 : vec3<f32> = *(halfHeight_1);\n  dSphereRadius = max(length(x_862), length(x_864));\n  let x_868 : vec3<f32> = *(lightPos_1);\n  let x_870 : vec3<f32> = x_462.view_position;\n  let x_872 : vec3<f32> = normalize((x_868 - x_870));\n  let x_874 : vec3<f32> = vNormalW;\n  f_1 = reflect(x_872, x_874);\n  let x_877 : vec3<f32> = f_1;\n  let x_878 : vec3<f32> = *(halfHeight_1);\n  w = normalize(cross(x_877, x_878));\n  let x_882 : vec3<f32> = f_1;\n  let x_883 : vec3<f32> = w;\n  h_2 = normalize(cross(x_882, x_883));\n  let x_886 : vec3<f32> = w;\n  let x_887 : f32 = dSphereRadius;\n  let x_889 : vec3<f32> = h_2;\n  let x_890 : f32 = dSphereRadius;\n  let x_893 : vec3<f32> = *(lightPos_1);\n  param_9 = x_893;\n  param_10 = (x_886 * x_887);\n  param_11 = (x_889 * x_890);\n  let x_896 : Coords = getLTCLightCoords_vf3_vf3_vf3_(&(param_9), &(param_10), &(param_11));\n  return x_896;\n}\n\nfn calcSphereLightValues_vf3_vf3_vf3_(lightPos_4 : ptr<function, vec3<f32>>, halfWidth_4 : ptr<function, vec3<f32>>, halfHeight_4 : ptr<function, vec3<f32>>) {\n  var param_23 : vec3<f32>;\n  var param_24 : vec3<f32>;\n  var param_25 : vec3<f32>;\n  let x_978 : vec3<f32> = *(lightPos_4);\n  param_23 = x_978;\n  let x_980 : vec3<f32> = *(halfWidth_4);\n  param_24 = x_980;\n  let x_982 : vec3<f32> = *(halfHeight_4);\n  param_25 = x_982;\n  let x_983 : Coords = getSphereLightCoords_vf3_vf3_vf3_(&(param_23), &(param_24), &(param_25));\n  dLTCCoords = x_983;\n  return;\n}\n\nfn square_f1_(x : ptr<function, f32>) -> f32 {\n  let x_343 : f32 = *(x);\n  let x_344 : f32 = *(x);\n  return (x_343 * x_344);\n}\n\nfn getFalloffWindow_f1_vf3_(lightRadius : ptr<function, f32>, lightDir : ptr<function, vec3<f32>>) -> f32 {\n  var sqrDist : f32;\n  var invRadius : f32;\n  var param : f32;\n  var param_1 : f32;\n  var param_2 : f32;\n  var param_3 : f32;\n  let x_364 : vec3<f32> = *(lightDir);\n  let x_365 : vec3<f32> = *(lightDir);\n  sqrDist = dot(x_364, x_365);\n  let x_368 : f32 = *(lightRadius);\n  invRadius = (1.0f / x_368);\n  let x_370 : f32 = sqrDist;\n  let x_372 : f32 = invRadius;\n  param = x_372;\n  let x_373 : f32 = square_f1_(&(param));\n  param_1 = (x_370 * x_373);\n  let x_376 : f32 = square_f1_(&(param_1));\n  param_2 = (1.0f - x_376);\n  let x_379 : f32 = saturate_f1_(&(param_2));\n  param_3 = x_379;\n  let x_381 : f32 = square_f1_(&(param_3));\n  return x_381;\n}\n\nfn getFalloffLinear_f1_vf3_(lightRadius_2 : ptr<function, f32>, lightDir_2 : ptr<function, vec3<f32>>) -> f32 {\n  var d : f32;\n  let x_416 : vec3<f32> = *(lightDir_2);\n  d = length(x_416);\n  let x_418 : f32 = *(lightRadius_2);\n  let x_419 : f32 = d;\n  let x_421 : f32 = *(lightRadius_2);\n  return max(((x_418 - x_419) / x_421), 0.0f);\n}\n\nfn getFalloffInvSquared_f1_vf3_(lightRadius_1 : ptr<function, f32>, lightDir_1 : ptr<function, vec3<f32>>) -> f32 {\n  var sqrDist_1 : f32;\n  var falloff : f32;\n  var invRadius_1 : f32;\n  var param_4 : f32;\n  var param_5 : f32;\n  var param_6 : f32;\n  var param_7 : f32;\n  let x_385 : vec3<f32> = *(lightDir_1);\n  let x_386 : vec3<f32> = *(lightDir_1);\n  sqrDist_1 = dot(x_385, x_386);\n  let x_389 : f32 = sqrDist_1;\n  falloff = (1.0f / (x_389 + 1.0f));\n  let x_393 : f32 = *(lightRadius_1);\n  invRadius_1 = (1.0f / x_393);\n  let x_396 : f32 = falloff;\n  falloff = (x_396 * 16.0f);\n  let x_398 : f32 = sqrDist_1;\n  let x_400 : f32 = invRadius_1;\n  param_4 = x_400;\n  let x_401 : f32 = square_f1_(&(param_4));\n  param_5 = (x_398 * x_401);\n  let x_404 : f32 = square_f1_(&(param_5));\n  param_6 = (1.0f - x_404);\n  let x_407 : f32 = saturate_f1_(&(param_6));\n  param_7 = x_407;\n  let x_409 : f32 = square_f1_(&(param_7));\n  let x_410 : f32 = falloff;\n  falloff = (x_410 * x_409);\n  let x_412 : f32 = falloff;\n  return x_412;\n}\n\nfn transposeMat3_mf33_(m : mat3x3<f32>) -> mat3x3<f32> {\n  var tmp : mat3x3<f32>;\n  tmp[0i] = vec3<f32>(m[0u].x, m[1u].x, m[2u].x);\n  tmp[1i] = vec3<f32>(m[0u].y, m[1u].y, m[2u].y);\n  tmp[2i] = vec3<f32>(m[0u].z, m[1u].z, m[2u].z);\n  let x_623 : mat3x3<f32> = tmp;\n  return x_623;\n}\n\nfn LTC_EdgeVectorFormFactor_vf3_vf3_(v1 : vec3<f32>, v2 : vec3<f32>) -> vec3<f32> {\n  var x_3 : f32;\n  var y : f32;\n  var a : f32;\n  var b : f32;\n  var v : f32;\n  var theta_sintheta : f32;\n  var x_688 : f32;\n  x_3 = dot(v1, v2);\n  let x_660 : f32 = x_3;\n  y = abs(x_660);\n  let x_666 : f32 = y;\n  let x_669 : f32 = y;\n  a = (0.854398489f + ((0.496515512f + (0.0145206f * x_666)) * x_669));\n  let x_675 : f32 = y;\n  let x_677 : f32 = y;\n  b = (3.417593956f + ((4.161672592f + x_675) * x_677));\n  let x_681 : f32 = a;\n  let x_682 : f32 = b;\n  v = (x_681 / x_682);\n  let x_685 : f32 = x_3;\n  if ((x_685 > 0.0f)) {\n    let x_691 : f32 = v;\n    x_688 = x_691;\n  } else {\n    let x_694 : f32 = x_3;\n    let x_695 : f32 = x_3;\n    let x_701 : f32 = v;\n    x_688 = ((0.5f * inverseSqrt(max((1.0f - (x_694 * x_695)), 0.0000001f))) - x_701);\n  }\n  let x_703 : f32 = x_688;\n  theta_sintheta = x_703;\n  let x_705 : f32 = theta_sintheta;\n  return (cross(v1, v2) * x_705);\n}\n\nfn LTC_ClippedSphereFormFactor_vf3_(f : vec3<f32>) -> f32 {\n  var l : f32;\n  l = length(f);\n  let x_646 : f32 = l;\n  let x_647 : f32 = l;\n  let x_651 : f32 = l;\n  return max((((x_646 * x_647) + f.z) / (x_651 + 1.0f)), 0.0f);\n}\n\nfn LTC_EvaluateRect_vf3_vf3_vf3_mf33_struct_Coords_vf3_vf3_vf3_vf31_(N_1 : vec3<f32>, V_1 : vec3<f32>, P : vec3<f32>, mInv : mat3x3<f32>, rectCoords : Coords) -> f32 {\n  var v1_1 : vec3<f32>;\n  var v2_1 : vec3<f32>;\n  var lightNormal : vec3<f32>;\n  var factor : f32;\n  var T1 : vec3<f32>;\n  var T2 : vec3<f32>;\n  var mat : mat3x3<f32>;\n  var coords : array<vec3<f32>, 4u>;\n  var vectorFormFactor : vec3<f32>;\n  var result : f32;\n  v1_1 = (rectCoords.coord1 - rectCoords.coord0);\n  v2_1 = (rectCoords.coord3 - rectCoords.coord0);\n  let x_719 : vec3<f32> = v1_1;\n  let x_720 : vec3<f32> = v2_1;\n  lightNormal = cross(x_719, x_720);\n  let x_723 : vec3<f32> = lightNormal;\n  factor = sign(-(dot(x_723, (P - rectCoords.coord0))));\n  T1 = normalize((V_1 - (N_1 * dot(V_1, N_1))));\n  let x_735 : f32 = factor;\n  let x_736 : vec3<f32> = T1;\n  T2 = (cross(N_1, x_736) * x_735);\n  let x_740 : vec3<f32> = T1;\n  let x_741 : vec3<f32> = T2;\n  let x_755 : mat3x3<f32> = transposeMat3_mf33_(mat3x3<f32>(vec3<f32>(x_740.x, x_740.y, x_740.z), vec3<f32>(x_741.x, x_741.y, x_741.z), vec3<f32>(N_1.x, N_1.y, N_1.z)));\n  mat = (mInv * x_755);\n  let x_761 : mat3x3<f32> = mat;\n  coords[0i] = (x_761 * (rectCoords.coord0 - P));\n  let x_766 : mat3x3<f32> = mat;\n  coords[1i] = (x_766 * (rectCoords.coord1 - P));\n  let x_771 : mat3x3<f32> = mat;\n  coords[2i] = (x_771 * (rectCoords.coord2 - P));\n  let x_776 : mat3x3<f32> = mat;\n  coords[3i] = (x_776 * (rectCoords.coord3 - P));\n  let x_782 : vec3<f32> = coords[0i];\n  coords[0i] = normalize(x_782);\n  let x_786 : vec3<f32> = coords[1i];\n  coords[1i] = normalize(x_786);\n  let x_790 : vec3<f32> = coords[2i];\n  coords[2i] = normalize(x_790);\n  let x_794 : vec3<f32> = coords[3i];\n  coords[3i] = normalize(x_794);\n  vectorFormFactor = vec3<f32>(0.0f, 0.0f, 0.0f);\n  let x_800 : vec3<f32> = coords[0i];\n  let x_802 : vec3<f32> = coords[1i];\n  let x_803 : vec3<f32> = LTC_EdgeVectorFormFactor_vf3_vf3_(x_800, x_802);\n  let x_804 : vec3<f32> = vectorFormFactor;\n  vectorFormFactor = (x_804 + x_803);\n  let x_807 : vec3<f32> = coords[1i];\n  let x_809 : vec3<f32> = coords[2i];\n  let x_810 : vec3<f32> = LTC_EdgeVectorFormFactor_vf3_vf3_(x_807, x_809);\n  let x_811 : vec3<f32> = vectorFormFactor;\n  vectorFormFactor = (x_811 + x_810);\n  let x_814 : vec3<f32> = coords[2i];\n  let x_816 : vec3<f32> = coords[3i];\n  let x_817 : vec3<f32> = LTC_EdgeVectorFormFactor_vf3_vf3_(x_814, x_816);\n  let x_818 : vec3<f32> = vectorFormFactor;\n  vectorFormFactor = (x_818 + x_817);\n  let x_821 : vec3<f32> = coords[3i];\n  let x_823 : vec3<f32> = coords[0i];\n  let x_824 : vec3<f32> = LTC_EdgeVectorFormFactor_vf3_vf3_(x_821, x_823);\n  let x_825 : vec3<f32> = vectorFormFactor;\n  vectorFormFactor = (x_825 + x_824);\n  let x_828 : vec3<f32> = vectorFormFactor;\n  let x_829 : f32 = LTC_ClippedSphereFormFactor_vf3_(x_828);\n  result = x_829;\n  let x_830 : f32 = result;\n  return x_830;\n}\n\nfn getRectLightDiffuse_vf3_vf3_vf3_vf3_(worldNormal_3 : ptr<function, vec3<f32>>, viewDir_3 : ptr<function, vec3<f32>>, lightDir_4 : ptr<function, vec3<f32>>, lightDirNorm_2 : ptr<function, vec3<f32>>) -> f32 {\n  let x_1688 : vec3<f32> = *(worldNormal_3);\n  let x_1689 : vec3<f32> = *(viewDir_3);\n  let x_1690 : vec3<f32> = vPositionW;\n  let x_1695 : Coords = dLTCCoords;\n  let x_1696 : f32 = LTC_EvaluateRect_vf3_vf3_vf3_mf33_struct_Coords_vf3_vf3_vf3_vf31_(x_1688, x_1689, x_1690, mat3x3<f32>(vec3<f32>(1.0f, 0.0f, 0.0f), vec3<f32>(0.0f, 1.0f, 0.0f), vec3<f32>(0.0f, 0.0f, 1.0f)), x_1695);\n  return x_1696;\n}\n\nfn SolveCubic_vf4_(Coefficient : ptr<function, vec4<f32>>) -> vec3<f32> {\n  var pi : f32;\n  var A : f32;\n  var B : f32;\n  var C : f32;\n  var D : f32;\n  var Delta : vec3<f32>;\n  var Discriminant : f32;\n  var A_a : f32;\n  var C_a : f32;\n  var D_a : f32;\n  var Theta : f32;\n  var x_1a : f32;\n  var x_3a : f32;\n  var xl : f32;\n  var xlc : vec2<f32>;\n  var A_d : f32;\n  var C_d : f32;\n  var D_d : f32;\n  var Theta_1 : f32;\n  var x_1d : f32;\n  var x_3d : f32;\n  var xs : f32;\n  var xsc : vec2<f32>;\n  var E : f32;\n  var F : f32;\n  var G : f32;\n  var xmc : vec2<f32>;\n  var Root : vec3<f32>;\n  var x_1249 : bool;\n  var x_1250 : bool;\n  pi = 3.141590118f;\n  let x_988 : f32 = (*(Coefficient)).w;\n  let x_989 : vec4<f32> = *(Coefficient);\n  let x_992 : vec3<f32> = (vec3<f32>(x_989.x, x_989.y, x_989.z) / vec3<f32>(x_988, x_988, x_988));\n  let x_993 : vec4<f32> = *(Coefficient);\n  *(Coefficient) = vec4<f32>(x_992.x, x_992.y, x_992.z, x_993.w);\n  let x_996 : vec4<f32> = *(Coefficient);\n  let x_999 : vec2<f32> = (vec2<f32>(x_996.y, x_996.z) / vec2<f32>(3.0f, 3.0f));\n  let x_1000 : vec4<f32> = *(Coefficient);\n  *(Coefficient) = vec4<f32>(x_1000.x, x_999.x, x_999.y, x_1000.w);\n  let x_1004 : f32 = (*(Coefficient)).w;\n  A = x_1004;\n  let x_1007 : f32 = (*(Coefficient)).z;\n  B = x_1007;\n  let x_1010 : f32 = (*(Coefficient)).y;\n  C = x_1010;\n  let x_1013 : f32 = (*(Coefficient)).x;\n  D = x_1013;\n  let x_1016 : f32 = (*(Coefficient)).z;\n  let x_1019 : f32 = (*(Coefficient)).z;\n  let x_1022 : f32 = (*(Coefficient)).y;\n  let x_1025 : f32 = (*(Coefficient)).y;\n  let x_1028 : f32 = (*(Coefficient)).z;\n  let x_1031 : f32 = (*(Coefficient)).x;\n  let x_1034 : f32 = (*(Coefficient)).z;\n  let x_1036 : f32 = (*(Coefficient)).y;\n  let x_1039 : vec4<f32> = *(Coefficient);\n  Delta = vec3<f32>(((-(x_1016) * x_1019) + x_1022), ((-(x_1025) * x_1028) + x_1031), dot(vec2<f32>(x_1034, -(x_1036)), vec2<f32>(x_1039.x, x_1039.y)));\n  let x_1046 : f32 = Delta.x;\n  let x_1049 : f32 = Delta.y;\n  let x_1052 : vec3<f32> = Delta;\n  Discriminant = dot(vec2<f32>((4.0f * x_1046), -(x_1049)), vec2<f32>(x_1052.z, x_1052.y));\n  A_a = 1.0f;\n  let x_1058 : f32 = Delta.x;\n  C_a = x_1058;\n  let x_1061 : f32 = B;\n  let x_1064 : f32 = Delta.x;\n  let x_1067 : f32 = Delta.y;\n  D_a = (((-2.0f * x_1061) * x_1064) + x_1067);\n  let x_1070 : f32 = Discriminant;\n  let x_1072 : f32 = D_a;\n  Theta = (atan2(sqrt(x_1070), -(x_1072)) / 3.0f);\n  let x_1078 : f32 = C_a;\n  let x_1082 : f32 = Theta;\n  x_1a = ((2.0f * sqrt(-(x_1078))) * cos(x_1082));\n  let x_1086 : f32 = C_a;\n  let x_1090 : f32 = Theta;\n  let x_1092 : f32 = pi;\n  x_3a = ((2.0f * sqrt(-(x_1086))) * cos((x_1090 + (0.666666687f * x_1092))));\n  let x_1097 : f32 = x_1a;\n  let x_1098 : f32 = x_3a;\n  let x_1100 : f32 = B;\n  if (((x_1097 + x_1098) > (2.0f * x_1100))) {\n    let x_1106 : f32 = x_1a;\n    xl = x_1106;\n  } else {\n    let x_1108 : f32 = x_3a;\n    xl = x_1108;\n  }\n  let x_1110 : f32 = xl;\n  let x_1111 : f32 = B;\n  let x_1113 : f32 = A;\n  xlc = vec2<f32>((x_1110 - x_1111), x_1113);\n  let x_1116 : f32 = D;\n  A_d = x_1116;\n  let x_1119 : f32 = Delta.z;\n  C_d = x_1119;\n  let x_1121 : f32 = D;\n  let x_1124 : f32 = Delta.y;\n  let x_1126 : f32 = C;\n  let x_1129 : f32 = Delta.z;\n  D_d = ((-(x_1121) * x_1124) + ((2.0f * x_1126) * x_1129));\n  let x_1133 : f32 = D;\n  let x_1134 : f32 = Discriminant;\n  let x_1137 : f32 = D_d;\n  Theta_1 = (atan2((x_1133 * sqrt(x_1134)), -(x_1137)) / 3.0f);\n  let x_1142 : f32 = C_d;\n  let x_1146 : f32 = Theta_1;\n  x_1d = ((2.0f * sqrt(-(x_1142))) * cos(x_1146));\n  let x_1150 : f32 = C_d;\n  let x_1154 : f32 = Theta_1;\n  let x_1155 : f32 = pi;\n  x_3d = ((2.0f * sqrt(-(x_1150))) * cos((x_1154 + (0.666666687f * x_1155))));\n  let x_1160 : f32 = x_1d;\n  let x_1161 : f32 = x_3d;\n  let x_1163 : f32 = C;\n  if (((x_1160 + x_1161) < (2.0f * x_1163))) {\n    let x_1169 : f32 = x_1d;\n    xs = x_1169;\n  } else {\n    let x_1171 : f32 = x_3d;\n    xs = x_1171;\n  }\n  let x_1173 : f32 = D;\n  let x_1175 : f32 = xs;\n  let x_1176 : f32 = C;\n  xsc = vec2<f32>(-(x_1173), (x_1175 + x_1176));\n  let x_1181 : f32 = xlc.y;\n  let x_1183 : f32 = xsc.y;\n  E = (x_1181 * x_1183);\n  let x_1187 : f32 = xlc.x;\n  let x_1190 : f32 = xsc.y;\n  let x_1193 : f32 = xlc.y;\n  let x_1195 : f32 = xsc.x;\n  F = ((-(x_1187) * x_1190) - (x_1193 * x_1195));\n  let x_1200 : f32 = xlc.x;\n  let x_1202 : f32 = xsc.x;\n  G = (x_1200 * x_1202);\n  let x_1205 : f32 = C;\n  let x_1206 : f32 = F;\n  let x_1208 : f32 = B;\n  let x_1209 : f32 = G;\n  let x_1212 : f32 = B;\n  let x_1214 : f32 = F;\n  let x_1216 : f32 = C;\n  let x_1217 : f32 = E;\n  xmc = vec2<f32>(((x_1205 * x_1206) - (x_1208 * x_1209)), ((-(x_1212) * x_1214) + (x_1216 * x_1217)));\n  let x_1223 : f32 = xsc.x;\n  let x_1225 : f32 = xsc.y;\n  let x_1228 : f32 = xmc.x;\n  let x_1230 : f32 = xmc.y;\n  let x_1233 : f32 = xlc.x;\n  let x_1235 : f32 = xlc.y;\n  Root = vec3<f32>((x_1223 / x_1225), (x_1228 / x_1230), (x_1233 / x_1235));\n  let x_1239 : f32 = Root.x;\n  let x_1241 : f32 = Root.y;\n  let x_1242 : bool = (x_1239 < x_1241);\n  x_1250 = x_1242;\n  if (x_1242) {\n    let x_1246 : f32 = Root.x;\n    let x_1248 : f32 = Root.z;\n    x_1249 = (x_1246 < x_1248);\n    x_1250 = x_1249;\n  }\n  var x_1267 : bool;\n  var x_1268 : bool;\n  if (x_1250) {\n    let x_1253 : vec3<f32> = Root;\n    Root = vec3<f32>(x_1253.y, x_1253.x, x_1253.z);\n  } else {\n    let x_1257 : f32 = Root.z;\n    let x_1259 : f32 = Root.x;\n    let x_1260 : bool = (x_1257 < x_1259);\n    x_1268 = x_1260;\n    if (x_1260) {\n      let x_1264 : f32 = Root.z;\n      let x_1266 : f32 = Root.y;\n      x_1267 = (x_1264 < x_1266);\n      x_1268 = x_1267;\n    }\n    if (x_1268) {\n      let x_1271 : vec3<f32> = Root;\n      Root = vec3<f32>(x_1271.x, x_1271.z, x_1271.y);\n    }\n  }\n  let x_1273 : vec3<f32> = Root;\n  return x_1273;\n}\n\nfn LTC_EvaluateDisk_vf3_vf3_vf3_mf33_struct_Coords_vf3_vf3_vf3_vf31_(N_2 : ptr<function, vec3<f32>>, V_2 : ptr<function, vec3<f32>>, P_1 : ptr<function, vec3<f32>>, Minv : ptr<function, mat3x3<f32>>, points : ptr<function, Coords>) -> f32 {\n  var T1_1 : vec3<f32>;\n  var T2_1 : vec3<f32>;\n  var R : mat3x3<f32>;\n  var L_ : array<vec3<f32>, 3u>;\n  var Lo_i : vec3<f32>;\n  var C_1 : vec3<f32>;\n  var V1 : vec3<f32>;\n  var V2 : vec3<f32>;\n  var d11 : f32;\n  var d22 : f32;\n  var d12 : f32;\n  var tr : f32;\n  var det : f32;\n  var u : f32;\n  var v_1 : f32;\n  var e_max : f32;\n  var e_min : f32;\n  var V1_ : vec3<f32>;\n  var V2_ : vec3<f32>;\n  var a_1 : f32;\n  var b_1 : f32;\n  var V3 : vec3<f32>;\n  var L : f32;\n  var x0 : f32;\n  var y0 : f32;\n  var E1 : f32;\n  var E2 : f32;\n  var c0 : f32;\n  var c1 : f32;\n  var c2 : f32;\n  var c3 : f32;\n  var roots : vec3<f32>;\n  var param_26 : vec4<f32>;\n  var e1 : f32;\n  var e2 : f32;\n  var e3 : f32;\n  var avgDir : vec3<f32>;\n  var rotate : mat3x3<f32>;\n  var L1 : f32;\n  var L2 : f32;\n  var formFactor : f32;\n  var uv_5 : vec2<f32>;\n  var scale : f32;\n  let x_1277 : vec3<f32> = *(V_2);\n  let x_1278 : vec3<f32> = *(N_2);\n  let x_1279 : vec3<f32> = *(V_2);\n  let x_1280 : vec3<f32> = *(N_2);\n  T1_1 = normalize((x_1277 - (x_1278 * dot(x_1279, x_1280))));\n  let x_1286 : vec3<f32> = *(N_2);\n  let x_1287 : vec3<f32> = T1_1;\n  T2_1 = cross(x_1286, x_1287);\n  let x_1290 : vec3<f32> = T1_1;\n  let x_1291 : vec3<f32> = T2_1;\n  let x_1292 : vec3<f32> = *(N_2);\n  let x_1306 : mat3x3<f32> = transposeMat3_mf33_(mat3x3<f32>(vec3<f32>(x_1290.x, x_1290.y, x_1290.z), vec3<f32>(x_1291.x, x_1291.y, x_1291.z), vec3<f32>(x_1292.x, x_1292.y, x_1292.z)));\n  R = x_1306;\n  let x_1310 : mat3x3<f32> = R;\n  let x_1312 : vec3<f32> = (*(points)).coord0;\n  let x_1313 : vec3<f32> = *(P_1);\n  L_[0i] = (x_1310 * (x_1312 - x_1313));\n  let x_1317 : mat3x3<f32> = R;\n  let x_1319 : vec3<f32> = (*(points)).coord1;\n  let x_1320 : vec3<f32> = *(P_1);\n  L_[1i] = (x_1317 * (x_1319 - x_1320));\n  let x_1324 : mat3x3<f32> = R;\n  let x_1326 : vec3<f32> = (*(points)).coord2;\n  let x_1327 : vec3<f32> = *(P_1);\n  L_[2i] = (x_1324 * (x_1326 - x_1327));\n  Lo_i = vec3<f32>(0.0f, 0.0f, 0.0f);\n  let x_1334 : vec3<f32> = L_[0i];\n  let x_1336 : vec3<f32> = L_[2i];\n  C_1 = ((x_1334 + x_1336) * 0.5f);\n  let x_1341 : vec3<f32> = L_[1i];\n  let x_1343 : vec3<f32> = L_[2i];\n  V1 = ((x_1341 - x_1343) * 0.5f);\n  let x_1348 : vec3<f32> = L_[1i];\n  let x_1350 : vec3<f32> = L_[0i];\n  V2 = ((x_1348 - x_1350) * 0.5f);\n  let x_1353 : mat3x3<f32> = *(Minv);\n  let x_1354 : vec3<f32> = C_1;\n  C_1 = (x_1353 * x_1354);\n  let x_1356 : mat3x3<f32> = *(Minv);\n  let x_1357 : vec3<f32> = V1;\n  V1 = (x_1356 * x_1357);\n  let x_1359 : mat3x3<f32> = *(Minv);\n  let x_1360 : vec3<f32> = V2;\n  V2 = (x_1359 * x_1360);\n  let x_1363 : vec3<f32> = V1;\n  let x_1364 : vec3<f32> = V1;\n  d11 = dot(x_1363, x_1364);\n  let x_1367 : vec3<f32> = V2;\n  let x_1368 : vec3<f32> = V2;\n  d22 = dot(x_1367, x_1368);\n  let x_1371 : vec3<f32> = V1;\n  let x_1372 : vec3<f32> = V2;\n  d12 = dot(x_1371, x_1372);\n  let x_1374 : f32 = d12;\n  let x_1376 : f32 = d11;\n  let x_1377 : f32 = d22;\n  if (((abs(x_1374) / sqrt((x_1376 * x_1377))) > 0.0001f)) {\n    let x_1386 : f32 = d11;\n    let x_1387 : f32 = d22;\n    tr = (x_1386 + x_1387);\n    let x_1390 : f32 = d12;\n    let x_1392 : f32 = d12;\n    let x_1394 : f32 = d11;\n    let x_1395 : f32 = d22;\n    det = ((-(x_1390) * x_1392) + (x_1394 * x_1395));\n    let x_1398 : f32 = det;\n    det = sqrt(x_1398);\n    let x_1401 : f32 = tr;\n    let x_1402 : f32 = det;\n    u = (0.5f * sqrt((x_1401 - (2.0f * x_1402))));\n    let x_1408 : f32 = tr;\n    let x_1409 : f32 = det;\n    v_1 = (0.5f * sqrt((x_1408 + (2.0f * x_1409))));\n    let x_1415 : f32 = u;\n    let x_1416 : f32 = v_1;\n    let x_1418 : f32 = u;\n    let x_1419 : f32 = v_1;\n    e_max = ((x_1415 + x_1416) * (x_1418 + x_1419));\n    let x_1423 : f32 = u;\n    let x_1424 : f32 = v_1;\n    let x_1426 : f32 = u;\n    let x_1427 : f32 = v_1;\n    e_min = ((x_1423 - x_1424) * (x_1426 - x_1427));\n    let x_1430 : f32 = d11;\n    let x_1431 : f32 = d22;\n    if ((x_1430 > x_1431)) {\n      let x_1436 : f32 = d12;\n      let x_1437 : vec3<f32> = V1;\n      let x_1439 : f32 = e_max;\n      let x_1440 : f32 = d11;\n      let x_1442 : vec3<f32> = V2;\n      V1_ = ((x_1437 * x_1436) + (x_1442 * (x_1439 - x_1440)));\n      let x_1446 : f32 = d12;\n      let x_1447 : vec3<f32> = V1;\n      let x_1449 : f32 = e_min;\n      let x_1450 : f32 = d11;\n      let x_1452 : vec3<f32> = V2;\n      V2_ = ((x_1447 * x_1446) + (x_1452 * (x_1449 - x_1450)));\n    } else {\n      let x_1456 : f32 = d12;\n      let x_1457 : vec3<f32> = V2;\n      let x_1459 : f32 = e_max;\n      let x_1460 : f32 = d22;\n      let x_1462 : vec3<f32> = V1;\n      V1_ = ((x_1457 * x_1456) + (x_1462 * (x_1459 - x_1460)));\n      let x_1465 : f32 = d12;\n      let x_1466 : vec3<f32> = V2;\n      let x_1468 : f32 = e_min;\n      let x_1469 : f32 = d22;\n      let x_1471 : vec3<f32> = V1;\n      V2_ = ((x_1466 * x_1465) + (x_1471 * (x_1468 - x_1469)));\n    }\n    let x_1475 : f32 = e_max;\n    a_1 = (1.0f / x_1475);\n    let x_1478 : f32 = e_min;\n    b_1 = (1.0f / x_1478);\n    let x_1480 : vec3<f32> = V1_;\n    V1 = normalize(x_1480);\n    let x_1482 : vec3<f32> = V2_;\n    V2 = normalize(x_1482);\n  } else {\n    let x_1485 : vec3<f32> = V1;\n    let x_1486 : vec3<f32> = V1;\n    a_1 = (1.0f / dot(x_1485, x_1486));\n    let x_1489 : vec3<f32> = V2;\n    let x_1490 : vec3<f32> = V2;\n    b_1 = (1.0f / dot(x_1489, x_1490));\n    let x_1493 : f32 = a_1;\n    let x_1495 : vec3<f32> = V1;\n    V1 = (x_1495 * sqrt(x_1493));\n    let x_1497 : f32 = b_1;\n    let x_1499 : vec3<f32> = V2;\n    V2 = (x_1499 * sqrt(x_1497));\n  }\n  let x_1502 : vec3<f32> = V1;\n  let x_1503 : vec3<f32> = V2;\n  V3 = cross(x_1502, x_1503);\n  let x_1505 : vec3<f32> = C_1;\n  let x_1506 : vec3<f32> = V3;\n  if ((dot(x_1505, x_1506) < 0.0f)) {\n    let x_1512 : vec3<f32> = V3;\n    V3 = (x_1512 * -1.0f);\n  }\n  let x_1515 : vec3<f32> = V3;\n  let x_1516 : vec3<f32> = C_1;\n  L = dot(x_1515, x_1516);\n  let x_1519 : vec3<f32> = V1;\n  let x_1520 : vec3<f32> = C_1;\n  let x_1522 : f32 = L;\n  x0 = (dot(x_1519, x_1520) / x_1522);\n  let x_1525 : vec3<f32> = V2;\n  let x_1526 : vec3<f32> = C_1;\n  let x_1528 : f32 = L;\n  y0 = (dot(x_1525, x_1526) / x_1528);\n  let x_1531 : f32 = a_1;\n  E1 = inverseSqrt(x_1531);\n  let x_1534 : f32 = b_1;\n  E2 = inverseSqrt(x_1534);\n  let x_1536 : f32 = L;\n  let x_1537 : f32 = L;\n  let x_1539 : f32 = a_1;\n  a_1 = (x_1539 * (x_1536 * x_1537));\n  let x_1541 : f32 = L;\n  let x_1542 : f32 = L;\n  let x_1544 : f32 = b_1;\n  b_1 = (x_1544 * (x_1541 * x_1542));\n  let x_1547 : f32 = a_1;\n  let x_1548 : f32 = b_1;\n  c0 = (x_1547 * x_1548);\n  let x_1551 : f32 = a_1;\n  let x_1552 : f32 = b_1;\n  let x_1554 : f32 = x0;\n  let x_1555 : f32 = x0;\n  let x_1558 : f32 = y0;\n  let x_1559 : f32 = y0;\n  let x_1563 : f32 = a_1;\n  let x_1565 : f32 = b_1;\n  c1 = ((((x_1551 * x_1552) * ((1.0f + (x_1554 * x_1555)) + (x_1558 * x_1559))) - x_1563) - x_1565);\n  let x_1568 : f32 = a_1;\n  let x_1569 : f32 = x0;\n  let x_1570 : f32 = x0;\n  let x_1575 : f32 = b_1;\n  let x_1576 : f32 = y0;\n  let x_1577 : f32 = y0;\n  c2 = ((1.0f - (x_1568 * (1.0f + (x_1569 * x_1570)))) - (x_1575 * (1.0f + (x_1576 * x_1577))));\n  c3 = 1.0f;\n  let x_1584 : f32 = c0;\n  let x_1585 : f32 = c1;\n  let x_1586 : f32 = c2;\n  let x_1587 : f32 = c3;\n  param_26 = vec4<f32>(x_1584, x_1585, x_1586, x_1587);\n  let x_1590 : vec3<f32> = SolveCubic_vf4_(&(param_26));\n  roots = x_1590;\n  let x_1593 : f32 = roots.x;\n  e1 = x_1593;\n  let x_1596 : f32 = roots.y;\n  e2 = x_1596;\n  let x_1599 : f32 = roots.z;\n  e3 = x_1599;\n  let x_1601 : f32 = a_1;\n  let x_1602 : f32 = x0;\n  let x_1604 : f32 = a_1;\n  let x_1605 : f32 = e2;\n  let x_1608 : f32 = b_1;\n  let x_1609 : f32 = y0;\n  let x_1611 : f32 = b_1;\n  let x_1612 : f32 = e2;\n  avgDir = vec3<f32>(((x_1601 * x_1602) / (x_1604 - x_1605)), ((x_1608 * x_1609) / (x_1611 - x_1612)), 1.0f);\n  let x_1617 : vec3<f32> = V1;\n  let x_1618 : vec3<f32> = V2;\n  let x_1619 : vec3<f32> = V3;\n  rotate = mat3x3<f32>(vec3<f32>(x_1617.x, x_1617.y, x_1617.z), vec3<f32>(x_1618.x, x_1618.y, x_1618.z), vec3<f32>(x_1619.x, x_1619.y, x_1619.z));\n  let x_1633 : mat3x3<f32> = rotate;\n  let x_1634 : vec3<f32> = avgDir;\n  avgDir = (x_1633 * x_1634);\n  let x_1636 : vec3<f32> = avgDir;\n  avgDir = normalize(x_1636);\n  let x_1639 : f32 = e2;\n  let x_1641 : f32 = e3;\n  L1 = sqrt((-(x_1639) / x_1641));\n  let x_1645 : f32 = e2;\n  let x_1647 : f32 = e1;\n  L2 = sqrt((-(x_1645) / x_1647));\n  let x_1651 : f32 = L1;\n  let x_1652 : f32 = L2;\n  let x_1654 : f32 = L1;\n  let x_1655 : f32 = L1;\n  let x_1658 : f32 = L2;\n  let x_1659 : f32 = L2;\n  formFactor = ((x_1651 * x_1652) * inverseSqrt(((1.0f + (x_1654 * x_1655)) * (1.0f + (x_1658 * x_1659)))));\n  let x_1667 : f32 = avgDir.z;\n  let x_1670 : f32 = formFactor;\n  uv_5 = vec2<f32>(((x_1667 * 0.5f) + 0.5f), x_1670);\n  let x_1672 : vec2<f32> = uv_5;\n  uv_5 = ((x_1672 * 0.984375f) + vec2<f32>(0.0078125f, 0.0078125f));\n  let x_1680 : vec2<f32> = uv_5;\n  let x_1681 : vec4<f32> = textureSampleLevel(areaLightsLutTex2, areaLightsLutTex2_sampler, x_1680, 0.0f);\n  scale = x_1681.w;\n  let x_1683 : f32 = formFactor;\n  let x_1684 : f32 = scale;\n  return (x_1683 * x_1684);\n}\n\nfn getDiskLightDiffuse_vf3_vf3_vf3_vf3_(worldNormal_4 : ptr<function, vec3<f32>>, viewDir_4 : ptr<function, vec3<f32>>, lightDir_5 : ptr<function, vec3<f32>>, lightDirNorm_3 : ptr<function, vec3<f32>>) -> f32 {\n  var param_27 : vec3<f32>;\n  var param_28 : vec3<f32>;\n  var param_29 : vec3<f32>;\n  var param_30 : mat3x3<f32>;\n  var param_31 : Coords;\n  let x_1700 : vec3<f32> = *(worldNormal_4);\n  param_27 = x_1700;\n  let x_1702 : vec3<f32> = *(viewDir_4);\n  param_28 = x_1702;\n  let x_1704 : vec3<f32> = vPositionW;\n  param_29 = x_1704;\n  param_30 = mat3x3<f32>(vec3<f32>(1.0f, 0.0f, 0.0f), vec3<f32>(0.0f, 1.0f, 0.0f), vec3<f32>(0.0f, 0.0f, 1.0f));\n  let x_1707 : Coords = dLTCCoords;\n  param_31 = x_1707;\n  let x_1708 : f32 = LTC_EvaluateDisk_vf3_vf3_vf3_mf33_struct_Coords_vf3_vf3_vf3_vf31_(&(param_27), &(param_28), &(param_29), &(param_30), &(param_31));\n  return x_1708;\n}\n\nfn getLightDiffuse_vf3_vf3_vf3_vf3_(worldNormal : ptr<function, vec3<f32>>, viewDir : ptr<function, vec3<f32>>, lightDir_3 : ptr<function, vec3<f32>>, lightDirNorm_1 : ptr<function, vec3<f32>>) -> f32 {\n  let x_595 : vec3<f32> = *(worldNormal);\n  let x_596 : vec3<f32> = *(lightDirNorm_1);\n  return max(dot(x_595, -(x_596)), 0.0f);\n}\n\nfn getSphereLightDiffuse_vf3_vf3_vf3_vf3_(worldNormal_5 : ptr<function, vec3<f32>>, viewDir_5 : ptr<function, vec3<f32>>, lightDir_6 : ptr<function, vec3<f32>>, lightDirNorm_4 : ptr<function, vec3<f32>>) -> f32 {\n  var falloff_1 : f32;\n  var param_32 : vec3<f32>;\n  var param_33 : vec3<f32>;\n  var param_34 : vec3<f32>;\n  var param_35 : vec3<f32>;\n  let x_1712 : f32 = dSphereRadius;\n  let x_1713 : vec3<f32> = *(lightDir_6);\n  let x_1714 : vec3<f32> = *(lightDir_6);\n  let x_1716 : f32 = dSphereRadius;\n  falloff_1 = (x_1712 / (dot(x_1713, x_1714) + x_1716));\n  let x_1720 : vec3<f32> = *(worldNormal_5);\n  param_32 = x_1720;\n  let x_1722 : vec3<f32> = *(viewDir_5);\n  param_33 = x_1722;\n  let x_1724 : vec3<f32> = *(lightDir_6);\n  param_34 = x_1724;\n  let x_1726 : vec3<f32> = *(lightDirNorm_4);\n  param_35 = x_1726;\n  let x_1727 : f32 = getLightDiffuse_vf3_vf3_vf3_vf3_(&(param_32), &(param_33), &(param_34), &(param_35));\n  let x_1728 : f32 = falloff_1;\n  return (x_1727 * x_1728);\n}\n\nfn decodeClusterLightSpot_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_(clusterLightData_3 : ptr<function, ClusterLightData>) {\n  var coneAngle : vec4<f32>;\n  var param_63 : i32;\n  var param_64 : vec2<f32>;\n  var param_65 : vec2<f32>;\n  let x_1989 : ClusterLightData = *(clusterLightData_3);\n  param_63 = 3i;\n  let x_1991 : vec4<f32> = sampleLightsTexture8_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_i1_(x_1989, &(param_63));\n  coneAngle = x_1991;\n  let x_1994 : vec4<f32> = coneAngle;\n  param_64 = vec2<f32>(x_1994.x, x_1994.y);\n  let x_1996 : f32 = bytes2float2_vf2_(&(param_64));\n  (*(clusterLightData_3)).innerConeAngleCos = ((x_1996 * 2.0f) - 1.0f);\n  let x_2002 : vec4<f32> = coneAngle;\n  param_65 = vec2<f32>(x_2002.z, x_2002.w);\n  let x_2004 : f32 = bytes2float2_vf2_(&(param_65));\n  (*(clusterLightData_3)).outerConeAngleCos = ((x_2004 * 2.0f) - 1.0f);\n  return;\n}\n\nfn getSpotEffect_vf3_f1_f1_vf3_(lightSpotDirW : ptr<function, vec3<f32>>, lightInnerConeAngle : ptr<function, f32>, lightOuterConeAngle : ptr<function, f32>, lightDirNorm : ptr<function, vec3<f32>>) -> f32 {\n  var cosAngle : f32;\n  let x_354 : vec3<f32> = *(lightDirNorm);\n  let x_355 : vec3<f32> = *(lightSpotDirW);\n  cosAngle = dot(x_354, x_355);\n  let x_357 : f32 = *(lightOuterConeAngle);\n  let x_358 : f32 = *(lightInnerConeAngle);\n  let x_359 : f32 = cosAngle;\n  return smoothstep(x_357, x_358, x_359);\n}\n\nfn getLTCLightInvMat_vf2_(uv_1 : ptr<function, vec2<f32>>) -> mat3x3<f32> {\n  var t1 : vec4<f32>;\n  let x_1738 : vec2<f32> = *(uv_1);\n  let x_1739 : vec4<f32> = textureSampleLevel(areaLightsLutTex1, areaLightsLutTex1_sampler, x_1738, 0.0f);\n  t1 = x_1739;\n  let x_1744 : vec4<f32> = t1;\n  t1 = (x_1744 * vec4<f32>(1.001000047f, 0.323900014f, 0.60437566f, 1.0f));\n  let x_1749 : vec4<f32> = t1;\n  t1 = (x_1749 + vec4<f32>(0.0f, -0.297600001f, -0.01381f, 0.0f));\n  let x_1752 : f32 = t1.x;\n  let x_1754 : f32 = t1.y;\n  let x_1755 : vec3<f32> = vec3<f32>(x_1752, 0.0f, x_1754);\n  let x_1757 : f32 = t1.z;\n  let x_1759 : f32 = t1.w;\n  let x_1760 : vec3<f32> = vec3<f32>(x_1757, 0.0f, x_1759);\n  return mat3x3<f32>(vec3<f32>(x_1755.x, x_1755.y, x_1755.z), vec3<f32>(vec3<f32>(0.0f, 1.0f, 0.0f).x, vec3<f32>(0.0f, 1.0f, 0.0f).y, vec3<f32>(0.0f, 1.0f, 0.0f).z), vec3<f32>(x_1760.x, x_1760.y, x_1760.z));\n}\n\nfn calcRectLightSpecular_vf3_vf3_vf2_(worldNormal_6 : ptr<function, vec3<f32>>, viewDir_6 : ptr<function, vec3<f32>>, uv_2 : ptr<function, vec2<f32>>) -> f32 {\n  var mInv_1 : mat3x3<f32>;\n  var param_36 : vec2<f32>;\n  let x_1778 : vec2<f32> = *(uv_2);\n  param_36 = x_1778;\n  let x_1779 : mat3x3<f32> = getLTCLightInvMat_vf2_(&(param_36));\n  mInv_1 = x_1779;\n  let x_1780 : vec3<f32> = *(worldNormal_6);\n  let x_1781 : vec3<f32> = *(viewDir_6);\n  let x_1782 : vec3<f32> = vPositionW;\n  let x_1783 : mat3x3<f32> = mInv_1;\n  let x_1784 : Coords = dLTCCoords;\n  let x_1785 : f32 = LTC_EvaluateRect_vf3_vf3_vf3_mf33_struct_Coords_vf3_vf3_vf3_vf31_(x_1780, x_1781, x_1782, x_1783, x_1784);\n  return x_1785;\n}\n\nfn getRectLightSpecular_vf3_vf3_(worldNormal_7 : ptr<function, vec3<f32>>, viewDir_7 : ptr<function, vec3<f32>>) -> f32 {\n  var param_37 : vec3<f32>;\n  var param_38 : vec3<f32>;\n  var param_39 : vec2<f32>;\n  let x_1789 : vec3<f32> = *(worldNormal_7);\n  param_37 = x_1789;\n  let x_1791 : vec3<f32> = *(viewDir_7);\n  param_38 = x_1791;\n  let x_1793 : vec2<f32> = dLTCUV;\n  param_39 = x_1793;\n  let x_1794 : f32 = calcRectLightSpecular_vf3_vf3_vf2_(&(param_37), &(param_38), &(param_39));\n  return x_1794;\n}\n\nfn calcDiskLightSpecular_vf3_vf3_vf2_(worldNormal_8 : ptr<function, vec3<f32>>, viewDir_8 : ptr<function, vec3<f32>>, uv_3 : ptr<function, vec2<f32>>) -> f32 {\n  var mInv_2 : mat3x3<f32>;\n  var param_40 : vec2<f32>;\n  var param_41 : vec3<f32>;\n  var param_42 : vec3<f32>;\n  var param_43 : vec3<f32>;\n  var param_44 : mat3x3<f32>;\n  var param_45 : Coords;\n  let x_1799 : vec2<f32> = *(uv_3);\n  param_40 = x_1799;\n  let x_1800 : mat3x3<f32> = getLTCLightInvMat_vf2_(&(param_40));\n  mInv_2 = x_1800;\n  let x_1802 : vec3<f32> = *(worldNormal_8);\n  param_41 = x_1802;\n  let x_1804 : vec3<f32> = *(viewDir_8);\n  param_42 = x_1804;\n  let x_1806 : vec3<f32> = vPositionW;\n  param_43 = x_1806;\n  let x_1808 : mat3x3<f32> = mInv_2;\n  param_44 = x_1808;\n  let x_1810 : Coords = dLTCCoords;\n  param_45 = x_1810;\n  let x_1811 : f32 = LTC_EvaluateDisk_vf3_vf3_vf3_mf33_struct_Coords_vf3_vf3_vf3_vf31_(&(param_41), &(param_42), &(param_43), &(param_44), &(param_45));\n  return x_1811;\n}\n\nfn getDiskLightSpecular_vf3_vf3_(worldNormal_9 : ptr<function, vec3<f32>>, viewDir_9 : ptr<function, vec3<f32>>) -> f32 {\n  var param_46 : vec3<f32>;\n  var param_47 : vec3<f32>;\n  var param_48 : vec2<f32>;\n  let x_1815 : vec3<f32> = *(worldNormal_9);\n  param_46 = x_1815;\n  let x_1817 : vec3<f32> = *(viewDir_9);\n  param_47 = x_1817;\n  let x_1819 : vec2<f32> = dLTCUV;\n  param_48 = x_1819;\n  let x_1820 : f32 = calcDiskLightSpecular_vf3_vf3_vf2_(&(param_46), &(param_47), &(param_48));\n  return x_1820;\n}\n\nfn getSphereLightSpecular_vf3_vf3_(worldNormal_10 : ptr<function, vec3<f32>>, viewDir_10 : ptr<function, vec3<f32>>) -> f32 {\n  var param_49 : vec3<f32>;\n  var param_50 : vec3<f32>;\n  var param_51 : vec2<f32>;\n  let x_1824 : vec3<f32> = *(worldNormal_10);\n  param_49 = x_1824;\n  let x_1826 : vec3<f32> = *(viewDir_10);\n  param_50 = x_1826;\n  let x_1828 : vec2<f32> = dLTCUV;\n  param_51 = x_1828;\n  let x_1829 : f32 = calcDiskLightSpecular_vf3_vf3_vf2_(&(param_49), &(param_50), &(param_51));\n  return x_1829;\n}\n\nfn calcLightSpecular_f1_vf3_vf3_(gloss_3 : ptr<function, f32>, worldNormal_11 : ptr<function, vec3<f32>>, h : ptr<function, vec3<f32>>) -> f32 {\n  var nh : f32;\n  var specPow : f32;\n  let x_1833 : vec3<f32> = *(h);\n  let x_1834 : vec3<f32> = *(worldNormal_11);\n  nh = max(dot(x_1833, x_1834), 0.0f);\n  let x_1838 : f32 = *(gloss_3);\n  specPow = exp2((x_1838 * 11.0f));\n  let x_1842 : f32 = specPow;\n  specPow = max(x_1842, 0.0001f);\n  let x_1844 : f32 = nh;\n  let x_1845 : f32 = specPow;\n  let x_1847 : f32 = specPow;\n  return ((pow(x_1844, x_1845) * (x_1847 + 2.0f)) / 8.0f);\n}\n\nfn getLightSpecular_vf3_vf3_vf3_vf3_vf3_f1_mf33_(h_1 : ptr<function, vec3<f32>>, reflDir : ptr<function, vec3<f32>>, worldNormal_12 : ptr<function, vec3<f32>>, viewDir_11 : ptr<function, vec3<f32>>, lightDirNorm_5 : ptr<function, vec3<f32>>, gloss_4 : ptr<function, f32>, tbn : ptr<function, mat3x3<f32>>) -> f32 {\n  var param_52 : f32;\n  var param_53 : vec3<f32>;\n  var param_54 : vec3<f32>;\n  let x_1855 : f32 = *(gloss_4);\n  param_52 = x_1855;\n  let x_1857 : vec3<f32> = *(worldNormal_12);\n  param_53 = x_1857;\n  let x_1859 : vec3<f32> = *(h_1);\n  param_54 = x_1859;\n  let x_1860 : f32 = calcLightSpecular_f1_vf3_vf3_(&(param_52), &(param_53), &(param_54));\n  return x_1860;\n}\n\nfn getFresnel_f1_f1_vf3_(cosTheta : ptr<function, f32>, gloss : ptr<function, f32>, specularity : ptr<function, vec3<f32>>) -> vec3<f32> {\n  var fresnel : f32;\n  var glossSq : f32;\n  var ret : vec3<f32>;\n  let x_572 : f32 = *(cosTheta);\n  fresnel = pow((1.0f - max(x_572, 0.0f)), 5.0f);\n  let x_578 : f32 = *(gloss);\n  let x_579 : f32 = *(gloss);\n  glossSq = (x_578 * x_579);\n  let x_582 : vec3<f32> = *(specularity);\n  let x_583 : f32 = glossSq;\n  let x_585 : vec3<f32> = *(specularity);\n  let x_587 : vec3<f32> = *(specularity);\n  let x_589 : f32 = fresnel;\n  ret = (x_582 + ((max(vec3<f32>(x_583, x_583, x_583), x_585) - x_587) * x_589));\n  let x_592 : vec3<f32> = ret;\n  return x_592;\n}\n\nfn evaluateLight_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_vf3_vf3_vf3_f1_vf3_vf3_mf33_struct_ClearcoatArgs_f1_f1_vf31_struct_SheenArgs_f1_vf31_struct_IridescenceArgs_f1_f11_(light : ptr<function, ClusterLightData>, worldNormal_15 : ptr<function, vec3<f32>>, viewDir_13 : ptr<function, vec3<f32>>, reflectionDir : ptr<function, vec3<f32>>, gloss_6 : ptr<function, f32>, specularity_3 : ptr<function, vec3<f32>>, geometricNormal : ptr<function, vec3<f32>>, tbn_2 : ptr<function, mat3x3<f32>>, clearcoat : ptr<function, ClearcoatArgs>, sheen : ptr<function, SheenArgs>, iridescence : ptr<function, IridescenceArgs>) {\n  var cookieAttenuation : vec3<f32>;\n  var diffuseAttenuation : f32;\n  var falloffAttenuation : f32;\n  var param_68 : vec3<f32>;\n  var param_69 : ClusterLightData;\n  var param_70 : vec3<f32>;\n  var param_71 : vec3<f32>;\n  var param_72 : vec3<f32>;\n  var param_73 : vec3<f32>;\n  var param_74 : vec3<f32>;\n  var param_75 : vec3<f32>;\n  var param_76 : vec3<f32>;\n  var param_77 : vec3<f32>;\n  var param_78 : vec3<f32>;\n  var param_79 : f32;\n  var param_80 : vec3<f32>;\n  var param_81 : f32;\n  var param_82 : vec3<f32>;\n  var param_83 : f32;\n  var param_84 : vec3<f32>;\n  var param_85 : vec3<f32>;\n  var param_86 : vec3<f32>;\n  var param_87 : vec3<f32>;\n  var param_88 : vec3<f32>;\n  var param_89 : vec3<f32>;\n  var param_90 : vec3<f32>;\n  var param_91 : vec3<f32>;\n  var param_92 : vec3<f32>;\n  var param_93 : vec3<f32>;\n  var param_94 : vec3<f32>;\n  var param_95 : vec3<f32>;\n  var param_96 : vec3<f32>;\n  var param_97 : vec3<f32>;\n  var param_98 : vec3<f32>;\n  var param_99 : vec3<f32>;\n  var param_100 : vec3<f32>;\n  var param_101 : ClusterLightData;\n  var param_102 : vec3<f32>;\n  var param_103 : f32;\n  var param_104 : f32;\n  var param_105 : vec3<f32>;\n  var areaDiffuse : vec3<f32>;\n  var areaLightSpecular : f32;\n  var param_106 : vec3<f32>;\n  var param_107 : vec3<f32>;\n  var param_108 : vec3<f32>;\n  var param_109 : vec3<f32>;\n  var param_110 : vec3<f32>;\n  var param_111 : vec3<f32>;\n  var punctualDiffuse : vec3<f32>;\n  var halfDir : vec3<f32>;\n  var param_112 : vec3<f32>;\n  var param_113 : vec3<f32>;\n  var param_114 : vec3<f32>;\n  var param_115 : vec3<f32>;\n  var param_116 : vec3<f32>;\n  var param_117 : f32;\n  var param_118 : mat3x3<f32>;\n  var param_119 : f32;\n  var param_120 : f32;\n  var param_121 : vec3<f32>;\n  cookieAttenuation = vec3<f32>(1.0f, 1.0f, 1.0f);\n  diffuseAttenuation = 1.0f;\n  falloffAttenuation = 1.0f;\n  let x_2023 : vec3<f32> = (*(light)).position;\n  param_68 = x_2023;\n  getLightDirPoint_vf3_(&(param_68));\n  let x_2026 : f32 = (*(light)).shape;\n  if ((x_2026 > 0.100000001f)) {\n    let x_2032 : ClusterLightData = *(light);\n    param_69 = x_2032;\n    decodeClusterLightAreaData_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_(&(param_69));\n    let x_2034 : ClusterLightData = param_69;\n    *(light) = x_2034;\n    let x_2036 : f32 = (*(light)).shape;\n    if ((x_2036 < 0.300000012f)) {\n      let x_2043 : vec3<f32> = (*(light)).position;\n      param_70 = x_2043;\n      let x_2046 : vec3<f32> = (*(light)).halfWidth;\n      param_71 = x_2046;\n      let x_2049 : vec3<f32> = (*(light)).halfHeight;\n      param_72 = x_2049;\n      calcRectLightValues_vf3_vf3_vf3_(&(param_70), &(param_71), &(param_72));\n    } else {\n      let x_2053 : f32 = (*(light)).shape;\n      if ((x_2053 < 0.600000024f)) {\n        let x_2060 : vec3<f32> = (*(light)).position;\n        param_73 = x_2060;\n        let x_2063 : vec3<f32> = (*(light)).halfWidth;\n        param_74 = x_2063;\n        let x_2066 : vec3<f32> = (*(light)).halfHeight;\n        param_75 = x_2066;\n        calcDiskLightValues_vf3_vf3_vf3_(&(param_73), &(param_74), &(param_75));\n      } else {\n        let x_2071 : vec3<f32> = (*(light)).position;\n        param_76 = x_2071;\n        let x_2074 : vec3<f32> = (*(light)).halfWidth;\n        param_77 = x_2074;\n        let x_2077 : vec3<f32> = (*(light)).halfHeight;\n        param_78 = x_2077;\n        calcSphereLightValues_vf3_vf3_vf3_(&(param_76), &(param_77), &(param_78));\n      }\n    }\n    let x_2081 : f32 = (*(light)).range;\n    param_79 = x_2081;\n    let x_2083 : vec3<f32> = dLightDirW;\n    param_80 = x_2083;\n    let x_2084 : f32 = getFalloffWindow_f1_vf3_(&(param_79), &(param_80));\n    falloffAttenuation = x_2084;\n  } else {\n    let x_2087 : f32 = (*(light)).falloffMode;\n    if ((x_2087 < 0.5f)) {\n      let x_2093 : f32 = (*(light)).range;\n      param_81 = x_2093;\n      let x_2095 : vec3<f32> = dLightDirW;\n      param_82 = x_2095;\n      let x_2096 : f32 = getFalloffLinear_f1_vf3_(&(param_81), &(param_82));\n      falloffAttenuation = x_2096;\n    } else {\n      let x_2100 : f32 = (*(light)).range;\n      param_83 = x_2100;\n      let x_2102 : vec3<f32> = dLightDirW;\n      param_84 = x_2102;\n      let x_2103 : f32 = getFalloffInvSquared_f1_vf3_(&(param_83), &(param_84));\n      falloffAttenuation = x_2103;\n    }\n  }\n  let x_2104 : f32 = falloffAttenuation;\n  if ((x_2104 > 0.00001f)) {\n    let x_2110 : f32 = (*(light)).shape;\n    if ((x_2110 > 0.100000001f)) {\n      let x_2115 : f32 = (*(light)).shape;\n      if ((x_2115 < 0.300000012f)) {\n        let x_2120 : vec3<f32> = *(worldNormal_15);\n        param_85 = x_2120;\n        let x_2122 : vec3<f32> = *(viewDir_13);\n        param_86 = x_2122;\n        let x_2124 : vec3<f32> = dLightDirW;\n        param_87 = x_2124;\n        let x_2126 : vec3<f32> = dLightDirNormW;\n        param_88 = x_2126;\n        let x_2127 : f32 = getRectLightDiffuse_vf3_vf3_vf3_vf3_(&(param_85), &(param_86), &(param_87), &(param_88));\n        diffuseAttenuation = (x_2127 * 16.0f);\n      } else {\n        let x_2131 : f32 = (*(light)).shape;\n        if ((x_2131 < 0.600000024f)) {\n          let x_2136 : vec3<f32> = *(worldNormal_15);\n          param_89 = x_2136;\n          let x_2138 : vec3<f32> = *(viewDir_13);\n          param_90 = x_2138;\n          let x_2140 : vec3<f32> = dLightDirW;\n          param_91 = x_2140;\n          let x_2142 : vec3<f32> = dLightDirNormW;\n          param_92 = x_2142;\n          let x_2143 : f32 = getDiskLightDiffuse_vf3_vf3_vf3_vf3_(&(param_89), &(param_90), &(param_91), &(param_92));\n          diffuseAttenuation = (x_2143 * 16.0f);\n        } else {\n          let x_2147 : vec3<f32> = *(worldNormal_15);\n          param_93 = x_2147;\n          let x_2149 : vec3<f32> = *(viewDir_13);\n          param_94 = x_2149;\n          let x_2151 : vec3<f32> = dLightDirW;\n          param_95 = x_2151;\n          let x_2153 : vec3<f32> = dLightDirNormW;\n          param_96 = x_2153;\n          let x_2154 : f32 = getSphereLightDiffuse_vf3_vf3_vf3_vf3_(&(param_93), &(param_94), &(param_95), &(param_96));\n          diffuseAttenuation = (x_2154 * 16.0f);\n        }\n      }\n    } else {\n      let x_2158 : vec3<f32> = *(worldNormal_15);\n      param_97 = x_2158;\n      let x_2160 : vec3<f32> = *(viewDir_13);\n      param_98 = x_2160;\n      let x_2162 : vec3<f32> = dLightDirW;\n      param_99 = x_2162;\n      let x_2164 : vec3<f32> = dLightDirNormW;\n      param_100 = x_2164;\n      let x_2165 : f32 = getLightDiffuse_vf3_vf3_vf3_vf3_(&(param_97), &(param_98), &(param_99), &(param_100));\n      let x_2166 : f32 = falloffAttenuation;\n      falloffAttenuation = (x_2166 * x_2165);\n    }\n    let x_2169 : f32 = (*(light)).lightType;\n    if ((x_2169 > 0.5f)) {\n      let x_2174 : ClusterLightData = *(light);\n      param_101 = x_2174;\n      decodeClusterLightSpot_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_(&(param_101));\n      let x_2176 : ClusterLightData = param_101;\n      *(light) = x_2176;\n      let x_2179 : vec3<f32> = (*(light)).direction;\n      param_102 = x_2179;\n      let x_2182 : f32 = (*(light)).innerConeAngleCos;\n      param_103 = x_2182;\n      let x_2185 : f32 = (*(light)).outerConeAngleCos;\n      param_104 = x_2185;\n      let x_2187 : vec3<f32> = dLightDirNormW;\n      param_105 = x_2187;\n      let x_2188 : f32 = getSpotEffect_vf3_f1_f1_vf3_(&(param_102), &(param_103), &(param_104), &(param_105));\n      let x_2189 : f32 = falloffAttenuation;\n      falloffAttenuation = (x_2189 * x_2188);\n    }\n    let x_2192 : f32 = (*(light)).shape;\n    if ((x_2192 > 0.100000001f)) {\n      let x_2197 : f32 = diffuseAttenuation;\n      let x_2198 : f32 = falloffAttenuation;\n      let x_2201 : vec3<f32> = (*(light)).color;\n      let x_2203 : vec3<f32> = cookieAttenuation;\n      areaDiffuse = ((x_2201 * (x_2197 * x_2198)) * x_2203);\n      let x_2205 : vec3<f32> = areaDiffuse;\n      let x_2206 : vec3<f32> = dLTCSpecFres;\n      areaDiffuse = mix(x_2205, vec3<f32>(0.0f, 0.0f, 0.0f), x_2206);\n      let x_2208 : vec3<f32> = areaDiffuse;\n      let x_2209 : vec3<f32> = dDiffuseLight;\n      dDiffuseLight = (x_2209 + x_2208);\n      let x_2212 : f32 = (*(light)).shape;\n      if ((x_2212 < 0.300000012f)) {\n        let x_2218 : vec3<f32> = *(worldNormal_15);\n        param_106 = x_2218;\n        let x_2220 : vec3<f32> = *(viewDir_13);\n        param_107 = x_2220;\n        let x_2221 : f32 = getRectLightSpecular_vf3_vf3_(&(param_106), &(param_107));\n        areaLightSpecular = x_2221;\n      } else {\n        let x_2224 : f32 = (*(light)).shape;\n        if ((x_2224 < 0.600000024f)) {\n          let x_2229 : vec3<f32> = *(worldNormal_15);\n          param_108 = x_2229;\n          let x_2231 : vec3<f32> = *(viewDir_13);\n          param_109 = x_2231;\n          let x_2232 : f32 = getDiskLightSpecular_vf3_vf3_(&(param_108), &(param_109));\n          areaLightSpecular = x_2232;\n        } else {\n          let x_2235 : vec3<f32> = *(worldNormal_15);\n          param_110 = x_2235;\n          let x_2237 : vec3<f32> = *(viewDir_13);\n          param_111 = x_2237;\n          let x_2238 : f32 = getSphereLightSpecular_vf3_vf3_(&(param_110), &(param_111));\n          areaLightSpecular = x_2238;\n        }\n      }\n      let x_2239 : vec3<f32> = dLTCSpecFres;\n      let x_2240 : f32 = areaLightSpecular;\n      let x_2242 : f32 = falloffAttenuation;\n      let x_2245 : vec3<f32> = (*(light)).color;\n      let x_2247 : vec3<f32> = cookieAttenuation;\n      let x_2249 : vec3<f32> = dSpecularLight;\n      dSpecularLight = (x_2249 + ((((x_2239 * x_2240) * x_2242) * x_2245) * x_2247));\n    } else {\n      let x_2253 : f32 = falloffAttenuation;\n      let x_2255 : vec3<f32> = (*(light)).color;\n      let x_2257 : vec3<f32> = cookieAttenuation;\n      punctualDiffuse = ((x_2255 * x_2253) * x_2257);\n      let x_2259 : vec3<f32> = punctualDiffuse;\n      let x_2260 : vec3<f32> = *(specularity_3);\n      punctualDiffuse = mix(x_2259, vec3<f32>(0.0f, 0.0f, 0.0f), x_2260);\n      let x_2262 : vec3<f32> = punctualDiffuse;\n      let x_2263 : vec3<f32> = dDiffuseLight;\n      dDiffuseLight = (x_2263 + x_2262);\n      let x_2266 : vec3<f32> = dLightDirNormW;\n      let x_2268 : vec3<f32> = *(viewDir_13);\n      halfDir = normalize((-(x_2266) + x_2268));\n      let x_2272 : vec3<f32> = halfDir;\n      param_112 = x_2272;\n      let x_2274 : vec3<f32> = *(reflectionDir);\n      param_113 = x_2274;\n      let x_2276 : vec3<f32> = *(worldNormal_15);\n      param_114 = x_2276;\n      let x_2278 : vec3<f32> = *(viewDir_13);\n      param_115 = x_2278;\n      let x_2280 : vec3<f32> = dLightDirNormW;\n      param_116 = x_2280;\n      let x_2282 : f32 = *(gloss_6);\n      param_117 = x_2282;\n      let x_2284 : mat3x3<f32> = *(tbn_2);\n      param_118 = x_2284;\n      let x_2285 : f32 = getLightSpecular_vf3_vf3_vf3_vf3_vf3_f1_mf33_(&(param_112), &(param_113), &(param_114), &(param_115), &(param_116), &(param_117), &(param_118));\n      let x_2286 : f32 = falloffAttenuation;\n      let x_2289 : vec3<f32> = (*(light)).color;\n      let x_2291 : vec3<f32> = cookieAttenuation;\n      let x_2293 : vec3<f32> = *(viewDir_13);\n      let x_2294 : vec3<f32> = halfDir;\n      param_119 = dot(x_2293, x_2294);\n      let x_2298 : f32 = *(gloss_6);\n      param_120 = x_2298;\n      let x_2300 : vec3<f32> = *(specularity_3);\n      param_121 = x_2300;\n      let x_2301 : vec3<f32> = getFresnel_f1_f1_vf3_(&(param_119), &(param_120), &(param_121));\n      let x_2303 : vec3<f32> = dSpecularLight;\n      dSpecularLight = (x_2303 + (((x_2289 * (x_2285 * x_2286)) * x_2291) * x_2301));\n    }\n  }\n  return;\n}\n\nfn evaluateClusterLight_f1_vf3_vf3_vf3_f1_vf3_vf3_mf33_struct_ClearcoatArgs_f1_f1_vf31_struct_SheenArgs_f1_vf31_struct_IridescenceArgs_f1_f11_(lightIndex_1 : ptr<function, f32>, worldNormal_16 : ptr<function, vec3<f32>>, viewDir_14 : ptr<function, vec3<f32>>, reflectionDir_1 : ptr<function, vec3<f32>>, gloss_7 : ptr<function, f32>, specularity_4 : ptr<function, vec3<f32>>, geometricNormal_1 : ptr<function, vec3<f32>>, tbn_3 : ptr<function, mat3x3<f32>>, clearcoat_1 : ptr<function, ClearcoatArgs>, sheen_1 : ptr<function, SheenArgs>, iridescence_1 : ptr<function, IridescenceArgs>) {\n  var clusterLightData_5 : ClusterLightData;\n  var param_122 : ClusterLightData;\n  var param_123 : f32;\n  var param_124 : ClusterLightData;\n  var param_125 : vec3<f32>;\n  var param_126 : vec3<f32>;\n  var param_127 : vec3<f32>;\n  var param_128 : f32;\n  var param_129 : vec3<f32>;\n  var param_130 : vec3<f32>;\n  var param_131 : mat3x3<f32>;\n  var param_132 : ClearcoatArgs;\n  var param_133 : SheenArgs;\n  var param_134 : IridescenceArgs;\n  let x_2307 : ClusterLightData = clusterLightData_5;\n  param_122 = x_2307;\n  let x_2309 : f32 = *(lightIndex_1);\n  param_123 = x_2309;\n  decodeClusterLightCore_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_f1_(&(param_122), &(param_123));\n  let x_2311 : ClusterLightData = param_122;\n  clusterLightData_5 = x_2311;\n  let x_2313 : f32 = clusterLightData_5.mask;\n  if ((x_2313 < 0.75f)) {\n    let x_2319 : ClusterLightData = clusterLightData_5;\n    param_124 = x_2319;\n    let x_2321 : vec3<f32> = *(worldNormal_16);\n    param_125 = x_2321;\n    let x_2323 : vec3<f32> = *(viewDir_14);\n    param_126 = x_2323;\n    let x_2325 : vec3<f32> = *(reflectionDir_1);\n    param_127 = x_2325;\n    let x_2327 : f32 = *(gloss_7);\n    param_128 = x_2327;\n    let x_2329 : vec3<f32> = *(specularity_4);\n    param_129 = x_2329;\n    let x_2331 : vec3<f32> = *(geometricNormal_1);\n    param_130 = x_2331;\n    let x_2333 : mat3x3<f32> = *(tbn_3);\n    param_131 = x_2333;\n    let x_2335 : ClearcoatArgs = *(clearcoat_1);\n    param_132 = x_2335;\n    let x_2337 : SheenArgs = *(sheen_1);\n    param_133 = x_2337;\n    let x_2339 : IridescenceArgs = *(iridescence_1);\n    param_134 = x_2339;\n    evaluateLight_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_vf3_vf3_vf3_f1_vf3_vf3_mf33_struct_ClearcoatArgs_f1_f1_vf31_struct_SheenArgs_f1_vf31_struct_IridescenceArgs_f1_f11_(&(param_124), &(param_125), &(param_126), &(param_127), &(param_128), &(param_129), &(param_130), &(param_131), &(param_132), &(param_133), &(param_134));\n  }\n  return;\n}\n\nfn addClusteredLights_vf3_vf3_vf3_f1_vf3_vf3_mf33_struct_ClearcoatArgs_f1_f1_vf31_struct_SheenArgs_f1_vf31_struct_IridescenceArgs_f1_f11_(worldNormal_17 : ptr<function, vec3<f32>>, viewDir_15 : ptr<function, vec3<f32>>, reflectionDir_2 : ptr<function, vec3<f32>>, gloss_8 : ptr<function, f32>, specularity_5 : ptr<function, vec3<f32>>, geometricNormal_2 : ptr<function, vec3<f32>>, tbn_4 : ptr<function, mat3x3<f32>>, clearcoat_2 : ptr<function, ClearcoatArgs>, sheen_2 : ptr<function, SheenArgs>, iridescence_2 : ptr<function, IridescenceArgs>) {\n  var cellCoords : vec3<f32>;\n  var cellIndex : f32;\n  var clusterV : f32;\n  var clusterU : f32;\n  var lightCellIndex : i32;\n  var lightIndex_2 : f32;\n  var param_135 : f32;\n  var param_136 : vec3<f32>;\n  var param_137 : vec3<f32>;\n  var param_138 : vec3<f32>;\n  var param_139 : f32;\n  var param_140 : vec3<f32>;\n  var param_141 : vec3<f32>;\n  var param_142 : mat3x3<f32>;\n  var param_143 : ClearcoatArgs;\n  var param_144 : SheenArgs;\n  var param_145 : IridescenceArgs;\n  var x_2370 : bool;\n  var x_2371 : bool;\n  let x_2343 : f32 = x_462.clusterSkip;\n  if ((x_2343 > 0.5f)) {\n    return;\n  }\n  let x_2349 : vec3<f32> = vPositionW;\n  let x_2351 : vec3<f32> = x_462.clusterBoundsMin;\n  let x_2355 : vec3<f32> = x_462.clusterCellsCountByBoundsSize;\n  cellCoords = floor(((x_2349 - x_2351) * x_2355));\n  let x_2358 : vec3<f32> = cellCoords;\n  let x_2361 : bool = any((x_2358 < vec3<f32>(0.0f, 0.0f, 0.0f)));\n  x_2371 = x_2361;\n  if (!(x_2361)) {\n    let x_2365 : vec3<f32> = cellCoords;\n    let x_2368 : vec3<f32> = x_462.clusterCellsMax;\n    x_2370 = any((x_2365 >= x_2368));\n    x_2371 = x_2370;\n  }\n  if (!(x_2371)) {\n    let x_2377 : vec3<f32> = x_462.clusterCellsDot;\n    let x_2378 : vec3<f32> = cellCoords;\n    cellIndex = dot(x_2377, x_2378);\n    let x_2381 : f32 = cellIndex;\n    let x_2384 : f32 = x_462.clusterTextureSize.y;\n    clusterV = floor((x_2381 * x_2384));\n    let x_2388 : f32 = cellIndex;\n    let x_2389 : f32 = clusterV;\n    let x_2391 : f32 = x_462.clusterTextureSize.x;\n    clusterU = (x_2388 - (x_2389 * x_2391));\n    lightCellIndex = 0i;\n    loop {\n      let x_2400 : i32 = lightCellIndex;\n      let x_2403 : i32 = x_462.clusterMaxCells;\n      if ((x_2400 < x_2403)) {\n      } else {\n        break;\n      }\n      let x_2408 : f32 = clusterU;\n      let x_2410 : i32 = lightCellIndex;\n      let x_2412 : f32 = clusterV;\n      let x_2415 : vec4<f32> = textureLoad(clusterWorldTexture, vec2<i32>((i32(x_2408) + x_2410), i32(x_2412)), 0i);\n      lightIndex_2 = x_2415.x;\n      let x_2417 : f32 = lightIndex_2;\n      if ((x_2417 <= 0.0f)) {\n        return;\n      }\n      let x_2422 : f32 = lightIndex_2;\n      param_135 = (x_2422 * 255.0f);\n      let x_2427 : vec3<f32> = *(worldNormal_17);\n      param_136 = x_2427;\n      let x_2429 : vec3<f32> = *(viewDir_15);\n      param_137 = x_2429;\n      let x_2431 : vec3<f32> = *(reflectionDir_2);\n      param_138 = x_2431;\n      let x_2433 : f32 = *(gloss_8);\n      param_139 = x_2433;\n      let x_2435 : vec3<f32> = *(specularity_5);\n      param_140 = x_2435;\n      let x_2437 : vec3<f32> = *(geometricNormal_2);\n      param_141 = x_2437;\n      let x_2439 : mat3x3<f32> = *(tbn_4);\n      param_142 = x_2439;\n      let x_2441 : ClearcoatArgs = *(clearcoat_2);\n      param_143 = x_2441;\n      let x_2443 : SheenArgs = *(sheen_2);\n      param_144 = x_2443;\n      let x_2445 : IridescenceArgs = *(iridescence_2);\n      param_145 = x_2445;\n      evaluateClusterLight_f1_vf3_vf3_vf3_f1_vf3_vf3_mf33_struct_ClearcoatArgs_f1_f1_vf31_struct_SheenArgs_f1_vf31_struct_IridescenceArgs_f1_f11_(&(param_135), &(param_136), &(param_137), &(param_138), &(param_139), &(param_140), &(param_141), &(param_142), &(param_143), &(param_144), &(param_145));\n\n      continuing {\n        let x_2447 : i32 = lightCellIndex;\n        lightCellIndex = (x_2447 + 1i);\n      }\n    }\n  }\n  return;\n}\n\nfn combineColor_vf3_vf3_f1_(albedo : ptr<function, vec3<f32>>, sheenSpecularity : ptr<function, vec3<f32>>, clearcoatSpecularity_1 : ptr<function, f32>) -> vec3<f32> {\n  var ret_1 : vec3<f32>;\n  ret_1 = vec3<f32>(0.0f, 0.0f, 0.0f);\n  let x_1864 : vec3<f32> = *(albedo);\n  let x_1866 : vec3<f32> = dDiffuseLight;\n  let x_1868 : vec3<f32> = ret_1;\n  ret_1 = (x_1868 + (x_1864 * x_1866));\n  let x_1871 : vec3<f32> = dSpecularLight;\n  let x_1872 : vec3<f32> = ret_1;\n  ret_1 = (x_1872 + x_1871);\n  let x_1874 : vec3<f32> = ret_1;\n  return x_1874;\n}\n\nfn addFog_vf3_(color_2 : ptr<function, vec3<f32>>) -> vec3<f32> {\n  let x_490 : vec3<f32> = *(color_2);\n  return x_490;\n}\n\nfn toneMap_vf3_(color_1 : ptr<function, vec3<f32>>) -> vec3<f32> {\n  var tA : f32;\n  var tB : f32;\n  var tC : f32;\n  var tD : f32;\n  var tE : f32;\n  var x_2 : vec3<f32>;\n  tA = 2.50999999f;\n  tB = 0.029999999f;\n  tC = 2.430000067f;\n  tD = 0.589999974f;\n  tE = 0.140000001f;\n  let x_458 : vec3<f32> = *(color_1);\n  let x_466 : f32 = x_462.exposure;\n  x_2 = (x_458 * x_466);\n  let x_468 : vec3<f32> = x_2;\n  let x_469 : f32 = tA;\n  let x_470 : vec3<f32> = x_2;\n  let x_472 : f32 = tB;\n  let x_476 : vec3<f32> = x_2;\n  let x_477 : f32 = tC;\n  let x_478 : vec3<f32> = x_2;\n  let x_480 : f32 = tD;\n  let x_484 : f32 = tE;\n  return ((x_468 * ((x_470 * x_469) + vec3<f32>(x_472, x_472, x_472))) / ((x_476 * ((x_478 * x_477) + vec3<f32>(x_480, x_480, x_480))) + vec3<f32>(x_484, x_484, x_484)));\n}\n\nfn gammaCorrectOutput_vf3_(color : ptr<function, vec3<f32>>) -> vec3<f32> {\n  let x_438 : vec3<f32> = *(color);\n  return pow((x_438 + vec3<f32>(0.0000001f, 0.0000001f, 0.0000001f)), vec3<f32>(0.454545468f, 0.454545468f, 0.454545468f));\n}\n\nfn evaluateBackend_struct_LitShaderArguments_f1_vf3_vf3_f1_f1_vf3_f1_f1_f1_f1_vf3_vf3_vf3_struct_IridescenceArgs_f1_f11_struct_ClearcoatArgs_f1_f1_vf31_struct_SheenArgs_f1_vf311_(litShaderArgs_1 : ptr<function, LitShaderArguments>) {\n  var param_146 : vec3<f32>;\n  var param_147 : vec3<f32>;\n  var param_148 : f32;\n  var param_149 : mat3x3<f32>;\n  var param_150 : LitShaderArguments;\n  var param_151 : vec3<f32>;\n  var param_152 : f32;\n  var param_153 : vec3<f32>;\n  var param_154 : vec3<f32>;\n  var param_155 : vec3<f32>;\n  var param_156 : f32;\n  var param_157 : vec3<f32>;\n  var param_158 : f32;\n  var param_159 : vec3<f32>;\n  var param_160 : vec3<f32>;\n  var param_161 : vec3<f32>;\n  var param_162 : f32;\n  var param_163 : vec3<f32>;\n  var param_164 : vec3<f32>;\n  var param_165 : mat3x3<f32>;\n  var param_166 : ClearcoatArgs;\n  var param_167 : SheenArgs;\n  var param_168 : IridescenceArgs;\n  var param_169 : vec3<f32>;\n  var param_170 : vec3<f32>;\n  var param_171 : f32;\n  var param_172 : vec3<f32>;\n  var param_173 : vec3<f32>;\n  var param_174 : vec3<f32>;\n  let x_2453 : vec3<f32> = (*(litShaderArgs_1)).worldNormal;\n  param_146 = x_2453;\n  let x_2455 : vec3<f32> = dViewDirW;\n  param_147 = x_2455;\n  let x_2458 : f32 = (*(litShaderArgs_1)).gloss;\n  param_148 = x_2458;\n  let x_2460 : mat3x3<f32> = dTBN;\n  param_149 = x_2460;\n  getReflDir_vf3_vf3_f1_mf33_(&(param_146), &(param_147), &(param_148), &(param_149));\n  let x_2463 : LitShaderArguments = *(litShaderArgs_1);\n  param_150 = x_2463;\n  getMetalnessModulate_struct_LitShaderArguments_f1_vf3_vf3_f1_f1_vf3_f1_f1_f1_f1_vf3_vf3_vf3_struct_IridescenceArgs_f1_f11_struct_ClearcoatArgs_f1_f1_vf31_struct_SheenArgs_f1_vf311_(&(param_150));\n  let x_2465 : LitShaderArguments = param_150;\n  *(litShaderArgs_1) = x_2465;\n  let x_2468 : vec3<f32> = (*(litShaderArgs_1)).worldNormal;\n  param_151 = x_2468;\n  addAmbient_vf3_(&(param_151));\n  let x_2470 : vec3<f32> = dDiffuseLight;\n  let x_2472 : vec3<f32> = (*(litShaderArgs_1)).specularity;\n  dDiffuseLight = (x_2470 * (vec3<f32>(1.0f, 1.0f, 1.0f) - x_2472));\n  let x_2477 : vec3<f32> = (*(litShaderArgs_1)).specularity;\n  let x_2478 : vec3<f32> = dSpecularLight;\n  dSpecularLight = (x_2478 * x_2477);\n  let x_2482 : f32 = (*(litShaderArgs_1)).gloss;\n  param_152 = x_2482;\n  let x_2485 : vec3<f32> = (*(litShaderArgs_1)).worldNormal;\n  param_153 = x_2485;\n  let x_2487 : vec3<f32> = dViewDirW;\n  param_154 = x_2487;\n  let x_2490 : vec3<f32> = (*(litShaderArgs_1)).specularity;\n  param_155 = x_2490;\n  let x_2493 : f32 = (*(litShaderArgs_1)).clearcoat.gloss;\n  param_156 = x_2493;\n  let x_2496 : vec3<f32> = (*(litShaderArgs_1)).clearcoat.worldNormal;\n  param_157 = x_2496;\n  let x_2499 : f32 = (*(litShaderArgs_1)).clearcoat.specularity;\n  param_158 = x_2499;\n  calcLTCLightValues_f1_vf3_vf3_vf3_f1_vf3_f1_(&(param_152), &(param_153), &(param_154), &(param_155), &(param_156), &(param_157), &(param_158));\n  let x_2503 : vec3<f32> = (*(litShaderArgs_1)).worldNormal;\n  param_159 = x_2503;\n  let x_2505 : vec3<f32> = dViewDirW;\n  param_160 = x_2505;\n  let x_2507 : vec3<f32> = dReflDirW;\n  param_161 = x_2507;\n  let x_2510 : f32 = (*(litShaderArgs_1)).gloss;\n  param_162 = x_2510;\n  let x_2513 : vec3<f32> = (*(litShaderArgs_1)).specularity;\n  param_163 = x_2513;\n  let x_2515 : vec3<f32> = dVertexNormalW;\n  param_164 = x_2515;\n  let x_2517 : mat3x3<f32> = dTBN;\n  param_165 = x_2517;\n  let x_2520 : ClearcoatArgs = (*(litShaderArgs_1)).clearcoat;\n  param_166 = x_2520;\n  let x_2523 : SheenArgs = (*(litShaderArgs_1)).sheen;\n  param_167 = x_2523;\n  let x_2526 : IridescenceArgs = (*(litShaderArgs_1)).iridescence;\n  param_168 = x_2526;\n  addClusteredLights_vf3_vf3_vf3_f1_vf3_vf3_mf33_struct_ClearcoatArgs_f1_f1_vf31_struct_SheenArgs_f1_vf31_struct_IridescenceArgs_f1_f11_(&(param_159), &(param_160), &(param_161), &(param_162), &(param_163), &(param_164), &(param_165), &(param_166), &(param_167), &(param_168));\n  (*(litShaderArgs_1)).specularity = vec3<f32>(1.0f, 1.0f, 1.0f);\n  let x_2533 : vec3<f32> = (*(litShaderArgs_1)).albedo;\n  param_169 = x_2533;\n  let x_2536 : vec3<f32> = (*(litShaderArgs_1)).sheen.specularity;\n  param_170 = x_2536;\n  let x_2539 : f32 = (*(litShaderArgs_1)).clearcoat.specularity;\n  param_171 = x_2539;\n  let x_2540 : vec3<f32> = combineColor_vf3_vf3_f1_(&(param_169), &(param_170), &(param_171));\n  let x_2541 : vec4<f32> = pc_fragColor;\n  pc_fragColor = vec4<f32>(x_2540.x, x_2540.y, x_2540.z, x_2541.w);\n  let x_2544 : vec3<f32> = (*(litShaderArgs_1)).emission;\n  let x_2545 : vec4<f32> = pc_fragColor;\n  let x_2547 : vec3<f32> = (vec3<f32>(x_2545.x, x_2545.y, x_2545.z) + x_2544);\n  let x_2548 : vec4<f32> = pc_fragColor;\n  pc_fragColor = vec4<f32>(x_2547.x, x_2547.y, x_2547.z, x_2548.w);\n  let x_2551 : vec4<f32> = pc_fragColor;\n  param_172 = vec3<f32>(x_2551.x, x_2551.y, x_2551.z);\n  let x_2553 : vec3<f32> = addFog_vf3_(&(param_172));\n  let x_2554 : vec4<f32> = pc_fragColor;\n  pc_fragColor = vec4<f32>(x_2553.x, x_2553.y, x_2553.z, x_2554.w);\n  let x_2557 : vec4<f32> = pc_fragColor;\n  param_173 = vec3<f32>(x_2557.x, x_2557.y, x_2557.z);\n  let x_2559 : vec3<f32> = toneMap_vf3_(&(param_173));\n  let x_2560 : vec4<f32> = pc_fragColor;\n  pc_fragColor = vec4<f32>(x_2559.x, x_2559.y, x_2559.z, x_2560.w);\n  let x_2563 : vec4<f32> = pc_fragColor;\n  param_174 = vec3<f32>(x_2563.x, x_2563.y, x_2563.z);\n  let x_2565 : vec3<f32> = gammaCorrectOutput_vf3_(&(param_174));\n  let x_2566 : vec4<f32> = pc_fragColor;\n  pc_fragColor = vec4<f32>(x_2565.x, x_2565.y, x_2565.z, x_2566.w);\n  pc_fragColor.w = 1.0f;\n  return;\n}\n\nfn main_1() {\n  var x_2576 : vec3<f32>;\n  var litShaderArgs_2 : LitShaderArguments;\n  var param_175 : LitShaderArguments;\n  dAlpha = 1.0f;\n  dBlendModeFogFactor = 1.0f;\n  dReflection = vec4<f32>(0.0f, 0.0f, 0.0f, 0.0f);\n  let x_2575 : bool = gl_FrontFacing;\n  if (x_2575) {\n    let x_2579 : vec3<f32> = vNormalW;\n    let x_2581 : f32 = x_462.twoSidedLightingNegScaleFactor;\n    x_2576 = (x_2579 * x_2581);\n  } else {\n    let x_2584 : vec3<f32> = vNormalW;\n    let x_2587 : f32 = x_462.twoSidedLightingNegScaleFactor;\n    x_2576 = (-(x_2584) * x_2587);\n  }\n  let x_2589 : vec3<f32> = x_2576;\n  dVertexNormalW = normalize(x_2589);\n  getViewDir_();\n  let x_2593 : LitShaderArguments = evaluateFrontend_();\n  litShaderArgs_2 = x_2593;\n  let x_2595 : LitShaderArguments = litShaderArgs_2;\n  param_175 = x_2595;\n  evaluateBackend_struct_LitShaderArguments_f1_vf3_vf3_f1_f1_vf3_f1_f1_f1_f1_vf3_vf3_vf3_struct_IridescenceArgs_f1_f11_struct_ClearcoatArgs_f1_f1_vf31_struct_SheenArgs_f1_vf311_(&(param_175));\n  return;\n}\n\nstruct main_out {\n  @location(0)\n  pc_fragColor_1 : vec4<f32>,\n}\n\n@fragment\nfn main(@location(0) vPositionW_param : vec3<f32>, @location(1) vNormalW_param : vec3<f32>, @builtin(front_facing) gl_FrontFacing_param : bool) -> main_out {\n  vPositionW = vPositionW_param;\n  vNormalW = vNormalW_param;\n  gl_FrontFacing = gl_FrontFacing_param;\n  main_1();\n  return main_out(pc_fragColor);\n}\n"
      },
      "entryPoint": "main",
      "targets": [
          {
              "format": "rgba8unorm",
              "writeMask": 15
          }
      ]
  }
}