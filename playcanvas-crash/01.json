{
  "vertex": {
      "module": {
          "code": "struct ub_view {\n  /* @offset(0) */\n  matrix_model : mat4x4<f32>,\n  /* @offset(64) */\n  matrix_normal : mat3x3<f32>,\n  /* @offset(112) */\n  view_position : vec3<f32>,\n  /* @offset(128) */\n  light_globalAmbient : vec3<f32>,\n  /* @offset(140) */\n  textureBias : f32,\n  /* @offset(144) */\n  twoSidedLightingNegScaleFactor : f32,\n  /* @offset(148) */\n  tbnBasis : f32,\n  /* @offset(152) */\n  exposure : f32,\n  /* @offset(156) */\n  material_bumpiness : f32,\n  /* @offset(160) */\n  material_gloss : f32,\n  /* @offset(176) */\n  material_emissive : vec3<f32>,\n  /* @offset(188) */\n  material_f0 : f32,\n  /* @offset(192) */\n  clusterMaxCells : i32,\n  /* @offset(196) */\n  clusterSkip : f32,\n  /* @offset(208) */\n  clusterCellsCountByBoundsSize : vec3<f32>,\n  /* @offset(224) */\n  clusterTextureSize : vec3<f32>,\n  /* @offset(240) */\n  clusterBoundsMin : vec3<f32>,\n  /* @offset(256) */\n  clusterBoundsDelta : vec3<f32>,\n  /* @offset(272) */\n  clusterCellsDot : vec3<f32>,\n  /* @offset(288) */\n  clusterCellsMax : vec3<f32>,\n  /* @offset(304) */\n  clusterCompressionLimit0 : vec2<f32>,\n  /* @offset(312) */\n  shadowAtlasParams : vec2<f32>,\n}\n\nstruct ub_mesh {\n  /* @offset(0) */\n  matrix_viewProjection : mat4x4<f32>,\n}\n\nvar<private> vertex_texCoord0 : vec2<f32>;\n\n@group(0) @binding(0) var<uniform> x_34 : ub_view;\n\nvar<private> dModelMatrix : mat4x4<f32>;\n\nvar<private> vertex_position : vec3<f32>;\n\nvar<private> dPositionW : vec3<f32>;\n\n@group(1) @binding(0) var<uniform> x_66 : ub_mesh;\n\nvar<private> dNormalMatrix : mat3x3<f32>;\n\nvar<private> vertex_normal : vec3<f32>;\n\nvar<private> vPositionW : vec3<f32>;\n\nvar<private> vNormalW : vec3<f32>;\n\nvar<private> vUv0 : vec2<f32>;\n\n@group(1) @binding(1) var lightsTextureFloat : texture_2d<f32>;\n\n@group(1) @binding(2) var lightsTextureFloat_sampler : sampler;\n\n@group(1) @binding(3) var lightsTexture8 : texture_2d<f32>;\n\n@group(1) @binding(4) var lightsTexture8_sampler : sampler;\n\n@group(0) @binding(1) var texture_normalMap : texture_2d<f32>;\n\n@group(0) @binding(2) var texture_normalMap_sampler : sampler;\n\n@group(0) @binding(3) var texture_diffuseMap : texture_2d<f32>;\n\n@group(0) @binding(4) var texture_diffuseMap_sampler : sampler;\n\n@group(0) @binding(5) var texture_metalnessMap : texture_2d<f32>;\n\n@group(0) @binding(6) var texture_metalnessMap_sampler : sampler;\n\n@group(0) @binding(7) var areaLightsLutTex1 : texture_2d<f32>;\n\n@group(0) @binding(8) var areaLightsLutTex1_sampler : sampler;\n\n@group(0) @binding(9) var areaLightsLutTex2 : texture_2d<f32>;\n\n@group(0) @binding(10) var areaLightsLutTex2_sampler : sampler;\n\n@group(0) @binding(11) var clusterWorldTexture : texture_2d<f32>;\n\n@group(0) @binding(12) var clusterWorldTexture_sampler : sampler;\n\nvar<private> gl_Position : vec4<f32>;\n\nfn getModelMatrix_() -> mat4x4<f32> {\n  let x_38 : mat4x4<f32> = x_34.matrix_model;\n  return x_38;\n}\n\nfn getPosition_() -> vec4<f32> {\n  var localPos : vec3<f32>;\n  var posW : vec4<f32>;\n  var screenPos : vec4<f32>;\n  let x_43 : mat4x4<f32> = getModelMatrix_();\n  dModelMatrix = x_43;\n  let x_48 : vec3<f32> = vertex_position;\n  localPos = x_48;\n  let x_51 : mat4x4<f32> = dModelMatrix;\n  let x_52 : vec3<f32> = localPos;\n  posW = (x_51 * vec4<f32>(x_52.x, x_52.y, x_52.z, 1.0f));\n  let x_61 : vec4<f32> = posW;\n  dPositionW = vec3<f32>(x_61.x, x_61.y, x_61.z);\n  let x_68 : mat4x4<f32> = x_66.matrix_viewProjection;\n  let x_69 : vec4<f32> = posW;\n  screenPos = (x_68 * x_69);\n  let x_71 : vec4<f32> = screenPos;\n  return x_71;\n}\n\nfn getWorldPosition_() -> vec3<f32> {\n  let x_74 : vec3<f32> = dPositionW;\n  return x_74;\n}\n\nfn getNormal_() -> vec3<f32> {\n  var tempNormal : vec3<f32>;\n  let x_82 : mat3x3<f32> = x_34.matrix_normal;\n  dNormalMatrix = x_82;\n  let x_85 : vec3<f32> = vertex_normal;\n  tempNormal = x_85;\n  let x_86 : mat3x3<f32> = dNormalMatrix;\n  let x_87 : vec3<f32> = tempNormal;\n  return normalize((x_86 * x_87));\n}\n\nfn getUv0_() -> vec2<f32> {\n  let x_27 : vec2<f32> = vertex_texCoord0;\n  return x_27;\n}\n\nfn main_1() {\n  var uv0 : vec2<f32>;\n  let x_98 : vec4<f32> = getPosition_();\n  gl_Position = x_98;\n  let x_103 : vec3<f32> = getWorldPosition_();\n  vPositionW = x_103;\n  let x_105 : vec3<f32> = getNormal_();\n  vNormalW = x_105;\n  let x_108 : vec2<f32> = getUv0_();\n  uv0 = x_108;\n  let x_111 : vec2<f32> = uv0;\n  vUv0 = x_111;\n  return;\n}\n\nstruct main_out {\n  @builtin(position)\n  gl_Position : vec4<f32>,\n  @location(0)\n  vPositionW_1 : vec3<f32>,\n  @location(1)\n  vNormalW_1 : vec3<f32>,\n  @location(2)\n  vUv0_1 : vec2<f32>,\n}\n\n@vertex\nfn main(@location(5) vertex_texCoord0_param : vec2<f32>, @location(0) vertex_position_param : vec3<f32>, @location(1) vertex_normal_param : vec3<f32>) -> main_out {\n  vertex_texCoord0 = vertex_texCoord0_param;\n  vertex_position = vertex_position_param;\n  vertex_normal = vertex_normal_param;\n  main_1();\n  return main_out(gl_Position, vPositionW, vNormalW, vUv0);\n}\n"
      },
      "entryPoint": "main",
      "buffers": [
          {
              "attributes": [
                  {
                      "shaderLocation": 0,
                      "offset": 0,
                      "format": "float32x3"
                  },
                  {
                      "shaderLocation": 1,
                      "offset": 12,
                      "format": "float32x3"
                  },
                  {
                      "shaderLocation": 5,
                      "offset": 24,
                      "format": "float32x2"
                  },
                  {
                      "shaderLocation": 6,
                      "offset": 32,
                      "format": "float32x2"
                  }
              ],
              "arrayStride": 40,
              "stepMode": "vertex"
          }
      ]
  },
  "primitive": {
      "topology": "triangle-list",
      "cullMode": "none"
  },
  "depthStencil": {
      "format": "depth24plus-stencil8",
      "depthWriteEnabled": true,
      "depthCompare": "less-equal"
  },
  "multisample": {
      "count": 4
  },
  "layout": "auto",
  "fragment": {
      "module": {
          "code": "struct IridescenceArgs {\n  intensity : f32,\n  thickness : f32,\n}\n\nstruct ClearcoatArgs {\n  specularity : f32,\n  gloss : f32,\n  worldNormal : vec3<f32>,\n}\n\nstruct SheenArgs {\n  gloss : f32,\n  specularity : vec3<f32>,\n}\n\nstruct LitShaderArguments {\n  opacity : f32,\n  worldNormal : vec3<f32>,\n  albedo : vec3<f32>,\n  transmission : f32,\n  thickness : f32,\n  specularity : vec3<f32>,\n  gloss : f32,\n  metalness : f32,\n  specularityFactor : f32,\n  ao : f32,\n  emission : vec3<f32>,\n  lightmap : vec3<f32>,\n  lightmapDir : vec3<f32>,\n  iridescence : IridescenceArgs,\n  clearcoat : ClearcoatArgs,\n  sheen : SheenArgs,\n}\n\nstruct Coords {\n  coord0 : vec3<f32>,\n  coord1 : vec3<f32>,\n  coord2 : vec3<f32>,\n  coord3 : vec3<f32>,\n}\n\nstruct ClusterLightData {\n  halfWidth : vec3<f32>,\n  lightType : f32,\n  halfHeight : vec3<f32>,\n  lightIndex : i32,\n  position : vec3<f32>,\n  shape : f32,\n  direction : vec3<f32>,\n  falloffMode : f32,\n  color : vec3<f32>,\n  shadowIntensity : f32,\n  omniAtlasViewport : vec3<f32>,\n  range : f32,\n  cookieChannelMask : vec4<f32>,\n  shadowBias : f32,\n  shadowNormalBias : f32,\n  innerConeAngleCos : f32,\n  outerConeAngleCos : f32,\n  cookie : f32,\n  cookieRgb : f32,\n  cookieIntensity : f32,\n  mask : f32,\n}\n\nstruct ub_view {\n  /* @offset(0) */\n  matrix_model : mat4x4<f32>,\n  /* @offset(64) */\n  matrix_normal : mat3x3<f32>,\n  /* @offset(112) */\n  view_position : vec3<f32>,\n  /* @offset(128) */\n  light_globalAmbient : vec3<f32>,\n  /* @offset(140) */\n  textureBias : f32,\n  /* @offset(144) */\n  twoSidedLightingNegScaleFactor : f32,\n  /* @offset(148) */\n  tbnBasis : f32,\n  /* @offset(152) */\n  exposure : f32,\n  /* @offset(156) */\n  material_bumpiness : f32,\n  /* @offset(160) */\n  material_gloss : f32,\n  /* @offset(176) */\n  material_emissive : vec3<f32>,\n  /* @offset(188) */\n  material_f0 : f32,\n  /* @offset(192) */\n  clusterMaxCells : i32,\n  /* @offset(196) */\n  clusterSkip : f32,\n  /* @offset(208) */\n  clusterCellsCountByBoundsSize : vec3<f32>,\n  /* @offset(224) */\n  clusterTextureSize : vec3<f32>,\n  /* @offset(240) */\n  clusterBoundsMin : vec3<f32>,\n  /* @offset(256) */\n  clusterBoundsDelta : vec3<f32>,\n  /* @offset(272) */\n  clusterCellsDot : vec3<f32>,\n  /* @offset(288) */\n  clusterCellsMax : vec3<f32>,\n  /* @offset(304) */\n  clusterCompressionLimit0 : vec2<f32>,\n  /* @offset(312) */\n  shadowAtlasParams : vec2<f32>,\n}\n\nstruct ub_mesh {\n  /* @offset(0) */\n  matrix_viewProjection : mat4x4<f32>,\n}\n\nvar<private> dAlpha : f32;\n\nvar<private> dBlendModeFogFactor : f32;\n\nvar<private> dLightDirW : vec3<f32>;\n\nvar<private> vPositionW : vec3<f32>;\n\nvar<private> dLightDirNormW : vec3<f32>;\n\nvar<private> dLightPosW : vec3<f32>;\n\nvar<private> vUv0 : vec2<f32>;\n\n@group(0) @binding(0) var<uniform> x_534 : ub_view;\n\nvar<private> dTBN : mat3x3<f32>;\n\n@group(0) @binding(1) var texture_normalMap : texture_2d<f32>;\n\n@group(0) @binding(2) var texture_normalMap_sampler : sampler;\n\nvar<private> dNormalW : vec3<f32>;\n\nvar<private> dAlbedo : vec3<f32>;\n\n@group(0) @binding(3) var texture_diffuseMap : texture_2d<f32>;\n\n@group(0) @binding(4) var texture_diffuseMap_sampler : sampler;\n\n@group(0) @binding(5) var texture_metalnessMap : texture_2d<f32>;\n\n@group(0) @binding(6) var texture_metalnessMap_sampler : sampler;\n\nvar<private> dMetalness : f32;\n\nvar<private> dSpecularity : vec3<f32>;\n\nvar<private> dGlossiness : f32;\n\nvar<private> dAo : f32;\n\nvar<private> dEmission : vec3<f32>;\n\nvar<private> dDiffuseLight : vec3<f32>;\n\nvar<private> dSpecularLight : vec3<f32>;\n\nvar<private> dReflection : vec4<f32>;\n\nvar<private> dSphereRadius : f32;\n\nvar<private> vNormalW : vec3<f32>;\n\n@group(0) @binding(9) var areaLightsLutTex2 : texture_2d<f32>;\n\n@group(0) @binding(10) var areaLightsLutTex2_sampler : sampler;\n\nvar<private> dLTCUV : vec2<f32>;\n\nvar<private> dLTCSpecFres : vec3<f32>;\n\nvar<private> dLTCCoords : Coords;\n\n@group(0) @binding(7) var areaLightsLutTex1 : texture_2d<f32>;\n\n@group(0) @binding(8) var areaLightsLutTex1_sampler : sampler;\n\nvar<private> dViewDirW : vec3<f32>;\n\nvar<private> dReflDirW : vec3<f32>;\n\n@group(1) @binding(3) var lightsTexture8 : texture_2d<f32>;\n\n@group(1) @binding(1) var lightsTextureFloat : texture_2d<f32>;\n\n@group(0) @binding(11) var clusterWorldTexture : texture_2d<f32>;\n\nvar<private> dVertexNormalW : vec3<f32>;\n\nvar<private> pc_fragColor : vec4<f32>;\n\nvar<private> gl_FrontFacing : bool;\n\nvar<private> dTangentW : vec3<f32>;\n\nvar<private> dBinormalW : vec3<f32>;\n\n@group(1) @binding(0) var<uniform> x_2840 : ub_mesh;\n\n@group(1) @binding(2) var lightsTextureFloat_sampler : sampler;\n\n@group(1) @binding(4) var lightsTexture8_sampler : sampler;\n\n@group(0) @binding(12) var clusterWorldTexture_sampler : sampler;\n\nvar<private> ccReflDirW : vec3<f32>;\n\nvar<private> dShadowCoord : vec3<f32>;\n\nvar<private> ccFresnel : f32;\n\nvar<private> ccReflection : vec3<f32>;\n\nvar<private> ccSpecularLight : vec3<f32>;\n\nvar<private> sSpecularLight : vec3<f32>;\n\nvar<private> sReflection : vec3<f32>;\n\nvar<private> lightProjectionMatrix : mat4x4<f32>;\n\nfn getViewDir_() {\n  let x_2104 : vec3<f32> = x_534.view_position;\n  let x_2105 : vec3<f32> = vPositionW;\n  dViewDirW = normalize((x_2104 - x_2105));\n  return;\n}\n\nfn getTBN_vf3_vf3_vf3_(tangent : ptr<function, vec3<f32>>, binormal : ptr<function, vec3<f32>>, normal : ptr<function, vec3<f32>>) {\n  var uv_4 : vec2<f32>;\n  var dp1 : vec3<f32>;\n  var dp2 : vec3<f32>;\n  var duv1 : vec2<f32>;\n  var duv2 : vec2<f32>;\n  var dp2perp : vec3<f32>;\n  var dp1perp : vec3<f32>;\n  var T : vec3<f32>;\n  var B : vec3<f32>;\n  var denom : f32;\n  var invmax : f32;\n  var x_527 : f32;\n  let x_471 : vec2<f32> = vUv0;\n  uv_4 = x_471;\n  let x_473 : vec3<f32> = vPositionW;\n  dp1 = dpdx(x_473);\n  let x_476 : vec3<f32> = vPositionW;\n  dp2 = dpdy(x_476);\n  let x_479 : vec2<f32> = uv_4;\n  duv1 = dpdx(x_479);\n  let x_482 : vec2<f32> = uv_4;\n  duv2 = dpdy(x_482);\n  let x_485 : vec3<f32> = dp2;\n  let x_486 : vec3<f32> = *(normal);\n  dp2perp = cross(x_485, x_486);\n  let x_489 : vec3<f32> = *(normal);\n  let x_490 : vec3<f32> = dp1;\n  dp1perp = cross(x_489, x_490);\n  let x_493 : vec3<f32> = dp2perp;\n  let x_497 : f32 = duv1.x;\n  let x_499 : vec3<f32> = dp1perp;\n  let x_501 : f32 = duv2.x;\n  T = ((x_493 * x_497) + (x_499 * x_501));\n  let x_505 : vec3<f32> = dp2perp;\n  let x_508 : f32 = duv1.y;\n  let x_510 : vec3<f32> = dp1perp;\n  let x_512 : f32 = duv2.y;\n  B = ((x_505 * x_508) + (x_510 * x_512));\n  let x_516 : vec3<f32> = T;\n  let x_517 : vec3<f32> = T;\n  let x_519 : vec3<f32> = B;\n  let x_520 : vec3<f32> = B;\n  denom = max(dot(x_516, x_517), dot(x_519, x_520));\n  let x_524 : f32 = denom;\n  if ((x_524 == 0.0f)) {\n    x_527 = 0.0f;\n  } else {\n    let x_538 : f32 = x_534.tbnBasis;\n    let x_539 : f32 = denom;\n    x_527 = (x_538 / sqrt(x_539));\n  }\n  let x_542 : f32 = x_527;\n  invmax = x_542;\n  let x_545 : vec3<f32> = T;\n  let x_546 : f32 = invmax;\n  let x_547 : vec3<f32> = (x_545 * x_546);\n  let x_548 : vec3<f32> = B;\n  let x_550 : f32 = invmax;\n  let x_551 : vec3<f32> = (-(x_548) * x_550);\n  let x_552 : vec3<f32> = *(normal);\n  dTBN = mat3x3<f32>(vec3<f32>(x_547.x, x_547.y, x_547.z), vec3<f32>(x_551.x, x_551.y, x_551.z), vec3<f32>(x_552.x, x_552.y, x_552.z));\n  return;\n}\n\nfn unpackNormal_vf4_(nmap : ptr<function, vec4<f32>>) -> vec3<f32> {\n  let x_623 : vec4<f32> = *(nmap);\n  return ((vec3<f32>(x_623.x, x_623.y, x_623.z) * 2.0f) - vec3<f32>(1.0f, 1.0f, 1.0f));\n}\n\nfn addNormalDetail_vf3_(normalMap : ptr<function, vec3<f32>>) -> vec3<f32> {\n  let x_631 : vec3<f32> = *(normalMap);\n  return x_631;\n}\n\nfn getNormal_() {\n  var normalMap_1 : vec3<f32>;\n  var param_8 : vec4<f32>;\n  var param_9 : vec3<f32>;\n  let x_645 : vec2<f32> = vUv0;\n  let x_648 : f32 = x_534.textureBias;\n  let x_649 : vec4<f32> = textureSampleBias(texture_normalMap, texture_normalMap_sampler, x_645, x_648);\n  param_8 = x_649;\n  let x_651 : vec3<f32> = unpackNormal_vf4_(&(param_8));\n  normalMap_1 = x_651;\n  let x_653 : vec3<f32> = normalMap_1;\n  let x_656 : f32 = x_534.material_bumpiness;\n  normalMap_1 = mix(vec3<f32>(0.0f, 0.0f, 1.0f), x_653, vec3<f32>(x_656, x_656, x_656));\n  let x_660 : mat3x3<f32> = dTBN;\n  let x_662 : vec3<f32> = normalMap_1;\n  param_9 = x_662;\n  let x_663 : vec3<f32> = addNormalDetail_vf3_(&(param_9));\n  dNormalW = normalize((x_660 * x_663));\n  return;\n}\n\nfn decodeGamma_vf4_(raw : ptr<function, vec4<f32>>) -> vec3<f32> {\n  let x_566 : vec4<f32> = *(raw);\n  return pow(vec3<f32>(x_566.x, x_566.y, x_566.z), vec3<f32>(2.200000048f, 2.200000048f, 2.200000048f));\n}\n\nfn addAlbedoDetail_vf3_(albedo : ptr<function, vec3<f32>>) -> vec3<f32> {\n  let x_666 : vec3<f32> = *(albedo);\n  return x_666;\n}\n\nfn getAlbedo_() {\n  var albedoBase : vec3<f32>;\n  var param_10 : vec4<f32>;\n  var param_11 : vec3<f32>;\n  dAlbedo = vec3<f32>(1.0f, 1.0f, 1.0f);\n  let x_677 : vec2<f32> = vUv0;\n  let x_679 : f32 = x_534.textureBias;\n  let x_680 : vec4<f32> = textureSampleBias(texture_diffuseMap, texture_diffuseMap_sampler, x_677, x_679);\n  param_10 = x_680;\n  let x_682 : vec3<f32> = decodeGamma_vf4_(&(param_10));\n  albedoBase = x_682;\n  let x_684 : vec3<f32> = albedoBase;\n  param_11 = x_684;\n  let x_685 : vec3<f32> = addAlbedoDetail_vf3_(&(param_11));\n  let x_686 : vec3<f32> = dAlbedo;\n  dAlbedo = (x_686 * x_685);\n  return;\n}\n\nfn getMetalness_() {\n  var metalness : f32;\n  metalness = 1.0f;\n  let x_694 : vec2<f32> = vUv0;\n  let x_696 : f32 = x_534.textureBias;\n  let x_697 : vec4<f32> = textureSampleBias(texture_metalnessMap, texture_metalnessMap_sampler, x_694, x_696);\n  let x_700 : f32 = metalness;\n  metalness = (x_700 * x_697.z);\n  let x_703 : f32 = metalness;\n  dMetalness = x_703;\n  return;\n}\n\nfn getGlossiness_() {\n  dGlossiness = 1.0f;\n  let x_708 : f32 = x_534.material_gloss;\n  let x_709 : f32 = dGlossiness;\n  dGlossiness = (x_709 * x_708);\n  let x_714 : vec2<f32> = vUv0;\n  let x_716 : f32 = x_534.textureBias;\n  let x_717 : vec4<f32> = textureSampleBias(texture_metalnessMap, texture_metalnessMap_sampler, x_714, x_716);\n  let x_719 : f32 = dGlossiness;\n  dGlossiness = (x_719 * x_717.y);\n  let x_721 : f32 = dGlossiness;\n  dGlossiness = (1.0f - x_721);\n  let x_723 : f32 = dGlossiness;\n  dGlossiness = (x_723 + 0.0000001f);\n  return;\n}\n\nfn getSpecularity_() {\n  dSpecularity = vec3<f32>(1.0f, 1.0f, 1.0f);\n  return;\n}\n\nfn getAO_() {\n  dAo = 1.0f;\n  let x_729 : vec2<f32> = vUv0;\n  let x_731 : f32 = x_534.textureBias;\n  let x_732 : vec4<f32> = textureSampleBias(texture_metalnessMap, texture_metalnessMap_sampler, x_729, x_731);\n  let x_734 : f32 = dAo;\n  dAo = (x_734 * x_732.x);\n  return;\n}\n\nfn getEmission_() {\n  dEmission = vec3<f32>(1.0f, 1.0f, 1.0f);\n  let x_740 : vec3<f32> = x_534.material_emissive;\n  let x_741 : vec3<f32> = dEmission;\n  dEmission = (x_741 * x_740);\n  return;\n}\n\nfn evaluateFrontend_() -> LitShaderArguments {\n  var x_litShaderArgs : LitShaderArguments;\n  getNormal_();\n  getAlbedo_();\n  getMetalness_();\n  getGlossiness_();\n  getSpecularity_();\n  getAO_();\n  getEmission_();\n  let x_752 : vec3<f32> = dNormalW;\n  x_litShaderArgs.worldNormal = x_752;\n  let x_755 : vec3<f32> = dAlbedo;\n  x_litShaderArgs.albedo = x_755;\n  let x_757 : f32 = dMetalness;\n  x_litShaderArgs.metalness = x_757;\n  let x_760 : vec3<f32> = dSpecularity;\n  x_litShaderArgs.specularity = x_760;\n  let x_762 : f32 = dGlossiness;\n  x_litShaderArgs.gloss = x_762;\n  let x_764 : f32 = dAo;\n  x_litShaderArgs.ao = x_764;\n  let x_766 : vec3<f32> = dEmission;\n  x_litShaderArgs.emission = x_766;\n  let x_768 : LitShaderArguments = x_litShaderArgs;\n  return x_768;\n}\n\nfn getReflDir_vf3_vf3_f1_mf33_(worldNormal_15 : ptr<function, vec3<f32>>, viewDir_13 : ptr<function, vec3<f32>>, gloss_6 : ptr<function, f32>, tbn_1 : ptr<function, mat3x3<f32>>) {\n  let x_2109 : vec3<f32> = *(viewDir_13);\n  let x_2110 : vec3<f32> = *(worldNormal_15);\n  dReflDirW = normalize(-(reflect(x_2109, x_2110)));\n  return;\n}\n\nfn getMetalnessModulate_struct_LitShaderArguments_f1_vf3_vf3_f1_f1_vf3_f1_f1_f1_f1_vf3_vf3_vf3_struct_IridescenceArgs_f1_f11_struct_ClearcoatArgs_f1_f1_vf31_struct_SheenArgs_f1_vf311_(litShaderArgs : ptr<function, LitShaderArguments>) {\n  var dielectricF0 : vec3<f32>;\n  let x_774 : f32 = x_534.material_f0;\n  let x_776 : vec3<f32> = (*(litShaderArgs)).specularity;\n  dielectricF0 = (x_776 * x_774);\n  let x_778 : vec3<f32> = dielectricF0;\n  let x_780 : vec3<f32> = (*(litShaderArgs)).albedo;\n  let x_782 : f32 = (*(litShaderArgs)).metalness;\n  (*(litShaderArgs)).specularity = mix(x_778, x_780, vec3<f32>(x_782, x_782, x_782));\n  let x_787 : f32 = (*(litShaderArgs)).metalness;\n  let x_790 : vec3<f32> = (*(litShaderArgs)).albedo;\n  (*(litShaderArgs)).albedo = (x_790 * (1.0f - x_787));\n  return;\n}\n\nfn addAmbient_vf3_(worldNormal_14 : ptr<function, vec3<f32>>) {\n  let x_2099 : vec3<f32> = x_534.light_globalAmbient;\n  let x_2100 : vec3<f32> = dDiffuseLight;\n  dDiffuseLight = (x_2100 + x_2099);\n  return;\n}\n\nfn occludeDiffuse_f1_(ao : ptr<function, f32>) {\n  let x_818 : f32 = *(ao);\n  let x_819 : vec3<f32> = dDiffuseLight;\n  dDiffuseLight = (x_819 * x_818);\n  return;\n}\n\nfn saturate_f1_(x_1 : ptr<function, f32>) -> f32 {\n  let x_378 : f32 = *(x_1);\n  return clamp(x_378, 0.0f, 1.0f);\n}\n\nfn LTC_Uv_vf3_vf3_f1_(N : vec3<f32>, V : vec3<f32>, roughness : f32) -> vec2<f32> {\n  var dotNV : f32;\n  var param_12 : f32;\n  var uv_5 : vec2<f32>;\n  param_12 = dot(N, V);\n  let x_860 : f32 = saturate_f1_(&(param_12));\n  dotNV = x_860;\n  let x_862 : f32 = dotNV;\n  uv_5 = vec2<f32>(roughness, sqrt((1.0f - x_862)));\n  let x_866 : vec2<f32> = uv_5;\n  uv_5 = ((x_866 * 0.984375f) + vec2<f32>(0.0078125f, 0.0078125f));\n  let x_872 : vec2<f32> = uv_5;\n  return x_872;\n}\n\nfn getLTCLightUV_f1_vf3_vf3_(gloss_2 : ptr<function, f32>, worldNormal_2 : ptr<function, vec3<f32>>, viewDir_2 : ptr<function, vec3<f32>>) -> vec2<f32> {\n  var roughness_1 : f32;\n  let x_1130 : f32 = *(gloss_2);\n  let x_1132 : f32 = *(gloss_2);\n  roughness_1 = max(((1.0f - x_1130) * (1.0f - x_1132)), 0.001f);\n  let x_1137 : vec3<f32> = *(worldNormal_2);\n  let x_1138 : vec3<f32> = *(viewDir_2);\n  let x_1139 : f32 = roughness_1;\n  let x_1140 : vec2<f32> = LTC_Uv_vf3_vf3_f1_(x_1137, x_1138, x_1139);\n  return x_1140;\n}\n\nfn getLTCLightSpecFres_vf2_vf3_(uv : ptr<function, vec2<f32>>, specularity_1 : ptr<function, vec3<f32>>) -> vec3<f32> {\n  var t2 : vec4<f32>;\n  let x_1149 : vec2<f32> = *(uv);\n  let x_1150 : vec4<f32> = textureSampleLevel(areaLightsLutTex2, areaLightsLutTex2_sampler, x_1149, 0.0f);\n  t2 = x_1150;\n  let x_1153 : vec4<f32> = t2;\n  t2 = (x_1153 * vec4<f32>(0.693103015f, 1.0f, 1.0f, 1.0f));\n  let x_1157 : vec4<f32> = t2;\n  t2 = (x_1157 + vec4<f32>(0.306897014f, 0.0f, 0.0f, 0.0f));\n  let x_1159 : vec3<f32> = *(specularity_1);\n  let x_1161 : f32 = t2.x;\n  let x_1163 : vec3<f32> = *(specularity_1);\n  let x_1166 : f32 = t2.y;\n  return ((x_1159 * x_1161) + ((vec3<f32>(1.0f, 1.0f, 1.0f) - x_1163) * x_1166));\n}\n\nfn calcLTCLightValues_f1_vf3_vf3_vf3_f1_vf3_f1_(gloss_3 : ptr<function, f32>, worldNormal_3 : ptr<function, vec3<f32>>, viewDir_3 : ptr<function, vec3<f32>>, specularity_2 : ptr<function, vec3<f32>>, clearcoatGloss : ptr<function, f32>, clearcoatWorldNormal : ptr<function, vec3<f32>>, clearcoatSpecularity : ptr<function, f32>) {\n  var param_16 : f32;\n  var param_17 : vec3<f32>;\n  var param_18 : vec3<f32>;\n  var param_19 : vec2<f32>;\n  var param_20 : vec3<f32>;\n  let x_1174 : f32 = *(gloss_3);\n  param_16 = x_1174;\n  let x_1176 : vec3<f32> = *(worldNormal_3);\n  param_17 = x_1176;\n  let x_1178 : vec3<f32> = *(viewDir_3);\n  param_18 = x_1178;\n  let x_1179 : vec2<f32> = getLTCLightUV_f1_vf3_vf3_(&(param_16), &(param_17), &(param_18));\n  dLTCUV = x_1179;\n  let x_1182 : vec2<f32> = dLTCUV;\n  param_19 = x_1182;\n  let x_1184 : vec3<f32> = *(specularity_2);\n  param_20 = x_1184;\n  let x_1185 : vec3<f32> = getLTCLightSpecFres_vf2_vf3_(&(param_19), &(param_20));\n  dLTCSpecFres = x_1185;\n  return;\n}\n\nfn sampleLightsTexture8_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_i1_(clusterLightData : ClusterLightData, index : ptr<function, i32>) -> vec4<f32> {\n  let x_2122 : i32 = *(index);\n  let x_2126 : vec4<f32> = textureLoad(lightsTexture8, vec2<i32>(x_2122, clusterLightData.lightIndex), 0i);\n  return x_2126;\n}\n\nfn bytes2float2_vf2_(data : ptr<function, vec2<f32>>) -> f32 {\n  let x_2114 : vec2<f32> = *(data);\n  return dot(x_2114, vec2<f32>(1.0f, 0.003921569f));\n}\n\nfn sampleLightTextureF_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_i1_(clusterLightData_1 : ClusterLightData, index_1 : ptr<function, i32>) -> vec4<f32> {\n  let x_2131 : i32 = *(index_1);\n  let x_2134 : vec4<f32> = textureLoad(lightsTextureFloat, vec2<i32>(x_2131, clusterLightData_1.lightIndex), 0i);\n  return x_2134;\n}\n\nfn decodeClusterLightCore_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_f1_(clusterLightData_2 : ptr<function, ClusterLightData>, lightIndex : ptr<function, f32>) {\n  var lightInfo : vec4<f32>;\n  var param_59 : i32;\n  var colorA : vec4<f32>;\n  var param_60 : i32;\n  var colorB : vec4<f32>;\n  var param_61 : i32;\n  var param_62 : vec2<f32>;\n  var param_63 : vec2<f32>;\n  var param_64 : vec2<f32>;\n  var lightPosRange : vec4<f32>;\n  var param_65 : i32;\n  var lightDir_Unused : vec4<f32>;\n  var param_66 : i32;\n  let x_2137 : f32 = *(lightIndex);\n  (*(clusterLightData_2)).lightIndex = i32(x_2137);\n  let x_2141 : ClusterLightData = *(clusterLightData_2);\n  param_59 = 0i;\n  let x_2143 : vec4<f32> = sampleLightsTexture8_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_i1_(x_2141, &(param_59));\n  lightInfo = x_2143;\n  let x_2145 : f32 = lightInfo.x;\n  (*(clusterLightData_2)).lightType = x_2145;\n  let x_2148 : f32 = lightInfo.y;\n  (*(clusterLightData_2)).shape = x_2148;\n  let x_2151 : f32 = lightInfo.z;\n  (*(clusterLightData_2)).falloffMode = x_2151;\n  let x_2154 : f32 = lightInfo.w;\n  (*(clusterLightData_2)).shadowIntensity = x_2154;\n  let x_2157 : ClusterLightData = *(clusterLightData_2);\n  param_60 = 1i;\n  let x_2159 : vec4<f32> = sampleLightsTexture8_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_i1_(x_2157, &(param_60));\n  colorA = x_2159;\n  let x_2161 : ClusterLightData = *(clusterLightData_2);\n  param_61 = 2i;\n  let x_2163 : vec4<f32> = sampleLightsTexture8_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_i1_(x_2161, &(param_61));\n  colorB = x_2163;\n  let x_2165 : vec4<f32> = colorA;\n  param_62 = vec2<f32>(x_2165.x, x_2165.y);\n  let x_2167 : f32 = bytes2float2_vf2_(&(param_62));\n  let x_2169 : vec4<f32> = colorA;\n  param_63 = vec2<f32>(x_2169.z, x_2169.w);\n  let x_2171 : f32 = bytes2float2_vf2_(&(param_63));\n  let x_2173 : vec4<f32> = colorB;\n  param_64 = vec2<f32>(x_2173.x, x_2173.y);\n  let x_2175 : f32 = bytes2float2_vf2_(&(param_64));\n  let x_2179 : f32 = x_534.clusterCompressionLimit0.y;\n  (*(clusterLightData_2)).color = (vec3<f32>(x_2167, x_2171, x_2175) * x_2179);\n  let x_2184 : f32 = colorB.z;\n  (*(clusterLightData_2)).cookie = x_2184;\n  let x_2187 : f32 = colorB.w;\n  (*(clusterLightData_2)).mask = x_2187;\n  let x_2190 : ClusterLightData = *(clusterLightData_2);\n  param_65 = 0i;\n  let x_2192 : vec4<f32> = sampleLightTextureF_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_i1_(x_2190, &(param_65));\n  lightPosRange = x_2192;\n  let x_2193 : vec4<f32> = lightPosRange;\n  (*(clusterLightData_2)).position = vec3<f32>(x_2193.x, x_2193.y, x_2193.z);\n  let x_2197 : f32 = lightPosRange.w;\n  (*(clusterLightData_2)).range = x_2197;\n  let x_2200 : ClusterLightData = *(clusterLightData_2);\n  param_66 = 1i;\n  let x_2202 : vec4<f32> = sampleLightTextureF_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_i1_(x_2200, &(param_66));\n  lightDir_Unused = x_2202;\n  let x_2203 : vec4<f32> = lightDir_Unused;\n  (*(clusterLightData_2)).direction = vec3<f32>(x_2203.x, x_2203.y, x_2203.z);\n  return;\n}\n\nfn getLightDirPoint_vf3_(lightPosW : ptr<function, vec3<f32>>) {\n  let x_460 : vec3<f32> = vPositionW;\n  let x_461 : vec3<f32> = *(lightPosW);\n  dLightDirW = (x_460 - x_461);\n  let x_464 : vec3<f32> = dLightDirW;\n  dLightDirNormW = normalize(x_464);\n  let x_467 : vec3<f32> = *(lightPosW);\n  dLightPosW = x_467;\n  return;\n}\n\nfn decodeClusterLightAreaData_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_(clusterLightData_4 : ptr<function, ClusterLightData>) {\n  var param_70 : i32;\n  var param_71 : i32;\n  let x_2226 : ClusterLightData = *(clusterLightData_4);\n  param_70 = 6i;\n  let x_2228 : vec4<f32> = sampleLightTextureF_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_i1_(x_2226, &(param_70));\n  (*(clusterLightData_4)).halfWidth = vec3<f32>(x_2228.x, x_2228.y, x_2228.z);\n  let x_2231 : ClusterLightData = *(clusterLightData_4);\n  param_71 = 7i;\n  let x_2233 : vec4<f32> = sampleLightTextureF_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_i1_(x_2231, &(param_71));\n  (*(clusterLightData_4)).halfHeight = vec3<f32>(x_2233.x, x_2233.y, x_2233.z);\n  return;\n}\n\nfn getLTCLightCoords_vf3_vf3_vf3_(lightPos : ptr<function, vec3<f32>>, halfWidth : ptr<function, vec3<f32>>, halfHeight : ptr<function, vec3<f32>>) -> Coords {\n  var coords_1 : Coords;\n  let x_1064 : vec3<f32> = *(lightPos);\n  let x_1065 : vec3<f32> = *(halfWidth);\n  let x_1067 : vec3<f32> = *(halfHeight);\n  coords_1.coord0 = ((x_1064 + x_1065) - x_1067);\n  let x_1070 : vec3<f32> = *(lightPos);\n  let x_1071 : vec3<f32> = *(halfWidth);\n  let x_1073 : vec3<f32> = *(halfHeight);\n  coords_1.coord1 = ((x_1070 - x_1071) - x_1073);\n  let x_1076 : vec3<f32> = *(lightPos);\n  let x_1077 : vec3<f32> = *(halfWidth);\n  let x_1079 : vec3<f32> = *(halfHeight);\n  coords_1.coord2 = ((x_1076 - x_1077) + x_1079);\n  let x_1082 : vec3<f32> = *(lightPos);\n  let x_1083 : vec3<f32> = *(halfWidth);\n  let x_1085 : vec3<f32> = *(halfHeight);\n  coords_1.coord3 = ((x_1082 + x_1083) + x_1085);\n  let x_1088 : Coords = coords_1;\n  return x_1088;\n}\n\nfn calcRectLightValues_vf3_vf3_vf3_(lightPos_2 : ptr<function, vec3<f32>>, halfWidth_2 : ptr<function, vec3<f32>>, halfHeight_2 : ptr<function, vec3<f32>>) {\n  var param_21 : vec3<f32>;\n  var param_22 : vec3<f32>;\n  var param_23 : vec3<f32>;\n  let x_1189 : vec3<f32> = *(lightPos_2);\n  param_21 = x_1189;\n  let x_1191 : vec3<f32> = *(halfWidth_2);\n  param_22 = x_1191;\n  let x_1193 : vec3<f32> = *(halfHeight_2);\n  param_23 = x_1193;\n  let x_1194 : Coords = getLTCLightCoords_vf3_vf3_vf3_(&(param_21), &(param_22), &(param_23));\n  dLTCCoords = x_1194;\n  return;\n}\n\nfn calcDiskLightValues_vf3_vf3_vf3_(lightPos_3 : ptr<function, vec3<f32>>, halfWidth_3 : ptr<function, vec3<f32>>, halfHeight_3 : ptr<function, vec3<f32>>) {\n  var param_24 : vec3<f32>;\n  var param_25 : vec3<f32>;\n  var param_26 : vec3<f32>;\n  let x_1196 : vec3<f32> = *(lightPos_3);\n  param_24 = x_1196;\n  let x_1198 : vec3<f32> = *(halfWidth_3);\n  param_25 = x_1198;\n  let x_1200 : vec3<f32> = *(halfHeight_3);\n  param_26 = x_1200;\n  calcRectLightValues_vf3_vf3_vf3_(&(param_24), &(param_25), &(param_26));\n  return;\n}\n\nfn getSphereLightCoords_vf3_vf3_vf3_(lightPos_1 : ptr<function, vec3<f32>>, halfWidth_1 : ptr<function, vec3<f32>>, halfHeight_1 : ptr<function, vec3<f32>>) -> Coords {\n  var f_1 : vec3<f32>;\n  var w : vec3<f32>;\n  var h_2 : vec3<f32>;\n  var param_13 : vec3<f32>;\n  var param_14 : vec3<f32>;\n  var param_15 : vec3<f32>;\n  let x_1092 : vec3<f32> = *(halfWidth_1);\n  let x_1094 : vec3<f32> = *(halfHeight_1);\n  dSphereRadius = max(length(x_1092), length(x_1094));\n  let x_1098 : vec3<f32> = *(lightPos_1);\n  let x_1100 : vec3<f32> = x_534.view_position;\n  let x_1102 : vec3<f32> = normalize((x_1098 - x_1100));\n  let x_1104 : vec3<f32> = vNormalW;\n  f_1 = reflect(x_1102, x_1104);\n  let x_1107 : vec3<f32> = f_1;\n  let x_1108 : vec3<f32> = *(halfHeight_1);\n  w = normalize(cross(x_1107, x_1108));\n  let x_1112 : vec3<f32> = f_1;\n  let x_1113 : vec3<f32> = w;\n  h_2 = normalize(cross(x_1112, x_1113));\n  let x_1116 : vec3<f32> = w;\n  let x_1117 : f32 = dSphereRadius;\n  let x_1119 : vec3<f32> = h_2;\n  let x_1120 : f32 = dSphereRadius;\n  let x_1123 : vec3<f32> = *(lightPos_1);\n  param_13 = x_1123;\n  param_14 = (x_1116 * x_1117);\n  param_15 = (x_1119 * x_1120);\n  let x_1126 : Coords = getLTCLightCoords_vf3_vf3_vf3_(&(param_13), &(param_14), &(param_15));\n  return x_1126;\n}\n\nfn calcSphereLightValues_vf3_vf3_vf3_(lightPos_4 : ptr<function, vec3<f32>>, halfWidth_4 : ptr<function, vec3<f32>>, halfHeight_4 : ptr<function, vec3<f32>>) {\n  var param_27 : vec3<f32>;\n  var param_28 : vec3<f32>;\n  var param_29 : vec3<f32>;\n  let x_1203 : vec3<f32> = *(lightPos_4);\n  param_27 = x_1203;\n  let x_1205 : vec3<f32> = *(halfWidth_4);\n  param_28 = x_1205;\n  let x_1207 : vec3<f32> = *(halfHeight_4);\n  param_29 = x_1207;\n  let x_1208 : Coords = getSphereLightCoords_vf3_vf3_vf3_(&(param_27), &(param_28), &(param_29));\n  dLTCCoords = x_1208;\n  return;\n}\n\nfn square_f1_(x : ptr<function, f32>) -> f32 {\n  let x_373 : f32 = *(x);\n  let x_374 : f32 = *(x);\n  return (x_373 * x_374);\n}\n\nfn getFalloffWindow_f1_vf3_(lightRadius : ptr<function, f32>, lightDir : ptr<function, vec3<f32>>) -> f32 {\n  var sqrDist : f32;\n  var invRadius : f32;\n  var param : f32;\n  var param_1 : f32;\n  var param_2 : f32;\n  var param_3 : f32;\n  let x_394 : vec3<f32> = *(lightDir);\n  let x_395 : vec3<f32> = *(lightDir);\n  sqrDist = dot(x_394, x_395);\n  let x_398 : f32 = *(lightRadius);\n  invRadius = (1.0f / x_398);\n  let x_400 : f32 = sqrDist;\n  let x_402 : f32 = invRadius;\n  param = x_402;\n  let x_403 : f32 = square_f1_(&(param));\n  param_1 = (x_400 * x_403);\n  let x_406 : f32 = square_f1_(&(param_1));\n  param_2 = (1.0f - x_406);\n  let x_409 : f32 = saturate_f1_(&(param_2));\n  param_3 = x_409;\n  let x_411 : f32 = square_f1_(&(param_3));\n  return x_411;\n}\n\nfn getFalloffLinear_f1_vf3_(lightRadius_2 : ptr<function, f32>, lightDir_2 : ptr<function, vec3<f32>>) -> f32 {\n  var d : f32;\n  let x_446 : vec3<f32> = *(lightDir_2);\n  d = length(x_446);\n  let x_448 : f32 = *(lightRadius_2);\n  let x_449 : f32 = d;\n  let x_451 : f32 = *(lightRadius_2);\n  return max(((x_448 - x_449) / x_451), 0.0f);\n}\n\nfn getFalloffInvSquared_f1_vf3_(lightRadius_1 : ptr<function, f32>, lightDir_1 : ptr<function, vec3<f32>>) -> f32 {\n  var sqrDist_1 : f32;\n  var falloff : f32;\n  var invRadius_1 : f32;\n  var param_4 : f32;\n  var param_5 : f32;\n  var param_6 : f32;\n  var param_7 : f32;\n  let x_415 : vec3<f32> = *(lightDir_1);\n  let x_416 : vec3<f32> = *(lightDir_1);\n  sqrDist_1 = dot(x_415, x_416);\n  let x_419 : f32 = sqrDist_1;\n  falloff = (1.0f / (x_419 + 1.0f));\n  let x_423 : f32 = *(lightRadius_1);\n  invRadius_1 = (1.0f / x_423);\n  let x_426 : f32 = falloff;\n  falloff = (x_426 * 16.0f);\n  let x_428 : f32 = sqrDist_1;\n  let x_430 : f32 = invRadius_1;\n  param_4 = x_430;\n  let x_431 : f32 = square_f1_(&(param_4));\n  param_5 = (x_428 * x_431);\n  let x_434 : f32 = square_f1_(&(param_5));\n  param_6 = (1.0f - x_434);\n  let x_437 : f32 = saturate_f1_(&(param_6));\n  param_7 = x_437;\n  let x_439 : f32 = square_f1_(&(param_7));\n  let x_440 : f32 = falloff;\n  falloff = (x_440 * x_439);\n  let x_442 : f32 = falloff;\n  return x_442;\n}\n\nfn transposeMat3_mf33_(m : mat3x3<f32>) -> mat3x3<f32> {\n  var tmp : mat3x3<f32>;\n  tmp[0i] = vec3<f32>(m[0u].x, m[1u].x, m[2u].x);\n  tmp[1i] = vec3<f32>(m[0u].y, m[1u].y, m[2u].y);\n  tmp[2i] = vec3<f32>(m[0u].z, m[1u].z, m[2u].z);\n  let x_854 : mat3x3<f32> = tmp;\n  return x_854;\n}\n\nfn LTC_EdgeVectorFormFactor_vf3_vf3_(v1 : vec3<f32>, v2 : vec3<f32>) -> vec3<f32> {\n  var x_3 : f32;\n  var y : f32;\n  var a : f32;\n  var b : f32;\n  var v : f32;\n  var theta_sintheta : f32;\n  var x_918 : f32;\n  x_3 = dot(v1, v2);\n  let x_891 : f32 = x_3;\n  y = abs(x_891);\n  let x_897 : f32 = y;\n  let x_900 : f32 = y;\n  a = (0.854398489f + ((0.496515512f + (0.0145206f * x_897)) * x_900));\n  let x_906 : f32 = y;\n  let x_908 : f32 = y;\n  b = (3.417593956f + ((4.161672592f + x_906) * x_908));\n  let x_912 : f32 = a;\n  let x_913 : f32 = b;\n  v = (x_912 / x_913);\n  let x_916 : f32 = x_3;\n  if ((x_916 > 0.0f)) {\n    let x_921 : f32 = v;\n    x_918 = x_921;\n  } else {\n    let x_924 : f32 = x_3;\n    let x_925 : f32 = x_3;\n    let x_931 : f32 = v;\n    x_918 = ((0.5f * inverseSqrt(max((1.0f - (x_924 * x_925)), 0.0000001f))) - x_931);\n  }\n  let x_933 : f32 = x_918;\n  theta_sintheta = x_933;\n  let x_935 : f32 = theta_sintheta;\n  return (cross(v1, v2) * x_935);\n}\n\nfn LTC_ClippedSphereFormFactor_vf3_(f : vec3<f32>) -> f32 {\n  var l : f32;\n  l = length(f);\n  let x_877 : f32 = l;\n  let x_878 : f32 = l;\n  let x_882 : f32 = l;\n  return max((((x_877 * x_878) + f.z) / (x_882 + 1.0f)), 0.0f);\n}\n\nfn LTC_EvaluateRect_vf3_vf3_vf3_mf33_struct_Coords_vf3_vf3_vf3_vf31_(N_1 : vec3<f32>, V_1 : vec3<f32>, P : vec3<f32>, mInv : mat3x3<f32>, rectCoords : Coords) -> f32 {\n  var v1_1 : vec3<f32>;\n  var v2_1 : vec3<f32>;\n  var lightNormal : vec3<f32>;\n  var factor : f32;\n  var T1 : vec3<f32>;\n  var T2 : vec3<f32>;\n  var mat : mat3x3<f32>;\n  var coords : array<vec3<f32>, 4u>;\n  var vectorFormFactor : vec3<f32>;\n  var result : f32;\n  v1_1 = (rectCoords.coord1 - rectCoords.coord0);\n  v2_1 = (rectCoords.coord3 - rectCoords.coord0);\n  let x_949 : vec3<f32> = v1_1;\n  let x_950 : vec3<f32> = v2_1;\n  lightNormal = cross(x_949, x_950);\n  let x_953 : vec3<f32> = lightNormal;\n  factor = sign(-(dot(x_953, (P - rectCoords.coord0))));\n  T1 = normalize((V_1 - (N_1 * dot(V_1, N_1))));\n  let x_965 : f32 = factor;\n  let x_966 : vec3<f32> = T1;\n  T2 = (cross(N_1, x_966) * x_965);\n  let x_970 : vec3<f32> = T1;\n  let x_971 : vec3<f32> = T2;\n  let x_985 : mat3x3<f32> = transposeMat3_mf33_(mat3x3<f32>(vec3<f32>(x_970.x, x_970.y, x_970.z), vec3<f32>(x_971.x, x_971.y, x_971.z), vec3<f32>(N_1.x, N_1.y, N_1.z)));\n  mat = (mInv * x_985);\n  let x_991 : mat3x3<f32> = mat;\n  coords[0i] = (x_991 * (rectCoords.coord0 - P));\n  let x_996 : mat3x3<f32> = mat;\n  coords[1i] = (x_996 * (rectCoords.coord1 - P));\n  let x_1001 : mat3x3<f32> = mat;\n  coords[2i] = (x_1001 * (rectCoords.coord2 - P));\n  let x_1006 : mat3x3<f32> = mat;\n  coords[3i] = (x_1006 * (rectCoords.coord3 - P));\n  let x_1012 : vec3<f32> = coords[0i];\n  coords[0i] = normalize(x_1012);\n  let x_1016 : vec3<f32> = coords[1i];\n  coords[1i] = normalize(x_1016);\n  let x_1020 : vec3<f32> = coords[2i];\n  coords[2i] = normalize(x_1020);\n  let x_1024 : vec3<f32> = coords[3i];\n  coords[3i] = normalize(x_1024);\n  vectorFormFactor = vec3<f32>(0.0f, 0.0f, 0.0f);\n  let x_1030 : vec3<f32> = coords[0i];\n  let x_1032 : vec3<f32> = coords[1i];\n  let x_1033 : vec3<f32> = LTC_EdgeVectorFormFactor_vf3_vf3_(x_1030, x_1032);\n  let x_1034 : vec3<f32> = vectorFormFactor;\n  vectorFormFactor = (x_1034 + x_1033);\n  let x_1037 : vec3<f32> = coords[1i];\n  let x_1039 : vec3<f32> = coords[2i];\n  let x_1040 : vec3<f32> = LTC_EdgeVectorFormFactor_vf3_vf3_(x_1037, x_1039);\n  let x_1041 : vec3<f32> = vectorFormFactor;\n  vectorFormFactor = (x_1041 + x_1040);\n  let x_1044 : vec3<f32> = coords[2i];\n  let x_1046 : vec3<f32> = coords[3i];\n  let x_1047 : vec3<f32> = LTC_EdgeVectorFormFactor_vf3_vf3_(x_1044, x_1046);\n  let x_1048 : vec3<f32> = vectorFormFactor;\n  vectorFormFactor = (x_1048 + x_1047);\n  let x_1051 : vec3<f32> = coords[3i];\n  let x_1053 : vec3<f32> = coords[0i];\n  let x_1054 : vec3<f32> = LTC_EdgeVectorFormFactor_vf3_vf3_(x_1051, x_1053);\n  let x_1055 : vec3<f32> = vectorFormFactor;\n  vectorFormFactor = (x_1055 + x_1054);\n  let x_1058 : vec3<f32> = vectorFormFactor;\n  let x_1059 : f32 = LTC_ClippedSphereFormFactor_vf3_(x_1058);\n  result = x_1059;\n  let x_1060 : f32 = result;\n  return x_1060;\n}\n\nfn getRectLightDiffuse_vf3_vf3_vf3_vf3_(worldNormal_4 : ptr<function, vec3<f32>>, viewDir_4 : ptr<function, vec3<f32>>, lightDir_4 : ptr<function, vec3<f32>>, lightDirNorm_2 : ptr<function, vec3<f32>>) -> f32 {\n  let x_1912 : vec3<f32> = *(worldNormal_4);\n  let x_1913 : vec3<f32> = *(viewDir_4);\n  let x_1914 : vec3<f32> = vPositionW;\n  let x_1918 : Coords = dLTCCoords;\n  let x_1919 : f32 = LTC_EvaluateRect_vf3_vf3_vf3_mf33_struct_Coords_vf3_vf3_vf3_vf31_(x_1912, x_1913, x_1914, mat3x3<f32>(vec3<f32>(1.0f, 0.0f, 0.0f), vec3<f32>(0.0f, 1.0f, 0.0f), vec3<f32>(0.0f, 0.0f, 1.0f)), x_1918);\n  return x_1919;\n}\n\nfn SolveCubic_vf4_(Coefficient : ptr<function, vec4<f32>>) -> vec3<f32> {\n  var pi : f32;\n  var A : f32;\n  var B_1 : f32;\n  var C : f32;\n  var D : f32;\n  var Delta : vec3<f32>;\n  var Discriminant : f32;\n  var A_a : f32;\n  var C_a : f32;\n  var D_a : f32;\n  var Theta : f32;\n  var x_1a : f32;\n  var x_3a : f32;\n  var xl : f32;\n  var xlc : vec2<f32>;\n  var A_d : f32;\n  var C_d : f32;\n  var D_d : f32;\n  var Theta_1 : f32;\n  var x_1d : f32;\n  var x_3d : f32;\n  var xs : f32;\n  var xsc : vec2<f32>;\n  var E : f32;\n  var F : f32;\n  var G : f32;\n  var xmc : vec2<f32>;\n  var Root : vec3<f32>;\n  var x_1473 : bool;\n  var x_1474 : bool;\n  pi = 3.141590118f;\n  let x_1213 : f32 = (*(Coefficient)).w;\n  let x_1214 : vec4<f32> = *(Coefficient);\n  let x_1217 : vec3<f32> = (vec3<f32>(x_1214.x, x_1214.y, x_1214.z) / vec3<f32>(x_1213, x_1213, x_1213));\n  let x_1218 : vec4<f32> = *(Coefficient);\n  *(Coefficient) = vec4<f32>(x_1217.x, x_1217.y, x_1217.z, x_1218.w);\n  let x_1221 : vec4<f32> = *(Coefficient);\n  let x_1224 : vec2<f32> = (vec2<f32>(x_1221.y, x_1221.z) / vec2<f32>(3.0f, 3.0f));\n  let x_1225 : vec4<f32> = *(Coefficient);\n  *(Coefficient) = vec4<f32>(x_1225.x, x_1224.x, x_1224.y, x_1225.w);\n  let x_1229 : f32 = (*(Coefficient)).w;\n  A = x_1229;\n  let x_1232 : f32 = (*(Coefficient)).z;\n  B_1 = x_1232;\n  let x_1235 : f32 = (*(Coefficient)).y;\n  C = x_1235;\n  let x_1238 : f32 = (*(Coefficient)).x;\n  D = x_1238;\n  let x_1241 : f32 = (*(Coefficient)).z;\n  let x_1244 : f32 = (*(Coefficient)).z;\n  let x_1247 : f32 = (*(Coefficient)).y;\n  let x_1250 : f32 = (*(Coefficient)).y;\n  let x_1253 : f32 = (*(Coefficient)).z;\n  let x_1256 : f32 = (*(Coefficient)).x;\n  let x_1259 : f32 = (*(Coefficient)).z;\n  let x_1261 : f32 = (*(Coefficient)).y;\n  let x_1264 : vec4<f32> = *(Coefficient);\n  Delta = vec3<f32>(((-(x_1241) * x_1244) + x_1247), ((-(x_1250) * x_1253) + x_1256), dot(vec2<f32>(x_1259, -(x_1261)), vec2<f32>(x_1264.x, x_1264.y)));\n  let x_1271 : f32 = Delta.x;\n  let x_1274 : f32 = Delta.y;\n  let x_1277 : vec3<f32> = Delta;\n  Discriminant = dot(vec2<f32>((4.0f * x_1271), -(x_1274)), vec2<f32>(x_1277.z, x_1277.y));\n  A_a = 1.0f;\n  let x_1283 : f32 = Delta.x;\n  C_a = x_1283;\n  let x_1286 : f32 = B_1;\n  let x_1289 : f32 = Delta.x;\n  let x_1292 : f32 = Delta.y;\n  D_a = (((-2.0f * x_1286) * x_1289) + x_1292);\n  let x_1295 : f32 = Discriminant;\n  let x_1297 : f32 = D_a;\n  Theta = (atan2(sqrt(x_1295), -(x_1297)) / 3.0f);\n  let x_1302 : f32 = C_a;\n  let x_1306 : f32 = Theta;\n  x_1a = ((2.0f * sqrt(-(x_1302))) * cos(x_1306));\n  let x_1310 : f32 = C_a;\n  let x_1314 : f32 = Theta;\n  let x_1316 : f32 = pi;\n  x_3a = ((2.0f * sqrt(-(x_1310))) * cos((x_1314 + (0.666666687f * x_1316))));\n  let x_1321 : f32 = x_1a;\n  let x_1322 : f32 = x_3a;\n  let x_1324 : f32 = B_1;\n  if (((x_1321 + x_1322) > (2.0f * x_1324))) {\n    let x_1330 : f32 = x_1a;\n    xl = x_1330;\n  } else {\n    let x_1332 : f32 = x_3a;\n    xl = x_1332;\n  }\n  let x_1334 : f32 = xl;\n  let x_1335 : f32 = B_1;\n  let x_1337 : f32 = A;\n  xlc = vec2<f32>((x_1334 - x_1335), x_1337);\n  let x_1340 : f32 = D;\n  A_d = x_1340;\n  let x_1343 : f32 = Delta.z;\n  C_d = x_1343;\n  let x_1345 : f32 = D;\n  let x_1348 : f32 = Delta.y;\n  let x_1350 : f32 = C;\n  let x_1353 : f32 = Delta.z;\n  D_d = ((-(x_1345) * x_1348) + ((2.0f * x_1350) * x_1353));\n  let x_1357 : f32 = D;\n  let x_1358 : f32 = Discriminant;\n  let x_1361 : f32 = D_d;\n  Theta_1 = (atan2((x_1357 * sqrt(x_1358)), -(x_1361)) / 3.0f);\n  let x_1366 : f32 = C_d;\n  let x_1370 : f32 = Theta_1;\n  x_1d = ((2.0f * sqrt(-(x_1366))) * cos(x_1370));\n  let x_1374 : f32 = C_d;\n  let x_1378 : f32 = Theta_1;\n  let x_1379 : f32 = pi;\n  x_3d = ((2.0f * sqrt(-(x_1374))) * cos((x_1378 + (0.666666687f * x_1379))));\n  let x_1384 : f32 = x_1d;\n  let x_1385 : f32 = x_3d;\n  let x_1387 : f32 = C;\n  if (((x_1384 + x_1385) < (2.0f * x_1387))) {\n    let x_1393 : f32 = x_1d;\n    xs = x_1393;\n  } else {\n    let x_1395 : f32 = x_3d;\n    xs = x_1395;\n  }\n  let x_1397 : f32 = D;\n  let x_1399 : f32 = xs;\n  let x_1400 : f32 = C;\n  xsc = vec2<f32>(-(x_1397), (x_1399 + x_1400));\n  let x_1405 : f32 = xlc.y;\n  let x_1407 : f32 = xsc.y;\n  E = (x_1405 * x_1407);\n  let x_1411 : f32 = xlc.x;\n  let x_1414 : f32 = xsc.y;\n  let x_1417 : f32 = xlc.y;\n  let x_1419 : f32 = xsc.x;\n  F = ((-(x_1411) * x_1414) - (x_1417 * x_1419));\n  let x_1424 : f32 = xlc.x;\n  let x_1426 : f32 = xsc.x;\n  G = (x_1424 * x_1426);\n  let x_1429 : f32 = C;\n  let x_1430 : f32 = F;\n  let x_1432 : f32 = B_1;\n  let x_1433 : f32 = G;\n  let x_1436 : f32 = B_1;\n  let x_1438 : f32 = F;\n  let x_1440 : f32 = C;\n  let x_1441 : f32 = E;\n  xmc = vec2<f32>(((x_1429 * x_1430) - (x_1432 * x_1433)), ((-(x_1436) * x_1438) + (x_1440 * x_1441)));\n  let x_1447 : f32 = xsc.x;\n  let x_1449 : f32 = xsc.y;\n  let x_1452 : f32 = xmc.x;\n  let x_1454 : f32 = xmc.y;\n  let x_1457 : f32 = xlc.x;\n  let x_1459 : f32 = xlc.y;\n  Root = vec3<f32>((x_1447 / x_1449), (x_1452 / x_1454), (x_1457 / x_1459));\n  let x_1463 : f32 = Root.x;\n  let x_1465 : f32 = Root.y;\n  let x_1466 : bool = (x_1463 < x_1465);\n  x_1474 = x_1466;\n  if (x_1466) {\n    let x_1470 : f32 = Root.x;\n    let x_1472 : f32 = Root.z;\n    x_1473 = (x_1470 < x_1472);\n    x_1474 = x_1473;\n  }\n  var x_1491 : bool;\n  var x_1492 : bool;\n  if (x_1474) {\n    let x_1477 : vec3<f32> = Root;\n    Root = vec3<f32>(x_1477.y, x_1477.x, x_1477.z);\n  } else {\n    let x_1481 : f32 = Root.z;\n    let x_1483 : f32 = Root.x;\n    let x_1484 : bool = (x_1481 < x_1483);\n    x_1492 = x_1484;\n    if (x_1484) {\n      let x_1488 : f32 = Root.z;\n      let x_1490 : f32 = Root.y;\n      x_1491 = (x_1488 < x_1490);\n      x_1492 = x_1491;\n    }\n    if (x_1492) {\n      let x_1495 : vec3<f32> = Root;\n      Root = vec3<f32>(x_1495.x, x_1495.z, x_1495.y);\n    }\n  }\n  let x_1497 : vec3<f32> = Root;\n  return x_1497;\n}\n\nfn LTC_EvaluateDisk_vf3_vf3_vf3_mf33_struct_Coords_vf3_vf3_vf3_vf31_(N_2 : ptr<function, vec3<f32>>, V_2 : ptr<function, vec3<f32>>, P_1 : ptr<function, vec3<f32>>, Minv : ptr<function, mat3x3<f32>>, points : ptr<function, Coords>) -> f32 {\n  var T1_1 : vec3<f32>;\n  var T2_1 : vec3<f32>;\n  var R : mat3x3<f32>;\n  var L_ : array<vec3<f32>, 3u>;\n  var Lo_i : vec3<f32>;\n  var C_1 : vec3<f32>;\n  var V1 : vec3<f32>;\n  var V2 : vec3<f32>;\n  var d11 : f32;\n  var d22 : f32;\n  var d12 : f32;\n  var tr : f32;\n  var det : f32;\n  var u : f32;\n  var v_1 : f32;\n  var e_max : f32;\n  var e_min : f32;\n  var V1_ : vec3<f32>;\n  var V2_ : vec3<f32>;\n  var a_1 : f32;\n  var b_1 : f32;\n  var V3 : vec3<f32>;\n  var L : f32;\n  var x0 : f32;\n  var y0 : f32;\n  var E1 : f32;\n  var E2 : f32;\n  var c0 : f32;\n  var c1 : f32;\n  var c2 : f32;\n  var c3 : f32;\n  var roots : vec3<f32>;\n  var param_30 : vec4<f32>;\n  var e1 : f32;\n  var e2 : f32;\n  var e3 : f32;\n  var avgDir : vec3<f32>;\n  var rotate : mat3x3<f32>;\n  var L1 : f32;\n  var L2 : f32;\n  var formFactor : f32;\n  var uv_6 : vec2<f32>;\n  var scale : f32;\n  let x_1501 : vec3<f32> = *(V_2);\n  let x_1502 : vec3<f32> = *(N_2);\n  let x_1503 : vec3<f32> = *(V_2);\n  let x_1504 : vec3<f32> = *(N_2);\n  T1_1 = normalize((x_1501 - (x_1502 * dot(x_1503, x_1504))));\n  let x_1510 : vec3<f32> = *(N_2);\n  let x_1511 : vec3<f32> = T1_1;\n  T2_1 = cross(x_1510, x_1511);\n  let x_1514 : vec3<f32> = T1_1;\n  let x_1515 : vec3<f32> = T2_1;\n  let x_1516 : vec3<f32> = *(N_2);\n  let x_1530 : mat3x3<f32> = transposeMat3_mf33_(mat3x3<f32>(vec3<f32>(x_1514.x, x_1514.y, x_1514.z), vec3<f32>(x_1515.x, x_1515.y, x_1515.z), vec3<f32>(x_1516.x, x_1516.y, x_1516.z)));\n  R = x_1530;\n  let x_1534 : mat3x3<f32> = R;\n  let x_1536 : vec3<f32> = (*(points)).coord0;\n  let x_1537 : vec3<f32> = *(P_1);\n  L_[0i] = (x_1534 * (x_1536 - x_1537));\n  let x_1541 : mat3x3<f32> = R;\n  let x_1543 : vec3<f32> = (*(points)).coord1;\n  let x_1544 : vec3<f32> = *(P_1);\n  L_[1i] = (x_1541 * (x_1543 - x_1544));\n  let x_1548 : mat3x3<f32> = R;\n  let x_1550 : vec3<f32> = (*(points)).coord2;\n  let x_1551 : vec3<f32> = *(P_1);\n  L_[2i] = (x_1548 * (x_1550 - x_1551));\n  Lo_i = vec3<f32>(0.0f, 0.0f, 0.0f);\n  let x_1558 : vec3<f32> = L_[0i];\n  let x_1560 : vec3<f32> = L_[2i];\n  C_1 = ((x_1558 + x_1560) * 0.5f);\n  let x_1565 : vec3<f32> = L_[1i];\n  let x_1567 : vec3<f32> = L_[2i];\n  V1 = ((x_1565 - x_1567) * 0.5f);\n  let x_1572 : vec3<f32> = L_[1i];\n  let x_1574 : vec3<f32> = L_[0i];\n  V2 = ((x_1572 - x_1574) * 0.5f);\n  let x_1577 : mat3x3<f32> = *(Minv);\n  let x_1578 : vec3<f32> = C_1;\n  C_1 = (x_1577 * x_1578);\n  let x_1580 : mat3x3<f32> = *(Minv);\n  let x_1581 : vec3<f32> = V1;\n  V1 = (x_1580 * x_1581);\n  let x_1583 : mat3x3<f32> = *(Minv);\n  let x_1584 : vec3<f32> = V2;\n  V2 = (x_1583 * x_1584);\n  let x_1587 : vec3<f32> = V1;\n  let x_1588 : vec3<f32> = V1;\n  d11 = dot(x_1587, x_1588);\n  let x_1591 : vec3<f32> = V2;\n  let x_1592 : vec3<f32> = V2;\n  d22 = dot(x_1591, x_1592);\n  let x_1595 : vec3<f32> = V1;\n  let x_1596 : vec3<f32> = V2;\n  d12 = dot(x_1595, x_1596);\n  let x_1598 : f32 = d12;\n  let x_1600 : f32 = d11;\n  let x_1601 : f32 = d22;\n  if (((abs(x_1598) / sqrt((x_1600 * x_1601))) > 0.0001f)) {\n    let x_1610 : f32 = d11;\n    let x_1611 : f32 = d22;\n    tr = (x_1610 + x_1611);\n    let x_1614 : f32 = d12;\n    let x_1616 : f32 = d12;\n    let x_1618 : f32 = d11;\n    let x_1619 : f32 = d22;\n    det = ((-(x_1614) * x_1616) + (x_1618 * x_1619));\n    let x_1622 : f32 = det;\n    det = sqrt(x_1622);\n    let x_1625 : f32 = tr;\n    let x_1626 : f32 = det;\n    u = (0.5f * sqrt((x_1625 - (2.0f * x_1626))));\n    let x_1632 : f32 = tr;\n    let x_1633 : f32 = det;\n    v_1 = (0.5f * sqrt((x_1632 + (2.0f * x_1633))));\n    let x_1639 : f32 = u;\n    let x_1640 : f32 = v_1;\n    let x_1642 : f32 = u;\n    let x_1643 : f32 = v_1;\n    e_max = ((x_1639 + x_1640) * (x_1642 + x_1643));\n    let x_1647 : f32 = u;\n    let x_1648 : f32 = v_1;\n    let x_1650 : f32 = u;\n    let x_1651 : f32 = v_1;\n    e_min = ((x_1647 - x_1648) * (x_1650 - x_1651));\n    let x_1654 : f32 = d11;\n    let x_1655 : f32 = d22;\n    if ((x_1654 > x_1655)) {\n      let x_1660 : f32 = d12;\n      let x_1661 : vec3<f32> = V1;\n      let x_1663 : f32 = e_max;\n      let x_1664 : f32 = d11;\n      let x_1666 : vec3<f32> = V2;\n      V1_ = ((x_1661 * x_1660) + (x_1666 * (x_1663 - x_1664)));\n      let x_1670 : f32 = d12;\n      let x_1671 : vec3<f32> = V1;\n      let x_1673 : f32 = e_min;\n      let x_1674 : f32 = d11;\n      let x_1676 : vec3<f32> = V2;\n      V2_ = ((x_1671 * x_1670) + (x_1676 * (x_1673 - x_1674)));\n    } else {\n      let x_1680 : f32 = d12;\n      let x_1681 : vec3<f32> = V2;\n      let x_1683 : f32 = e_max;\n      let x_1684 : f32 = d22;\n      let x_1686 : vec3<f32> = V1;\n      V1_ = ((x_1681 * x_1680) + (x_1686 * (x_1683 - x_1684)));\n      let x_1689 : f32 = d12;\n      let x_1690 : vec3<f32> = V2;\n      let x_1692 : f32 = e_min;\n      let x_1693 : f32 = d22;\n      let x_1695 : vec3<f32> = V1;\n      V2_ = ((x_1690 * x_1689) + (x_1695 * (x_1692 - x_1693)));\n    }\n    let x_1699 : f32 = e_max;\n    a_1 = (1.0f / x_1699);\n    let x_1702 : f32 = e_min;\n    b_1 = (1.0f / x_1702);\n    let x_1704 : vec3<f32> = V1_;\n    V1 = normalize(x_1704);\n    let x_1706 : vec3<f32> = V2_;\n    V2 = normalize(x_1706);\n  } else {\n    let x_1709 : vec3<f32> = V1;\n    let x_1710 : vec3<f32> = V1;\n    a_1 = (1.0f / dot(x_1709, x_1710));\n    let x_1713 : vec3<f32> = V2;\n    let x_1714 : vec3<f32> = V2;\n    b_1 = (1.0f / dot(x_1713, x_1714));\n    let x_1717 : f32 = a_1;\n    let x_1719 : vec3<f32> = V1;\n    V1 = (x_1719 * sqrt(x_1717));\n    let x_1721 : f32 = b_1;\n    let x_1723 : vec3<f32> = V2;\n    V2 = (x_1723 * sqrt(x_1721));\n  }\n  let x_1726 : vec3<f32> = V1;\n  let x_1727 : vec3<f32> = V2;\n  V3 = cross(x_1726, x_1727);\n  let x_1729 : vec3<f32> = C_1;\n  let x_1730 : vec3<f32> = V3;\n  if ((dot(x_1729, x_1730) < 0.0f)) {\n    let x_1736 : vec3<f32> = V3;\n    V3 = (x_1736 * -1.0f);\n  }\n  let x_1739 : vec3<f32> = V3;\n  let x_1740 : vec3<f32> = C_1;\n  L = dot(x_1739, x_1740);\n  let x_1743 : vec3<f32> = V1;\n  let x_1744 : vec3<f32> = C_1;\n  let x_1746 : f32 = L;\n  x0 = (dot(x_1743, x_1744) / x_1746);\n  let x_1749 : vec3<f32> = V2;\n  let x_1750 : vec3<f32> = C_1;\n  let x_1752 : f32 = L;\n  y0 = (dot(x_1749, x_1750) / x_1752);\n  let x_1755 : f32 = a_1;\n  E1 = inverseSqrt(x_1755);\n  let x_1758 : f32 = b_1;\n  E2 = inverseSqrt(x_1758);\n  let x_1760 : f32 = L;\n  let x_1761 : f32 = L;\n  let x_1763 : f32 = a_1;\n  a_1 = (x_1763 * (x_1760 * x_1761));\n  let x_1765 : f32 = L;\n  let x_1766 : f32 = L;\n  let x_1768 : f32 = b_1;\n  b_1 = (x_1768 * (x_1765 * x_1766));\n  let x_1771 : f32 = a_1;\n  let x_1772 : f32 = b_1;\n  c0 = (x_1771 * x_1772);\n  let x_1775 : f32 = a_1;\n  let x_1776 : f32 = b_1;\n  let x_1778 : f32 = x0;\n  let x_1779 : f32 = x0;\n  let x_1782 : f32 = y0;\n  let x_1783 : f32 = y0;\n  let x_1787 : f32 = a_1;\n  let x_1789 : f32 = b_1;\n  c1 = ((((x_1775 * x_1776) * ((1.0f + (x_1778 * x_1779)) + (x_1782 * x_1783))) - x_1787) - x_1789);\n  let x_1792 : f32 = a_1;\n  let x_1793 : f32 = x0;\n  let x_1794 : f32 = x0;\n  let x_1799 : f32 = b_1;\n  let x_1800 : f32 = y0;\n  let x_1801 : f32 = y0;\n  c2 = ((1.0f - (x_1792 * (1.0f + (x_1793 * x_1794)))) - (x_1799 * (1.0f + (x_1800 * x_1801))));\n  c3 = 1.0f;\n  let x_1808 : f32 = c0;\n  let x_1809 : f32 = c1;\n  let x_1810 : f32 = c2;\n  let x_1811 : f32 = c3;\n  param_30 = vec4<f32>(x_1808, x_1809, x_1810, x_1811);\n  let x_1814 : vec3<f32> = SolveCubic_vf4_(&(param_30));\n  roots = x_1814;\n  let x_1817 : f32 = roots.x;\n  e1 = x_1817;\n  let x_1820 : f32 = roots.y;\n  e2 = x_1820;\n  let x_1823 : f32 = roots.z;\n  e3 = x_1823;\n  let x_1825 : f32 = a_1;\n  let x_1826 : f32 = x0;\n  let x_1828 : f32 = a_1;\n  let x_1829 : f32 = e2;\n  let x_1832 : f32 = b_1;\n  let x_1833 : f32 = y0;\n  let x_1835 : f32 = b_1;\n  let x_1836 : f32 = e2;\n  avgDir = vec3<f32>(((x_1825 * x_1826) / (x_1828 - x_1829)), ((x_1832 * x_1833) / (x_1835 - x_1836)), 1.0f);\n  let x_1841 : vec3<f32> = V1;\n  let x_1842 : vec3<f32> = V2;\n  let x_1843 : vec3<f32> = V3;\n  rotate = mat3x3<f32>(vec3<f32>(x_1841.x, x_1841.y, x_1841.z), vec3<f32>(x_1842.x, x_1842.y, x_1842.z), vec3<f32>(x_1843.x, x_1843.y, x_1843.z));\n  let x_1857 : mat3x3<f32> = rotate;\n  let x_1858 : vec3<f32> = avgDir;\n  avgDir = (x_1857 * x_1858);\n  let x_1860 : vec3<f32> = avgDir;\n  avgDir = normalize(x_1860);\n  let x_1863 : f32 = e2;\n  let x_1865 : f32 = e3;\n  L1 = sqrt((-(x_1863) / x_1865));\n  let x_1869 : f32 = e2;\n  let x_1871 : f32 = e1;\n  L2 = sqrt((-(x_1869) / x_1871));\n  let x_1875 : f32 = L1;\n  let x_1876 : f32 = L2;\n  let x_1878 : f32 = L1;\n  let x_1879 : f32 = L1;\n  let x_1882 : f32 = L2;\n  let x_1883 : f32 = L2;\n  formFactor = ((x_1875 * x_1876) * inverseSqrt(((1.0f + (x_1878 * x_1879)) * (1.0f + (x_1882 * x_1883)))));\n  let x_1891 : f32 = avgDir.z;\n  let x_1894 : f32 = formFactor;\n  uv_6 = vec2<f32>(((x_1891 * 0.5f) + 0.5f), x_1894);\n  let x_1896 : vec2<f32> = uv_6;\n  uv_6 = ((x_1896 * 0.984375f) + vec2<f32>(0.0078125f, 0.0078125f));\n  let x_1904 : vec2<f32> = uv_6;\n  let x_1905 : vec4<f32> = textureSampleLevel(areaLightsLutTex2, areaLightsLutTex2_sampler, x_1904, 0.0f);\n  scale = x_1905.w;\n  let x_1907 : f32 = formFactor;\n  let x_1908 : f32 = scale;\n  return (x_1907 * x_1908);\n}\n\nfn getDiskLightDiffuse_vf3_vf3_vf3_vf3_(worldNormal_5 : ptr<function, vec3<f32>>, viewDir_5 : ptr<function, vec3<f32>>, lightDir_5 : ptr<function, vec3<f32>>, lightDirNorm_3 : ptr<function, vec3<f32>>) -> f32 {\n  var param_31 : vec3<f32>;\n  var param_32 : vec3<f32>;\n  var param_33 : vec3<f32>;\n  var param_34 : mat3x3<f32>;\n  var param_35 : Coords;\n  let x_1923 : vec3<f32> = *(worldNormal_5);\n  param_31 = x_1923;\n  let x_1925 : vec3<f32> = *(viewDir_5);\n  param_32 = x_1925;\n  let x_1927 : vec3<f32> = vPositionW;\n  param_33 = x_1927;\n  param_34 = mat3x3<f32>(vec3<f32>(1.0f, 0.0f, 0.0f), vec3<f32>(0.0f, 1.0f, 0.0f), vec3<f32>(0.0f, 0.0f, 1.0f));\n  let x_1930 : Coords = dLTCCoords;\n  param_35 = x_1930;\n  let x_1931 : f32 = LTC_EvaluateDisk_vf3_vf3_vf3_mf33_struct_Coords_vf3_vf3_vf3_vf31_(&(param_31), &(param_32), &(param_33), &(param_34), &(param_35));\n  return x_1931;\n}\n\nfn getLightDiffuse_vf3_vf3_vf3_vf3_(worldNormal_1 : ptr<function, vec3<f32>>, viewDir_1 : ptr<function, vec3<f32>>, lightDir_3 : ptr<function, vec3<f32>>, lightDirNorm_1 : ptr<function, vec3<f32>>) -> f32 {\n  let x_830 : vec3<f32> = *(worldNormal_1);\n  let x_831 : vec3<f32> = *(lightDirNorm_1);\n  return max(dot(x_830, -(x_831)), 0.0f);\n}\n\nfn getSphereLightDiffuse_vf3_vf3_vf3_vf3_(worldNormal_6 : ptr<function, vec3<f32>>, viewDir_6 : ptr<function, vec3<f32>>, lightDir_6 : ptr<function, vec3<f32>>, lightDirNorm_4 : ptr<function, vec3<f32>>) -> f32 {\n  var falloff_1 : f32;\n  var param_36 : vec3<f32>;\n  var param_37 : vec3<f32>;\n  var param_38 : vec3<f32>;\n  var param_39 : vec3<f32>;\n  let x_1935 : f32 = dSphereRadius;\n  let x_1936 : vec3<f32> = *(lightDir_6);\n  let x_1937 : vec3<f32> = *(lightDir_6);\n  let x_1939 : f32 = dSphereRadius;\n  falloff_1 = (x_1935 / (dot(x_1936, x_1937) + x_1939));\n  let x_1943 : vec3<f32> = *(worldNormal_6);\n  param_36 = x_1943;\n  let x_1945 : vec3<f32> = *(viewDir_6);\n  param_37 = x_1945;\n  let x_1947 : vec3<f32> = *(lightDir_6);\n  param_38 = x_1947;\n  let x_1949 : vec3<f32> = *(lightDirNorm_4);\n  param_39 = x_1949;\n  let x_1950 : f32 = getLightDiffuse_vf3_vf3_vf3_vf3_(&(param_36), &(param_37), &(param_38), &(param_39));\n  let x_1951 : f32 = falloff_1;\n  return (x_1950 * x_1951);\n}\n\nfn decodeClusterLightSpot_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_(clusterLightData_3 : ptr<function, ClusterLightData>) {\n  var coneAngle : vec4<f32>;\n  var param_67 : i32;\n  var param_68 : vec2<f32>;\n  var param_69 : vec2<f32>;\n  let x_2207 : ClusterLightData = *(clusterLightData_3);\n  param_67 = 3i;\n  let x_2209 : vec4<f32> = sampleLightsTexture8_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_i1_(x_2207, &(param_67));\n  coneAngle = x_2209;\n  let x_2212 : vec4<f32> = coneAngle;\n  param_68 = vec2<f32>(x_2212.x, x_2212.y);\n  let x_2214 : f32 = bytes2float2_vf2_(&(param_68));\n  (*(clusterLightData_3)).innerConeAngleCos = ((x_2214 * 2.0f) - 1.0f);\n  let x_2220 : vec4<f32> = coneAngle;\n  param_69 = vec2<f32>(x_2220.z, x_2220.w);\n  let x_2222 : f32 = bytes2float2_vf2_(&(param_69));\n  (*(clusterLightData_3)).outerConeAngleCos = ((x_2222 * 2.0f) - 1.0f);\n  return;\n}\n\nfn getSpotEffect_vf3_f1_f1_vf3_(lightSpotDirW : ptr<function, vec3<f32>>, lightInnerConeAngle : ptr<function, f32>, lightOuterConeAngle : ptr<function, f32>, lightDirNorm : ptr<function, vec3<f32>>) -> f32 {\n  var cosAngle : f32;\n  let x_384 : vec3<f32> = *(lightDirNorm);\n  let x_385 : vec3<f32> = *(lightSpotDirW);\n  cosAngle = dot(x_384, x_385);\n  let x_387 : f32 = *(lightOuterConeAngle);\n  let x_388 : f32 = *(lightInnerConeAngle);\n  let x_389 : f32 = cosAngle;\n  return smoothstep(x_387, x_388, x_389);\n}\n\nfn getLTCLightInvMat_vf2_(uv_1 : ptr<function, vec2<f32>>) -> mat3x3<f32> {\n  var t1 : vec4<f32>;\n  let x_1961 : vec2<f32> = *(uv_1);\n  let x_1962 : vec4<f32> = textureSampleLevel(areaLightsLutTex1, areaLightsLutTex1_sampler, x_1961, 0.0f);\n  t1 = x_1962;\n  let x_1967 : vec4<f32> = t1;\n  t1 = (x_1967 * vec4<f32>(1.001000047f, 0.323900014f, 0.60437566f, 1.0f));\n  let x_1972 : vec4<f32> = t1;\n  t1 = (x_1972 + vec4<f32>(0.0f, -0.297600001f, -0.01381f, 0.0f));\n  let x_1975 : f32 = t1.x;\n  let x_1977 : f32 = t1.y;\n  let x_1978 : vec3<f32> = vec3<f32>(x_1975, 0.0f, x_1977);\n  let x_1980 : f32 = t1.z;\n  let x_1982 : f32 = t1.w;\n  let x_1983 : vec3<f32> = vec3<f32>(x_1980, 0.0f, x_1982);\n  return mat3x3<f32>(vec3<f32>(x_1978.x, x_1978.y, x_1978.z), vec3<f32>(vec3<f32>(0.0f, 1.0f, 0.0f).x, vec3<f32>(0.0f, 1.0f, 0.0f).y, vec3<f32>(0.0f, 1.0f, 0.0f).z), vec3<f32>(x_1983.x, x_1983.y, x_1983.z));\n}\n\nfn calcRectLightSpecular_vf3_vf3_vf2_(worldNormal_7 : ptr<function, vec3<f32>>, viewDir_7 : ptr<function, vec3<f32>>, uv_2 : ptr<function, vec2<f32>>) -> f32 {\n  var mInv_1 : mat3x3<f32>;\n  var param_40 : vec2<f32>;\n  let x_2001 : vec2<f32> = *(uv_2);\n  param_40 = x_2001;\n  let x_2002 : mat3x3<f32> = getLTCLightInvMat_vf2_(&(param_40));\n  mInv_1 = x_2002;\n  let x_2003 : vec3<f32> = *(worldNormal_7);\n  let x_2004 : vec3<f32> = *(viewDir_7);\n  let x_2005 : vec3<f32> = vPositionW;\n  let x_2006 : mat3x3<f32> = mInv_1;\n  let x_2007 : Coords = dLTCCoords;\n  let x_2008 : f32 = LTC_EvaluateRect_vf3_vf3_vf3_mf33_struct_Coords_vf3_vf3_vf3_vf31_(x_2003, x_2004, x_2005, x_2006, x_2007);\n  return x_2008;\n}\n\nfn getRectLightSpecular_vf3_vf3_(worldNormal_8 : ptr<function, vec3<f32>>, viewDir_8 : ptr<function, vec3<f32>>) -> f32 {\n  var param_41 : vec3<f32>;\n  var param_42 : vec3<f32>;\n  var param_43 : vec2<f32>;\n  let x_2012 : vec3<f32> = *(worldNormal_8);\n  param_41 = x_2012;\n  let x_2014 : vec3<f32> = *(viewDir_8);\n  param_42 = x_2014;\n  let x_2016 : vec2<f32> = dLTCUV;\n  param_43 = x_2016;\n  let x_2017 : f32 = calcRectLightSpecular_vf3_vf3_vf2_(&(param_41), &(param_42), &(param_43));\n  return x_2017;\n}\n\nfn calcDiskLightSpecular_vf3_vf3_vf2_(worldNormal_9 : ptr<function, vec3<f32>>, viewDir_9 : ptr<function, vec3<f32>>, uv_3 : ptr<function, vec2<f32>>) -> f32 {\n  var mInv_2 : mat3x3<f32>;\n  var param_44 : vec2<f32>;\n  var param_45 : vec3<f32>;\n  var param_46 : vec3<f32>;\n  var param_47 : vec3<f32>;\n  var param_48 : mat3x3<f32>;\n  var param_49 : Coords;\n  let x_2022 : vec2<f32> = *(uv_3);\n  param_44 = x_2022;\n  let x_2023 : mat3x3<f32> = getLTCLightInvMat_vf2_(&(param_44));\n  mInv_2 = x_2023;\n  let x_2025 : vec3<f32> = *(worldNormal_9);\n  param_45 = x_2025;\n  let x_2027 : vec3<f32> = *(viewDir_9);\n  param_46 = x_2027;\n  let x_2029 : vec3<f32> = vPositionW;\n  param_47 = x_2029;\n  let x_2031 : mat3x3<f32> = mInv_2;\n  param_48 = x_2031;\n  let x_2033 : Coords = dLTCCoords;\n  param_49 = x_2033;\n  let x_2034 : f32 = LTC_EvaluateDisk_vf3_vf3_vf3_mf33_struct_Coords_vf3_vf3_vf3_vf31_(&(param_45), &(param_46), &(param_47), &(param_48), &(param_49));\n  return x_2034;\n}\n\nfn getDiskLightSpecular_vf3_vf3_(worldNormal_10 : ptr<function, vec3<f32>>, viewDir_10 : ptr<function, vec3<f32>>) -> f32 {\n  var param_50 : vec3<f32>;\n  var param_51 : vec3<f32>;\n  var param_52 : vec2<f32>;\n  let x_2038 : vec3<f32> = *(worldNormal_10);\n  param_50 = x_2038;\n  let x_2040 : vec3<f32> = *(viewDir_10);\n  param_51 = x_2040;\n  let x_2042 : vec2<f32> = dLTCUV;\n  param_52 = x_2042;\n  let x_2043 : f32 = calcDiskLightSpecular_vf3_vf3_vf2_(&(param_50), &(param_51), &(param_52));\n  return x_2043;\n}\n\nfn getSphereLightSpecular_vf3_vf3_(worldNormal_11 : ptr<function, vec3<f32>>, viewDir_11 : ptr<function, vec3<f32>>) -> f32 {\n  var param_53 : vec3<f32>;\n  var param_54 : vec3<f32>;\n  var param_55 : vec2<f32>;\n  let x_2047 : vec3<f32> = *(worldNormal_11);\n  param_53 = x_2047;\n  let x_2049 : vec3<f32> = *(viewDir_11);\n  param_54 = x_2049;\n  let x_2051 : vec2<f32> = dLTCUV;\n  param_55 = x_2051;\n  let x_2052 : f32 = calcDiskLightSpecular_vf3_vf3_vf2_(&(param_53), &(param_54), &(param_55));\n  return x_2052;\n}\n\nfn calcLightSpecular_f1_vf3_vf3_(gloss_4 : ptr<function, f32>, worldNormal_12 : ptr<function, vec3<f32>>, h : ptr<function, vec3<f32>>) -> f32 {\n  var nh : f32;\n  var specPow : f32;\n  let x_2056 : vec3<f32> = *(h);\n  let x_2057 : vec3<f32> = *(worldNormal_12);\n  nh = max(dot(x_2056, x_2057), 0.0f);\n  let x_2061 : f32 = *(gloss_4);\n  specPow = exp2((x_2061 * 11.0f));\n  let x_2065 : f32 = specPow;\n  specPow = max(x_2065, 0.0001f);\n  let x_2067 : f32 = nh;\n  let x_2068 : f32 = specPow;\n  let x_2070 : f32 = specPow;\n  return ((pow(x_2067, x_2068) * (x_2070 + 2.0f)) / 8.0f);\n}\n\nfn getLightSpecular_vf3_vf3_vf3_vf3_vf3_f1_mf33_(h_1 : ptr<function, vec3<f32>>, reflDir : ptr<function, vec3<f32>>, worldNormal_13 : ptr<function, vec3<f32>>, viewDir_12 : ptr<function, vec3<f32>>, lightDirNorm_5 : ptr<function, vec3<f32>>, gloss_5 : ptr<function, f32>, tbn : ptr<function, mat3x3<f32>>) -> f32 {\n  var param_56 : f32;\n  var param_57 : vec3<f32>;\n  var param_58 : vec3<f32>;\n  let x_2078 : f32 = *(gloss_5);\n  param_56 = x_2078;\n  let x_2080 : vec3<f32> = *(worldNormal_13);\n  param_57 = x_2080;\n  let x_2082 : vec3<f32> = *(h_1);\n  param_58 = x_2082;\n  let x_2083 : f32 = calcLightSpecular_f1_vf3_vf3_(&(param_56), &(param_57), &(param_58));\n  return x_2083;\n}\n\nfn getFresnel_f1_f1_vf3_(cosTheta : ptr<function, f32>, gloss : ptr<function, f32>, specularity : ptr<function, vec3<f32>>) -> vec3<f32> {\n  var fresnel : f32;\n  var glossSq : f32;\n  var ret : vec3<f32>;\n  let x_794 : f32 = *(cosTheta);\n  fresnel = pow((1.0f - max(x_794, 0.0f)), 5.0f);\n  let x_800 : f32 = *(gloss);\n  let x_801 : f32 = *(gloss);\n  glossSq = (x_800 * x_801);\n  let x_804 : vec3<f32> = *(specularity);\n  let x_805 : f32 = glossSq;\n  let x_807 : vec3<f32> = *(specularity);\n  let x_809 : vec3<f32> = *(specularity);\n  let x_811 : f32 = fresnel;\n  ret = (x_804 + ((max(vec3<f32>(x_805, x_805, x_805), x_807) - x_809) * x_811));\n  let x_814 : vec3<f32> = ret;\n  return x_814;\n}\n\nfn evaluateLight_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_vf3_vf3_vf3_f1_vf3_vf3_mf33_struct_ClearcoatArgs_f1_f1_vf31_struct_SheenArgs_f1_vf31_struct_IridescenceArgs_f1_f11_(light : ptr<function, ClusterLightData>, worldNormal_16 : ptr<function, vec3<f32>>, viewDir_14 : ptr<function, vec3<f32>>, reflectionDir : ptr<function, vec3<f32>>, gloss_7 : ptr<function, f32>, specularity_3 : ptr<function, vec3<f32>>, geometricNormal : ptr<function, vec3<f32>>, tbn_2 : ptr<function, mat3x3<f32>>, clearcoat : ptr<function, ClearcoatArgs>, sheen : ptr<function, SheenArgs>, iridescence : ptr<function, IridescenceArgs>) {\n  var cookieAttenuation : vec3<f32>;\n  var diffuseAttenuation : f32;\n  var falloffAttenuation : f32;\n  var param_72 : vec3<f32>;\n  var param_73 : ClusterLightData;\n  var param_74 : vec3<f32>;\n  var param_75 : vec3<f32>;\n  var param_76 : vec3<f32>;\n  var param_77 : vec3<f32>;\n  var param_78 : vec3<f32>;\n  var param_79 : vec3<f32>;\n  var param_80 : vec3<f32>;\n  var param_81 : vec3<f32>;\n  var param_82 : vec3<f32>;\n  var param_83 : f32;\n  var param_84 : vec3<f32>;\n  var param_85 : f32;\n  var param_86 : vec3<f32>;\n  var param_87 : f32;\n  var param_88 : vec3<f32>;\n  var param_89 : vec3<f32>;\n  var param_90 : vec3<f32>;\n  var param_91 : vec3<f32>;\n  var param_92 : vec3<f32>;\n  var param_93 : vec3<f32>;\n  var param_94 : vec3<f32>;\n  var param_95 : vec3<f32>;\n  var param_96 : vec3<f32>;\n  var param_97 : vec3<f32>;\n  var param_98 : vec3<f32>;\n  var param_99 : vec3<f32>;\n  var param_100 : vec3<f32>;\n  var param_101 : vec3<f32>;\n  var param_102 : vec3<f32>;\n  var param_103 : vec3<f32>;\n  var param_104 : vec3<f32>;\n  var param_105 : ClusterLightData;\n  var param_106 : vec3<f32>;\n  var param_107 : f32;\n  var param_108 : f32;\n  var param_109 : vec3<f32>;\n  var areaDiffuse : vec3<f32>;\n  var areaLightSpecular : f32;\n  var param_110 : vec3<f32>;\n  var param_111 : vec3<f32>;\n  var param_112 : vec3<f32>;\n  var param_113 : vec3<f32>;\n  var param_114 : vec3<f32>;\n  var param_115 : vec3<f32>;\n  var punctualDiffuse : vec3<f32>;\n  var halfDir : vec3<f32>;\n  var param_116 : vec3<f32>;\n  var param_117 : vec3<f32>;\n  var param_118 : vec3<f32>;\n  var param_119 : vec3<f32>;\n  var param_120 : vec3<f32>;\n  var param_121 : f32;\n  var param_122 : mat3x3<f32>;\n  var param_123 : f32;\n  var param_124 : f32;\n  var param_125 : vec3<f32>;\n  cookieAttenuation = vec3<f32>(1.0f, 1.0f, 1.0f);\n  diffuseAttenuation = 1.0f;\n  falloffAttenuation = 1.0f;\n  let x_2241 : vec3<f32> = (*(light)).position;\n  param_72 = x_2241;\n  getLightDirPoint_vf3_(&(param_72));\n  let x_2244 : f32 = (*(light)).shape;\n  if ((x_2244 > 0.100000001f)) {\n    let x_2250 : ClusterLightData = *(light);\n    param_73 = x_2250;\n    decodeClusterLightAreaData_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_(&(param_73));\n    let x_2252 : ClusterLightData = param_73;\n    *(light) = x_2252;\n    let x_2254 : f32 = (*(light)).shape;\n    if ((x_2254 < 0.300000012f)) {\n      let x_2261 : vec3<f32> = (*(light)).position;\n      param_74 = x_2261;\n      let x_2264 : vec3<f32> = (*(light)).halfWidth;\n      param_75 = x_2264;\n      let x_2267 : vec3<f32> = (*(light)).halfHeight;\n      param_76 = x_2267;\n      calcRectLightValues_vf3_vf3_vf3_(&(param_74), &(param_75), &(param_76));\n    } else {\n      let x_2271 : f32 = (*(light)).shape;\n      if ((x_2271 < 0.600000024f)) {\n        let x_2278 : vec3<f32> = (*(light)).position;\n        param_77 = x_2278;\n        let x_2281 : vec3<f32> = (*(light)).halfWidth;\n        param_78 = x_2281;\n        let x_2284 : vec3<f32> = (*(light)).halfHeight;\n        param_79 = x_2284;\n        calcDiskLightValues_vf3_vf3_vf3_(&(param_77), &(param_78), &(param_79));\n      } else {\n        let x_2289 : vec3<f32> = (*(light)).position;\n        param_80 = x_2289;\n        let x_2292 : vec3<f32> = (*(light)).halfWidth;\n        param_81 = x_2292;\n        let x_2295 : vec3<f32> = (*(light)).halfHeight;\n        param_82 = x_2295;\n        calcSphereLightValues_vf3_vf3_vf3_(&(param_80), &(param_81), &(param_82));\n      }\n    }\n    let x_2299 : f32 = (*(light)).range;\n    param_83 = x_2299;\n    let x_2301 : vec3<f32> = dLightDirW;\n    param_84 = x_2301;\n    let x_2302 : f32 = getFalloffWindow_f1_vf3_(&(param_83), &(param_84));\n    falloffAttenuation = x_2302;\n  } else {\n    let x_2305 : f32 = (*(light)).falloffMode;\n    if ((x_2305 < 0.5f)) {\n      let x_2311 : f32 = (*(light)).range;\n      param_85 = x_2311;\n      let x_2313 : vec3<f32> = dLightDirW;\n      param_86 = x_2313;\n      let x_2314 : f32 = getFalloffLinear_f1_vf3_(&(param_85), &(param_86));\n      falloffAttenuation = x_2314;\n    } else {\n      let x_2318 : f32 = (*(light)).range;\n      param_87 = x_2318;\n      let x_2320 : vec3<f32> = dLightDirW;\n      param_88 = x_2320;\n      let x_2321 : f32 = getFalloffInvSquared_f1_vf3_(&(param_87), &(param_88));\n      falloffAttenuation = x_2321;\n    }\n  }\n  let x_2322 : f32 = falloffAttenuation;\n  if ((x_2322 > 0.00001f)) {\n    let x_2328 : f32 = (*(light)).shape;\n    if ((x_2328 > 0.100000001f)) {\n      let x_2333 : f32 = (*(light)).shape;\n      if ((x_2333 < 0.300000012f)) {\n        let x_2338 : vec3<f32> = *(worldNormal_16);\n        param_89 = x_2338;\n        let x_2340 : vec3<f32> = *(viewDir_14);\n        param_90 = x_2340;\n        let x_2342 : vec3<f32> = dLightDirW;\n        param_91 = x_2342;\n        let x_2344 : vec3<f32> = dLightDirNormW;\n        param_92 = x_2344;\n        let x_2345 : f32 = getRectLightDiffuse_vf3_vf3_vf3_vf3_(&(param_89), &(param_90), &(param_91), &(param_92));\n        diffuseAttenuation = (x_2345 * 16.0f);\n      } else {\n        let x_2349 : f32 = (*(light)).shape;\n        if ((x_2349 < 0.600000024f)) {\n          let x_2354 : vec3<f32> = *(worldNormal_16);\n          param_93 = x_2354;\n          let x_2356 : vec3<f32> = *(viewDir_14);\n          param_94 = x_2356;\n          let x_2358 : vec3<f32> = dLightDirW;\n          param_95 = x_2358;\n          let x_2360 : vec3<f32> = dLightDirNormW;\n          param_96 = x_2360;\n          let x_2361 : f32 = getDiskLightDiffuse_vf3_vf3_vf3_vf3_(&(param_93), &(param_94), &(param_95), &(param_96));\n          diffuseAttenuation = (x_2361 * 16.0f);\n        } else {\n          let x_2365 : vec3<f32> = *(worldNormal_16);\n          param_97 = x_2365;\n          let x_2367 : vec3<f32> = *(viewDir_14);\n          param_98 = x_2367;\n          let x_2369 : vec3<f32> = dLightDirW;\n          param_99 = x_2369;\n          let x_2371 : vec3<f32> = dLightDirNormW;\n          param_100 = x_2371;\n          let x_2372 : f32 = getSphereLightDiffuse_vf3_vf3_vf3_vf3_(&(param_97), &(param_98), &(param_99), &(param_100));\n          diffuseAttenuation = (x_2372 * 16.0f);\n        }\n      }\n    } else {\n      let x_2376 : vec3<f32> = *(worldNormal_16);\n      param_101 = x_2376;\n      let x_2378 : vec3<f32> = *(viewDir_14);\n      param_102 = x_2378;\n      let x_2380 : vec3<f32> = dLightDirW;\n      param_103 = x_2380;\n      let x_2382 : vec3<f32> = dLightDirNormW;\n      param_104 = x_2382;\n      let x_2383 : f32 = getLightDiffuse_vf3_vf3_vf3_vf3_(&(param_101), &(param_102), &(param_103), &(param_104));\n      let x_2384 : f32 = falloffAttenuation;\n      falloffAttenuation = (x_2384 * x_2383);\n    }\n    let x_2387 : f32 = (*(light)).lightType;\n    if ((x_2387 > 0.5f)) {\n      let x_2392 : ClusterLightData = *(light);\n      param_105 = x_2392;\n      decodeClusterLightSpot_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_(&(param_105));\n      let x_2394 : ClusterLightData = param_105;\n      *(light) = x_2394;\n      let x_2397 : vec3<f32> = (*(light)).direction;\n      param_106 = x_2397;\n      let x_2400 : f32 = (*(light)).innerConeAngleCos;\n      param_107 = x_2400;\n      let x_2403 : f32 = (*(light)).outerConeAngleCos;\n      param_108 = x_2403;\n      let x_2405 : vec3<f32> = dLightDirNormW;\n      param_109 = x_2405;\n      let x_2406 : f32 = getSpotEffect_vf3_f1_f1_vf3_(&(param_106), &(param_107), &(param_108), &(param_109));\n      let x_2407 : f32 = falloffAttenuation;\n      falloffAttenuation = (x_2407 * x_2406);\n    }\n    let x_2410 : f32 = (*(light)).shape;\n    if ((x_2410 > 0.100000001f)) {\n      let x_2415 : f32 = diffuseAttenuation;\n      let x_2416 : f32 = falloffAttenuation;\n      let x_2419 : vec3<f32> = (*(light)).color;\n      let x_2421 : vec3<f32> = cookieAttenuation;\n      areaDiffuse = ((x_2419 * (x_2415 * x_2416)) * x_2421);\n      let x_2423 : vec3<f32> = areaDiffuse;\n      let x_2424 : vec3<f32> = dLTCSpecFres;\n      areaDiffuse = mix(x_2423, vec3<f32>(0.0f, 0.0f, 0.0f), x_2424);\n      let x_2426 : vec3<f32> = areaDiffuse;\n      let x_2427 : vec3<f32> = dDiffuseLight;\n      dDiffuseLight = (x_2427 + x_2426);\n      let x_2430 : f32 = (*(light)).shape;\n      if ((x_2430 < 0.300000012f)) {\n        let x_2436 : vec3<f32> = *(worldNormal_16);\n        param_110 = x_2436;\n        let x_2438 : vec3<f32> = *(viewDir_14);\n        param_111 = x_2438;\n        let x_2439 : f32 = getRectLightSpecular_vf3_vf3_(&(param_110), &(param_111));\n        areaLightSpecular = x_2439;\n      } else {\n        let x_2442 : f32 = (*(light)).shape;\n        if ((x_2442 < 0.600000024f)) {\n          let x_2447 : vec3<f32> = *(worldNormal_16);\n          param_112 = x_2447;\n          let x_2449 : vec3<f32> = *(viewDir_14);\n          param_113 = x_2449;\n          let x_2450 : f32 = getDiskLightSpecular_vf3_vf3_(&(param_112), &(param_113));\n          areaLightSpecular = x_2450;\n        } else {\n          let x_2453 : vec3<f32> = *(worldNormal_16);\n          param_114 = x_2453;\n          let x_2455 : vec3<f32> = *(viewDir_14);\n          param_115 = x_2455;\n          let x_2456 : f32 = getSphereLightSpecular_vf3_vf3_(&(param_114), &(param_115));\n          areaLightSpecular = x_2456;\n        }\n      }\n      let x_2457 : vec3<f32> = dLTCSpecFres;\n      let x_2458 : f32 = areaLightSpecular;\n      let x_2460 : f32 = falloffAttenuation;\n      let x_2463 : vec3<f32> = (*(light)).color;\n      let x_2465 : vec3<f32> = cookieAttenuation;\n      let x_2467 : vec3<f32> = dSpecularLight;\n      dSpecularLight = (x_2467 + ((((x_2457 * x_2458) * x_2460) * x_2463) * x_2465));\n    } else {\n      let x_2471 : f32 = falloffAttenuation;\n      let x_2473 : vec3<f32> = (*(light)).color;\n      let x_2475 : vec3<f32> = cookieAttenuation;\n      punctualDiffuse = ((x_2473 * x_2471) * x_2475);\n      let x_2477 : vec3<f32> = punctualDiffuse;\n      let x_2478 : vec3<f32> = *(specularity_3);\n      punctualDiffuse = mix(x_2477, vec3<f32>(0.0f, 0.0f, 0.0f), x_2478);\n      let x_2480 : vec3<f32> = punctualDiffuse;\n      let x_2481 : vec3<f32> = dDiffuseLight;\n      dDiffuseLight = (x_2481 + x_2480);\n      let x_2484 : vec3<f32> = dLightDirNormW;\n      let x_2486 : vec3<f32> = *(viewDir_14);\n      halfDir = normalize((-(x_2484) + x_2486));\n      let x_2490 : vec3<f32> = halfDir;\n      param_116 = x_2490;\n      let x_2492 : vec3<f32> = *(reflectionDir);\n      param_117 = x_2492;\n      let x_2494 : vec3<f32> = *(worldNormal_16);\n      param_118 = x_2494;\n      let x_2496 : vec3<f32> = *(viewDir_14);\n      param_119 = x_2496;\n      let x_2498 : vec3<f32> = dLightDirNormW;\n      param_120 = x_2498;\n      let x_2500 : f32 = *(gloss_7);\n      param_121 = x_2500;\n      let x_2502 : mat3x3<f32> = *(tbn_2);\n      param_122 = x_2502;\n      let x_2503 : f32 = getLightSpecular_vf3_vf3_vf3_vf3_vf3_f1_mf33_(&(param_116), &(param_117), &(param_118), &(param_119), &(param_120), &(param_121), &(param_122));\n      let x_2504 : f32 = falloffAttenuation;\n      let x_2507 : vec3<f32> = (*(light)).color;\n      let x_2509 : vec3<f32> = cookieAttenuation;\n      let x_2511 : vec3<f32> = *(viewDir_14);\n      let x_2512 : vec3<f32> = halfDir;\n      param_123 = dot(x_2511, x_2512);\n      let x_2516 : f32 = *(gloss_7);\n      param_124 = x_2516;\n      let x_2518 : vec3<f32> = *(specularity_3);\n      param_125 = x_2518;\n      let x_2519 : vec3<f32> = getFresnel_f1_f1_vf3_(&(param_123), &(param_124), &(param_125));\n      let x_2521 : vec3<f32> = dSpecularLight;\n      dSpecularLight = (x_2521 + (((x_2507 * (x_2503 * x_2504)) * x_2509) * x_2519));\n    }\n  }\n  return;\n}\n\nfn evaluateClusterLight_f1_vf3_vf3_vf3_f1_vf3_vf3_mf33_struct_ClearcoatArgs_f1_f1_vf31_struct_SheenArgs_f1_vf31_struct_IridescenceArgs_f1_f11_(lightIndex_1 : ptr<function, f32>, worldNormal_17 : ptr<function, vec3<f32>>, viewDir_15 : ptr<function, vec3<f32>>, reflectionDir_1 : ptr<function, vec3<f32>>, gloss_8 : ptr<function, f32>, specularity_4 : ptr<function, vec3<f32>>, geometricNormal_1 : ptr<function, vec3<f32>>, tbn_3 : ptr<function, mat3x3<f32>>, clearcoat_1 : ptr<function, ClearcoatArgs>, sheen_1 : ptr<function, SheenArgs>, iridescence_1 : ptr<function, IridescenceArgs>) {\n  var clusterLightData_5 : ClusterLightData;\n  var param_126 : ClusterLightData;\n  var param_127 : f32;\n  var param_128 : ClusterLightData;\n  var param_129 : vec3<f32>;\n  var param_130 : vec3<f32>;\n  var param_131 : vec3<f32>;\n  var param_132 : f32;\n  var param_133 : vec3<f32>;\n  var param_134 : vec3<f32>;\n  var param_135 : mat3x3<f32>;\n  var param_136 : ClearcoatArgs;\n  var param_137 : SheenArgs;\n  var param_138 : IridescenceArgs;\n  let x_2525 : ClusterLightData = clusterLightData_5;\n  param_126 = x_2525;\n  let x_2527 : f32 = *(lightIndex_1);\n  param_127 = x_2527;\n  decodeClusterLightCore_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_f1_(&(param_126), &(param_127));\n  let x_2529 : ClusterLightData = param_126;\n  clusterLightData_5 = x_2529;\n  let x_2531 : f32 = clusterLightData_5.mask;\n  if ((x_2531 < 0.75f)) {\n    let x_2537 : ClusterLightData = clusterLightData_5;\n    param_128 = x_2537;\n    let x_2539 : vec3<f32> = *(worldNormal_17);\n    param_129 = x_2539;\n    let x_2541 : vec3<f32> = *(viewDir_15);\n    param_130 = x_2541;\n    let x_2543 : vec3<f32> = *(reflectionDir_1);\n    param_131 = x_2543;\n    let x_2545 : f32 = *(gloss_8);\n    param_132 = x_2545;\n    let x_2547 : vec3<f32> = *(specularity_4);\n    param_133 = x_2547;\n    let x_2549 : vec3<f32> = *(geometricNormal_1);\n    param_134 = x_2549;\n    let x_2551 : mat3x3<f32> = *(tbn_3);\n    param_135 = x_2551;\n    let x_2553 : ClearcoatArgs = *(clearcoat_1);\n    param_136 = x_2553;\n    let x_2555 : SheenArgs = *(sheen_1);\n    param_137 = x_2555;\n    let x_2557 : IridescenceArgs = *(iridescence_1);\n    param_138 = x_2557;\n    evaluateLight_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_vf3_vf3_vf3_f1_vf3_vf3_mf33_struct_ClearcoatArgs_f1_f1_vf31_struct_SheenArgs_f1_vf31_struct_IridescenceArgs_f1_f11_(&(param_128), &(param_129), &(param_130), &(param_131), &(param_132), &(param_133), &(param_134), &(param_135), &(param_136), &(param_137), &(param_138));\n  }\n  return;\n}\n\nfn addClusteredLights_vf3_vf3_vf3_f1_vf3_vf3_mf33_struct_ClearcoatArgs_f1_f1_vf31_struct_SheenArgs_f1_vf31_struct_IridescenceArgs_f1_f11_(worldNormal_18 : ptr<function, vec3<f32>>, viewDir_16 : ptr<function, vec3<f32>>, reflectionDir_2 : ptr<function, vec3<f32>>, gloss_9 : ptr<function, f32>, specularity_5 : ptr<function, vec3<f32>>, geometricNormal_2 : ptr<function, vec3<f32>>, tbn_4 : ptr<function, mat3x3<f32>>, clearcoat_2 : ptr<function, ClearcoatArgs>, sheen_2 : ptr<function, SheenArgs>, iridescence_2 : ptr<function, IridescenceArgs>) {\n  var cellCoords : vec3<f32>;\n  var cellIndex : f32;\n  var clusterV : f32;\n  var clusterU : f32;\n  var lightCellIndex : i32;\n  var lightIndex_2 : f32;\n  var param_139 : f32;\n  var param_140 : vec3<f32>;\n  var param_141 : vec3<f32>;\n  var param_142 : vec3<f32>;\n  var param_143 : f32;\n  var param_144 : vec3<f32>;\n  var param_145 : vec3<f32>;\n  var param_146 : mat3x3<f32>;\n  var param_147 : ClearcoatArgs;\n  var param_148 : SheenArgs;\n  var param_149 : IridescenceArgs;\n  var x_2588 : bool;\n  var x_2589 : bool;\n  let x_2561 : f32 = x_534.clusterSkip;\n  if ((x_2561 > 0.5f)) {\n    return;\n  }\n  let x_2567 : vec3<f32> = vPositionW;\n  let x_2569 : vec3<f32> = x_534.clusterBoundsMin;\n  let x_2573 : vec3<f32> = x_534.clusterCellsCountByBoundsSize;\n  cellCoords = floor(((x_2567 - x_2569) * x_2573));\n  let x_2576 : vec3<f32> = cellCoords;\n  let x_2579 : bool = any((x_2576 < vec3<f32>(0.0f, 0.0f, 0.0f)));\n  x_2589 = x_2579;\n  if (!(x_2579)) {\n    let x_2583 : vec3<f32> = cellCoords;\n    let x_2586 : vec3<f32> = x_534.clusterCellsMax;\n    x_2588 = any((x_2583 >= x_2586));\n    x_2589 = x_2588;\n  }\n  if (!(x_2589)) {\n    let x_2596 : vec3<f32> = x_534.clusterCellsDot;\n    let x_2597 : vec3<f32> = cellCoords;\n    cellIndex = dot(x_2596, x_2597);\n    let x_2600 : f32 = cellIndex;\n    let x_2602 : f32 = x_534.clusterTextureSize.y;\n    clusterV = floor((x_2600 * x_2602));\n    let x_2606 : f32 = cellIndex;\n    let x_2607 : f32 = clusterV;\n    let x_2609 : f32 = x_534.clusterTextureSize.x;\n    clusterU = (x_2606 - (x_2607 * x_2609));\n    lightCellIndex = 0i;\n    loop {\n      let x_2618 : i32 = lightCellIndex;\n      let x_2622 : i32 = x_534.clusterMaxCells;\n      if ((x_2618 < x_2622)) {\n      } else {\n        break;\n      }\n      let x_2627 : f32 = clusterU;\n      let x_2629 : i32 = lightCellIndex;\n      let x_2631 : f32 = clusterV;\n      let x_2634 : vec4<f32> = textureLoad(clusterWorldTexture, vec2<i32>((i32(x_2627) + x_2629), i32(x_2631)), 0i);\n      lightIndex_2 = x_2634.x;\n      let x_2636 : f32 = lightIndex_2;\n      if ((x_2636 <= 0.0f)) {\n        return;\n      }\n      let x_2641 : f32 = lightIndex_2;\n      param_139 = (x_2641 * 255.0f);\n      let x_2646 : vec3<f32> = *(worldNormal_18);\n      param_140 = x_2646;\n      let x_2648 : vec3<f32> = *(viewDir_16);\n      param_141 = x_2648;\n      let x_2650 : vec3<f32> = *(reflectionDir_2);\n      param_142 = x_2650;\n      let x_2652 : f32 = *(gloss_9);\n      param_143 = x_2652;\n      let x_2654 : vec3<f32> = *(specularity_5);\n      param_144 = x_2654;\n      let x_2656 : vec3<f32> = *(geometricNormal_2);\n      param_145 = x_2656;\n      let x_2658 : mat3x3<f32> = *(tbn_4);\n      param_146 = x_2658;\n      let x_2660 : ClearcoatArgs = *(clearcoat_2);\n      param_147 = x_2660;\n      let x_2662 : SheenArgs = *(sheen_2);\n      param_148 = x_2662;\n      let x_2664 : IridescenceArgs = *(iridescence_2);\n      param_149 = x_2664;\n      evaluateClusterLight_f1_vf3_vf3_vf3_f1_vf3_vf3_mf33_struct_ClearcoatArgs_f1_f1_vf31_struct_SheenArgs_f1_vf31_struct_IridescenceArgs_f1_f11_(&(param_139), &(param_140), &(param_141), &(param_142), &(param_143), &(param_144), &(param_145), &(param_146), &(param_147), &(param_148), &(param_149));\n\n      continuing {\n        let x_2666 : i32 = lightCellIndex;\n        lightCellIndex = (x_2666 + 1i);\n      }\n    }\n  }\n  return;\n}\n\nfn occludeSpecular_f1_f1_vf3_vf3_(gloss_1 : ptr<function, f32>, ao_1 : ptr<function, f32>, worldNormal : ptr<function, vec3<f32>>, viewDir : ptr<function, vec3<f32>>) {\n  let x_822 : f32 = *(ao_1);\n  let x_823 : vec3<f32> = dSpecularLight;\n  dSpecularLight = (x_823 * x_822);\n  let x_827 : f32 = *(ao_1);\n  let x_828 : vec4<f32> = dReflection;\n  dReflection = (x_828 * x_827);\n  return;\n}\n\nfn combineColor_vf3_vf3_f1_(albedo_1 : ptr<function, vec3<f32>>, sheenSpecularity : ptr<function, vec3<f32>>, clearcoatSpecularity_1 : ptr<function, f32>) -> vec3<f32> {\n  var ret_1 : vec3<f32>;\n  ret_1 = vec3<f32>(0.0f, 0.0f, 0.0f);\n  let x_2087 : vec3<f32> = *(albedo_1);\n  let x_2088 : vec3<f32> = dDiffuseLight;\n  let x_2090 : vec3<f32> = ret_1;\n  ret_1 = (x_2090 + (x_2087 * x_2088));\n  let x_2092 : vec3<f32> = dSpecularLight;\n  let x_2093 : vec3<f32> = ret_1;\n  ret_1 = (x_2093 + x_2092);\n  let x_2095 : vec3<f32> = ret_1;\n  return x_2095;\n}\n\nfn addFog_vf3_(color_2 : ptr<function, vec3<f32>>) -> vec3<f32> {\n  let x_620 : vec3<f32> = *(color_2);\n  return x_620;\n}\n\nfn toneMap_vf3_(color_1 : ptr<function, vec3<f32>>) -> vec3<f32> {\n  var tA : f32;\n  var tB : f32;\n  var tC : f32;\n  var tD : f32;\n  var tE : f32;\n  var x_2 : vec3<f32>;\n  tA = 2.50999999f;\n  tB = 0.029999999f;\n  tC = 2.430000067f;\n  tD = 0.589999974f;\n  tE = 0.140000001f;\n  let x_593 : vec3<f32> = *(color_1);\n  let x_596 : f32 = x_534.exposure;\n  x_2 = (x_593 * x_596);\n  let x_598 : vec3<f32> = x_2;\n  let x_599 : f32 = tA;\n  let x_600 : vec3<f32> = x_2;\n  let x_602 : f32 = tB;\n  let x_606 : vec3<f32> = x_2;\n  let x_607 : f32 = tC;\n  let x_608 : vec3<f32> = x_2;\n  let x_610 : f32 = tD;\n  let x_614 : f32 = tE;\n  return ((x_598 * ((x_600 * x_599) + vec3<f32>(x_602, x_602, x_602))) / ((x_606 * ((x_608 * x_607) + vec3<f32>(x_610, x_610, x_610))) + vec3<f32>(x_614, x_614, x_614)));\n}\n\nfn gammaCorrectOutput_vf3_(color : ptr<function, vec3<f32>>) -> vec3<f32> {\n  let x_573 : vec3<f32> = *(color);\n  return pow((x_573 + vec3<f32>(0.0000001f, 0.0000001f, 0.0000001f)), vec3<f32>(0.454545468f, 0.454545468f, 0.454545468f));\n}\n\nfn evaluateBackend_struct_LitShaderArguments_f1_vf3_vf3_f1_f1_vf3_f1_f1_f1_f1_vf3_vf3_vf3_struct_IridescenceArgs_f1_f11_struct_ClearcoatArgs_f1_f1_vf31_struct_SheenArgs_f1_vf311_(litShaderArgs_1 : ptr<function, LitShaderArguments>) {\n  var param_150 : vec3<f32>;\n  var param_151 : vec3<f32>;\n  var param_152 : f32;\n  var param_153 : mat3x3<f32>;\n  var param_154 : LitShaderArguments;\n  var param_155 : vec3<f32>;\n  var param_156 : f32;\n  var param_157 : f32;\n  var param_158 : vec3<f32>;\n  var param_159 : vec3<f32>;\n  var param_160 : vec3<f32>;\n  var param_161 : f32;\n  var param_162 : vec3<f32>;\n  var param_163 : f32;\n  var param_164 : vec3<f32>;\n  var param_165 : vec3<f32>;\n  var param_166 : vec3<f32>;\n  var param_167 : f32;\n  var param_168 : vec3<f32>;\n  var param_169 : vec3<f32>;\n  var param_170 : mat3x3<f32>;\n  var param_171 : ClearcoatArgs;\n  var param_172 : SheenArgs;\n  var param_173 : IridescenceArgs;\n  var param_174 : f32;\n  var param_175 : f32;\n  var param_176 : vec3<f32>;\n  var param_177 : vec3<f32>;\n  var param_178 : vec3<f32>;\n  var param_179 : vec3<f32>;\n  var param_180 : f32;\n  var param_181 : vec3<f32>;\n  var param_182 : vec3<f32>;\n  var param_183 : vec3<f32>;\n  let x_2670 : vec3<f32> = (*(litShaderArgs_1)).worldNormal;\n  param_150 = x_2670;\n  let x_2672 : vec3<f32> = dViewDirW;\n  param_151 = x_2672;\n  let x_2675 : f32 = (*(litShaderArgs_1)).gloss;\n  param_152 = x_2675;\n  let x_2677 : mat3x3<f32> = dTBN;\n  param_153 = x_2677;\n  getReflDir_vf3_vf3_f1_mf33_(&(param_150), &(param_151), &(param_152), &(param_153));\n  let x_2680 : LitShaderArguments = *(litShaderArgs_1);\n  param_154 = x_2680;\n  getMetalnessModulate_struct_LitShaderArguments_f1_vf3_vf3_f1_f1_vf3_f1_f1_f1_f1_vf3_vf3_vf3_struct_IridescenceArgs_f1_f11_struct_ClearcoatArgs_f1_f1_vf31_struct_SheenArgs_f1_vf311_(&(param_154));\n  let x_2682 : LitShaderArguments = param_154;\n  *(litShaderArgs_1) = x_2682;\n  let x_2685 : vec3<f32> = (*(litShaderArgs_1)).worldNormal;\n  param_155 = x_2685;\n  addAmbient_vf3_(&(param_155));\n  let x_2687 : vec3<f32> = dDiffuseLight;\n  let x_2689 : vec3<f32> = (*(litShaderArgs_1)).specularity;\n  dDiffuseLight = (x_2687 * (vec3<f32>(1.0f, 1.0f, 1.0f) - x_2689));\n  let x_2695 : f32 = (*(litShaderArgs_1)).ao;\n  param_156 = x_2695;\n  occludeDiffuse_f1_(&(param_156));\n  let x_2698 : vec3<f32> = (*(litShaderArgs_1)).specularity;\n  let x_2699 : vec3<f32> = dSpecularLight;\n  dSpecularLight = (x_2699 * x_2698);\n  let x_2703 : f32 = (*(litShaderArgs_1)).gloss;\n  param_157 = x_2703;\n  let x_2706 : vec3<f32> = (*(litShaderArgs_1)).worldNormal;\n  param_158 = x_2706;\n  let x_2708 : vec3<f32> = dViewDirW;\n  param_159 = x_2708;\n  let x_2711 : vec3<f32> = (*(litShaderArgs_1)).specularity;\n  param_160 = x_2711;\n  let x_2714 : f32 = (*(litShaderArgs_1)).clearcoat.gloss;\n  param_161 = x_2714;\n  let x_2717 : vec3<f32> = (*(litShaderArgs_1)).clearcoat.worldNormal;\n  param_162 = x_2717;\n  let x_2720 : f32 = (*(litShaderArgs_1)).clearcoat.specularity;\n  param_163 = x_2720;\n  calcLTCLightValues_f1_vf3_vf3_vf3_f1_vf3_f1_(&(param_157), &(param_158), &(param_159), &(param_160), &(param_161), &(param_162), &(param_163));\n  let x_2725 : vec3<f32> = (*(litShaderArgs_1)).worldNormal;\n  param_164 = x_2725;\n  let x_2727 : vec3<f32> = dViewDirW;\n  param_165 = x_2727;\n  let x_2729 : vec3<f32> = dReflDirW;\n  param_166 = x_2729;\n  let x_2732 : f32 = (*(litShaderArgs_1)).gloss;\n  param_167 = x_2732;\n  let x_2735 : vec3<f32> = (*(litShaderArgs_1)).specularity;\n  param_168 = x_2735;\n  let x_2737 : vec3<f32> = dVertexNormalW;\n  param_169 = x_2737;\n  let x_2739 : mat3x3<f32> = dTBN;\n  param_170 = x_2739;\n  let x_2742 : ClearcoatArgs = (*(litShaderArgs_1)).clearcoat;\n  param_171 = x_2742;\n  let x_2745 : SheenArgs = (*(litShaderArgs_1)).sheen;\n  param_172 = x_2745;\n  let x_2748 : IridescenceArgs = (*(litShaderArgs_1)).iridescence;\n  param_173 = x_2748;\n  addClusteredLights_vf3_vf3_vf3_f1_vf3_vf3_mf33_struct_ClearcoatArgs_f1_f1_vf31_struct_SheenArgs_f1_vf31_struct_IridescenceArgs_f1_f11_(&(param_164), &(param_165), &(param_166), &(param_167), &(param_168), &(param_169), &(param_170), &(param_171), &(param_172), &(param_173));\n  (*(litShaderArgs_1)).specularity = vec3<f32>(1.0f, 1.0f, 1.0f);\n  let x_2753 : f32 = (*(litShaderArgs_1)).gloss;\n  param_174 = x_2753;\n  let x_2756 : f32 = (*(litShaderArgs_1)).ao;\n  param_175 = x_2756;\n  let x_2759 : vec3<f32> = (*(litShaderArgs_1)).worldNormal;\n  param_176 = x_2759;\n  let x_2761 : vec3<f32> = dViewDirW;\n  param_177 = x_2761;\n  occludeSpecular_f1_f1_vf3_vf3_(&(param_174), &(param_175), &(param_176), &(param_177));\n  let x_2767 : vec3<f32> = (*(litShaderArgs_1)).albedo;\n  param_178 = x_2767;\n  let x_2770 : vec3<f32> = (*(litShaderArgs_1)).sheen.specularity;\n  param_179 = x_2770;\n  let x_2773 : f32 = (*(litShaderArgs_1)).clearcoat.specularity;\n  param_180 = x_2773;\n  let x_2774 : vec3<f32> = combineColor_vf3_vf3_f1_(&(param_178), &(param_179), &(param_180));\n  let x_2775 : vec4<f32> = pc_fragColor;\n  pc_fragColor = vec4<f32>(x_2774.x, x_2774.y, x_2774.z, x_2775.w);\n  let x_2778 : vec3<f32> = (*(litShaderArgs_1)).emission;\n  let x_2779 : vec4<f32> = pc_fragColor;\n  let x_2781 : vec3<f32> = (vec3<f32>(x_2779.x, x_2779.y, x_2779.z) + x_2778);\n  let x_2782 : vec4<f32> = pc_fragColor;\n  pc_fragColor = vec4<f32>(x_2781.x, x_2781.y, x_2781.z, x_2782.w);\n  let x_2785 : vec4<f32> = pc_fragColor;\n  param_181 = vec3<f32>(x_2785.x, x_2785.y, x_2785.z);\n  let x_2787 : vec3<f32> = addFog_vf3_(&(param_181));\n  let x_2788 : vec4<f32> = pc_fragColor;\n  pc_fragColor = vec4<f32>(x_2787.x, x_2787.y, x_2787.z, x_2788.w);\n  let x_2791 : vec4<f32> = pc_fragColor;\n  param_182 = vec3<f32>(x_2791.x, x_2791.y, x_2791.z);\n  let x_2793 : vec3<f32> = toneMap_vf3_(&(param_182));\n  let x_2794 : vec4<f32> = pc_fragColor;\n  pc_fragColor = vec4<f32>(x_2793.x, x_2793.y, x_2793.z, x_2794.w);\n  let x_2797 : vec4<f32> = pc_fragColor;\n  param_183 = vec3<f32>(x_2797.x, x_2797.y, x_2797.z);\n  let x_2799 : vec3<f32> = gammaCorrectOutput_vf3_(&(param_183));\n  let x_2800 : vec4<f32> = pc_fragColor;\n  pc_fragColor = vec4<f32>(x_2799.x, x_2799.y, x_2799.z, x_2800.w);\n  pc_fragColor.w = 1.0f;\n  return;\n}\n\nfn main_1() {\n  var x_2808 : vec3<f32>;\n  var param_184 : vec3<f32>;\n  var param_185 : vec3<f32>;\n  var param_186 : vec3<f32>;\n  var litShaderArgs_2 : LitShaderArguments;\n  var param_187 : LitShaderArguments;\n  dAlpha = 1.0f;\n  dBlendModeFogFactor = 1.0f;\n  dReflection = vec4<f32>(0.0f, 0.0f, 0.0f, 0.0f);\n  let x_2807 : bool = gl_FrontFacing;\n  if (x_2807) {\n    let x_2811 : vec3<f32> = vNormalW;\n    let x_2813 : f32 = x_534.twoSidedLightingNegScaleFactor;\n    x_2808 = (x_2811 * x_2813);\n  } else {\n    let x_2816 : vec3<f32> = vNormalW;\n    let x_2819 : f32 = x_534.twoSidedLightingNegScaleFactor;\n    x_2808 = (-(x_2816) * x_2819);\n  }\n  let x_2821 : vec3<f32> = x_2808;\n  dVertexNormalW = normalize(x_2821);\n  getViewDir_();\n  let x_2827 : vec3<f32> = dTangentW;\n  param_184 = x_2827;\n  let x_2829 : vec3<f32> = dBinormalW;\n  param_185 = x_2829;\n  let x_2831 : vec3<f32> = dVertexNormalW;\n  param_186 = x_2831;\n  getTBN_vf3_vf3_vf3_(&(param_184), &(param_185), &(param_186));\n  let x_2834 : LitShaderArguments = evaluateFrontend_();\n  litShaderArgs_2 = x_2834;\n  let x_2836 : LitShaderArguments = litShaderArgs_2;\n  param_187 = x_2836;\n  evaluateBackend_struct_LitShaderArguments_f1_vf3_vf3_f1_f1_vf3_f1_f1_f1_f1_vf3_vf3_vf3_struct_IridescenceArgs_f1_f11_struct_ClearcoatArgs_f1_f1_vf31_struct_SheenArgs_f1_vf311_(&(param_187));\n  return;\n}\n\nstruct main_out {\n  @location(0)\n  pc_fragColor_1 : vec4<f32>,\n}\n\n@fragment\nfn main(@location(0) vPositionW_param : vec3<f32>, @location(2) vUv0_param : vec2<f32>, @location(1) vNormalW_param : vec3<f32>, @builtin(front_facing) gl_FrontFacing_param : bool) -> main_out {\n  vPositionW = vPositionW_param;\n  vUv0 = vUv0_param;\n  vNormalW = vNormalW_param;\n  gl_FrontFacing = gl_FrontFacing_param;\n  main_1();\n  return main_out(pc_fragColor);\n}\n"
      },
      "entryPoint": "main",
      "targets": [
          {
              "format": "rgba8unorm",
              "writeMask": 15
          }
      ]
  }
}