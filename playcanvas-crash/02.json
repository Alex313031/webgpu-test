{
  "vertex": {
      "module": {
          "code": "struct ub_view {\n  /* @offset(0) */\n  matrix_model : mat4x4<f32>,\n  /* @offset(64) */\n  matrix_normal : mat3x3<f32>,\n  /* @offset(112) */\n  view_position : vec3<f32>,\n  /* @offset(128) */\n  light_globalAmbient : vec3<f32>,\n  /* @offset(140) */\n  textureBias : f32,\n  /* @offset(144) */\n  twoSidedLightingNegScaleFactor : f32,\n  /* @offset(148) */\n  tbnBasis : f32,\n  /* @offset(152) */\n  exposure : f32,\n  /* @offset(156) */\n  material_bumpiness : f32,\n  /* @offset(160) */\n  material_gloss : f32,\n  /* @offset(176) */\n  material_emissive : vec3<f32>,\n  /* @offset(188) */\n  material_clearCoat : f32,\n  /* @offset(192) */\n  material_clearCoatGloss : f32,\n  /* @offset(196) */\n  material_clearCoatBumpiness : f32,\n  /* @offset(200) */\n  material_f0 : f32,\n  /* @offset(204) */\n  clusterMaxCells : i32,\n  /* @offset(208) */\n  clusterSkip : f32,\n  /* @offset(224) */\n  clusterCellsCountByBoundsSize : vec3<f32>,\n  /* @offset(240) */\n  clusterTextureSize : vec3<f32>,\n  /* @offset(256) */\n  clusterBoundsMin : vec3<f32>,\n  /* @offset(272) */\n  clusterBoundsDelta : vec3<f32>,\n  /* @offset(288) */\n  clusterCellsDot : vec3<f32>,\n  /* @offset(304) */\n  clusterCellsMax : vec3<f32>,\n  /* @offset(320) */\n  clusterCompressionLimit0 : vec2<f32>,\n  /* @offset(328) */\n  shadowAtlasParams : vec2<f32>,\n}\n\nstruct ub_mesh {\n  /* @offset(0) */\n  matrix_viewProjection : mat4x4<f32>,\n}\n\nvar<private> vertex_texCoord0 : vec2<f32>;\n\nvar<private> vertex_texCoord1 : vec2<f32>;\n\n@group(0) @binding(0) var<uniform> x_40 : ub_view;\n\nvar<private> dModelMatrix : mat4x4<f32>;\n\nvar<private> vertex_position : vec3<f32>;\n\nvar<private> dPositionW : vec3<f32>;\n\n@group(1) @binding(0) var<uniform> x_72 : ub_mesh;\n\nvar<private> dNormalMatrix : mat3x3<f32>;\n\nvar<private> vertex_normal : vec3<f32>;\n\nvar<private> vPositionW : vec3<f32>;\n\nvar<private> vNormalW : vec3<f32>;\n\nvar<private> vUv0 : vec2<f32>;\n\nvar<private> vUv1 : vec2<f32>;\n\n@group(1) @binding(1) var lightsTextureFloat : texture_2d<f32>;\n\n@group(1) @binding(2) var lightsTextureFloat_sampler : sampler;\n\n@group(1) @binding(3) var lightsTexture8 : texture_2d<f32>;\n\n@group(1) @binding(4) var lightsTexture8_sampler : sampler;\n\n@group(0) @binding(1) var texture_normalMap : texture_2d<f32>;\n\n@group(0) @binding(2) var texture_normalMap_sampler : sampler;\n\n@group(0) @binding(3) var texture_diffuseMap : texture_2d<f32>;\n\n@group(0) @binding(4) var texture_diffuseMap_sampler : sampler;\n\n@group(0) @binding(5) var texture_metalnessMap : texture_2d<f32>;\n\n@group(0) @binding(6) var texture_metalnessMap_sampler : sampler;\n\n@group(0) @binding(7) var texture_clearCoatNormalMap : texture_2d<f32>;\n\n@group(0) @binding(8) var texture_clearCoatNormalMap_sampler : sampler;\n\n@group(0) @binding(9) var areaLightsLutTex1 : texture_2d<f32>;\n\n@group(0) @binding(10) var areaLightsLutTex1_sampler : sampler;\n\n@group(0) @binding(11) var areaLightsLutTex2 : texture_2d<f32>;\n\n@group(0) @binding(12) var areaLightsLutTex2_sampler : sampler;\n\n@group(0) @binding(13) var clusterWorldTexture : texture_2d<f32>;\n\n@group(0) @binding(14) var clusterWorldTexture_sampler : sampler;\n\nvar<private> gl_Position : vec4<f32>;\n\nfn getModelMatrix_() -> mat4x4<f32> {\n  let x_44 : mat4x4<f32> = x_40.matrix_model;\n  return x_44;\n}\n\nfn getPosition_() -> vec4<f32> {\n  var localPos : vec3<f32>;\n  var posW : vec4<f32>;\n  var screenPos : vec4<f32>;\n  let x_49 : mat4x4<f32> = getModelMatrix_();\n  dModelMatrix = x_49;\n  let x_54 : vec3<f32> = vertex_position;\n  localPos = x_54;\n  let x_57 : mat4x4<f32> = dModelMatrix;\n  let x_58 : vec3<f32> = localPos;\n  posW = (x_57 * vec4<f32>(x_58.x, x_58.y, x_58.z, 1.0f));\n  let x_67 : vec4<f32> = posW;\n  dPositionW = vec3<f32>(x_67.x, x_67.y, x_67.z);\n  let x_74 : mat4x4<f32> = x_72.matrix_viewProjection;\n  let x_75 : vec4<f32> = posW;\n  screenPos = (x_74 * x_75);\n  let x_77 : vec4<f32> = screenPos;\n  return x_77;\n}\n\nfn getWorldPosition_() -> vec3<f32> {\n  let x_80 : vec3<f32> = dPositionW;\n  return x_80;\n}\n\nfn getNormal_() -> vec3<f32> {\n  var tempNormal : vec3<f32>;\n  let x_88 : mat3x3<f32> = x_40.matrix_normal;\n  dNormalMatrix = x_88;\n  let x_91 : vec3<f32> = vertex_normal;\n  tempNormal = x_91;\n  let x_92 : mat3x3<f32> = dNormalMatrix;\n  let x_93 : vec3<f32> = tempNormal;\n  return normalize((x_92 * x_93));\n}\n\nfn getUv0_() -> vec2<f32> {\n  let x_29 : vec2<f32> = vertex_texCoord0;\n  return x_29;\n}\n\nfn getUv1_() -> vec2<f32> {\n  let x_33 : vec2<f32> = vertex_texCoord1;\n  return x_33;\n}\n\nfn main_1() {\n  var uv0 : vec2<f32>;\n  var uv1 : vec2<f32>;\n  let x_104 : vec4<f32> = getPosition_();\n  gl_Position = x_104;\n  let x_109 : vec3<f32> = getWorldPosition_();\n  vPositionW = x_109;\n  let x_111 : vec3<f32> = getNormal_();\n  vNormalW = x_111;\n  let x_114 : vec2<f32> = getUv0_();\n  uv0 = x_114;\n  let x_117 : vec2<f32> = uv0;\n  vUv0 = x_117;\n  let x_119 : vec2<f32> = getUv1_();\n  uv1 = x_119;\n  let x_121 : vec2<f32> = uv1;\n  vUv1 = x_121;\n  return;\n}\n\nstruct main_out {\n  @builtin(position)\n  gl_Position : vec4<f32>,\n  @location(0)\n  vPositionW_1 : vec3<f32>,\n  @location(1)\n  vNormalW_1 : vec3<f32>,\n  @location(2)\n  vUv0_1 : vec2<f32>,\n  @location(3)\n  vUv1_1 : vec2<f32>,\n}\n\n@vertex\nfn main(@location(5) vertex_texCoord0_param : vec2<f32>, @location(6) vertex_texCoord1_param : vec2<f32>, @location(0) vertex_position_param : vec3<f32>, @location(1) vertex_normal_param : vec3<f32>) -> main_out {\n  vertex_texCoord0 = vertex_texCoord0_param;\n  vertex_texCoord1 = vertex_texCoord1_param;\n  vertex_position = vertex_position_param;\n  vertex_normal = vertex_normal_param;\n  main_1();\n  return main_out(gl_Position, vPositionW, vNormalW, vUv0, vUv1);\n}\n"
      },
      "entryPoint": "main",
      "buffers": [
          {
              "attributes": [
                  {
                      "shaderLocation": 0,
                      "offset": 0,
                      "format": "float32x3"
                  },
                  {
                      "shaderLocation": 1,
                      "offset": 12,
                      "format": "float32x3"
                  },
                  {
                      "shaderLocation": 5,
                      "offset": 24,
                      "format": "float32x2"
                  },
                  {
                      "shaderLocation": 6,
                      "offset": 32,
                      "format": "float32x2"
                  }
              ],
              "arrayStride": 40,
              "stepMode": "vertex"
          }
      ]
  },
  "primitive": {
      "topology": "triangle-list",
      "cullMode": "none"
  },
  "depthStencil": {
      "format": "depth24plus-stencil8",
      "depthWriteEnabled": true,
      "depthCompare": "less-equal"
  },
  "multisample": {
      "count": 4
  },
  "layout": "auto",
  "fragment": {
      "module": {
          "code": "struct IridescenceArgs {\n  intensity : f32,\n  thickness : f32,\n}\n\nstruct ClearcoatArgs {\n  specularity : f32,\n  gloss : f32,\n  worldNormal : vec3<f32>,\n}\n\nstruct SheenArgs {\n  gloss : f32,\n  specularity : vec3<f32>,\n}\n\nstruct LitShaderArguments {\n  opacity : f32,\n  worldNormal : vec3<f32>,\n  albedo : vec3<f32>,\n  transmission : f32,\n  thickness : f32,\n  specularity : vec3<f32>,\n  gloss : f32,\n  metalness : f32,\n  specularityFactor : f32,\n  ao : f32,\n  emission : vec3<f32>,\n  lightmap : vec3<f32>,\n  lightmapDir : vec3<f32>,\n  iridescence : IridescenceArgs,\n  clearcoat : ClearcoatArgs,\n  sheen : SheenArgs,\n}\n\nstruct Coords {\n  coord0 : vec3<f32>,\n  coord1 : vec3<f32>,\n  coord2 : vec3<f32>,\n  coord3 : vec3<f32>,\n}\n\nstruct ClusterLightData {\n  halfWidth : vec3<f32>,\n  lightType : f32,\n  halfHeight : vec3<f32>,\n  lightIndex : i32,\n  position : vec3<f32>,\n  shape : f32,\n  direction : vec3<f32>,\n  falloffMode : f32,\n  color : vec3<f32>,\n  shadowIntensity : f32,\n  omniAtlasViewport : vec3<f32>,\n  range : f32,\n  cookieChannelMask : vec4<f32>,\n  shadowBias : f32,\n  shadowNormalBias : f32,\n  innerConeAngleCos : f32,\n  outerConeAngleCos : f32,\n  cookie : f32,\n  cookieRgb : f32,\n  cookieIntensity : f32,\n  mask : f32,\n}\n\nstruct ub_view {\n  /* @offset(0) */\n  matrix_model : mat4x4<f32>,\n  /* @offset(64) */\n  matrix_normal : mat3x3<f32>,\n  /* @offset(112) */\n  view_position : vec3<f32>,\n  /* @offset(128) */\n  light_globalAmbient : vec3<f32>,\n  /* @offset(140) */\n  textureBias : f32,\n  /* @offset(144) */\n  twoSidedLightingNegScaleFactor : f32,\n  /* @offset(148) */\n  tbnBasis : f32,\n  /* @offset(152) */\n  exposure : f32,\n  /* @offset(156) */\n  material_bumpiness : f32,\n  /* @offset(160) */\n  material_gloss : f32,\n  /* @offset(176) */\n  material_emissive : vec3<f32>,\n  /* @offset(188) */\n  material_clearCoat : f32,\n  /* @offset(192) */\n  material_clearCoatGloss : f32,\n  /* @offset(196) */\n  material_clearCoatBumpiness : f32,\n  /* @offset(200) */\n  material_f0 : f32,\n  /* @offset(204) */\n  clusterMaxCells : i32,\n  /* @offset(208) */\n  clusterSkip : f32,\n  /* @offset(224) */\n  clusterCellsCountByBoundsSize : vec3<f32>,\n  /* @offset(240) */\n  clusterTextureSize : vec3<f32>,\n  /* @offset(256) */\n  clusterBoundsMin : vec3<f32>,\n  /* @offset(272) */\n  clusterBoundsDelta : vec3<f32>,\n  /* @offset(288) */\n  clusterCellsDot : vec3<f32>,\n  /* @offset(304) */\n  clusterCellsMax : vec3<f32>,\n  /* @offset(320) */\n  clusterCompressionLimit0 : vec2<f32>,\n  /* @offset(328) */\n  shadowAtlasParams : vec2<f32>,\n}\n\nstruct ub_mesh {\n  /* @offset(0) */\n  matrix_viewProjection : mat4x4<f32>,\n}\n\nvar<private> dAlpha : f32;\n\nvar<private> dBlendModeFogFactor : f32;\n\nvar<private> dLightDirW : vec3<f32>;\n\nvar<private> vPositionW : vec3<f32>;\n\nvar<private> dLightDirNormW : vec3<f32>;\n\nvar<private> dLightPosW : vec3<f32>;\n\nvar<private> vUv0 : vec2<f32>;\n\n@group(0) @binding(0) var<uniform> x_546 : ub_view;\n\nvar<private> dTBN : mat3x3<f32>;\n\n@group(0) @binding(1) var texture_normalMap : texture_2d<f32>;\n\n@group(0) @binding(2) var texture_normalMap_sampler : sampler;\n\nvar<private> dNormalW : vec3<f32>;\n\nvar<private> dAlbedo : vec3<f32>;\n\n@group(0) @binding(3) var texture_diffuseMap : texture_2d<f32>;\n\n@group(0) @binding(4) var texture_diffuseMap_sampler : sampler;\n\n@group(0) @binding(5) var texture_metalnessMap : texture_2d<f32>;\n\n@group(0) @binding(6) var texture_metalnessMap_sampler : sampler;\n\nvar<private> dMetalness : f32;\n\nvar<private> dSpecularity : vec3<f32>;\n\nvar<private> dGlossiness : f32;\n\nvar<private> dAo : f32;\n\nvar<private> dEmission : vec3<f32>;\n\nvar<private> ccSpecularity : f32;\n\nvar<private> ccGlossiness : f32;\n\n@group(0) @binding(7) var texture_clearCoatNormalMap : texture_2d<f32>;\n\n@group(0) @binding(8) var texture_clearCoatNormalMap_sampler : sampler;\n\nvar<private> vUv1 : vec2<f32>;\n\nvar<private> ccNormalW : vec3<f32>;\n\nvar<private> dDiffuseLight : vec3<f32>;\n\nvar<private> dSpecularLight : vec3<f32>;\n\nvar<private> dReflection : vec4<f32>;\n\nvar<private> dSphereRadius : f32;\n\nvar<private> vNormalW : vec3<f32>;\n\n@group(0) @binding(11) var areaLightsLutTex2 : texture_2d<f32>;\n\n@group(0) @binding(12) var areaLightsLutTex2_sampler : sampler;\n\nvar<private> dLTCUV : vec2<f32>;\n\nvar<private> dLTCSpecFres : vec3<f32>;\n\nvar<private> ccLTCUV : vec2<f32>;\n\nvar<private> ccLTCSpecFres : vec3<f32>;\n\nvar<private> dLTCCoords : Coords;\n\n@group(0) @binding(9) var areaLightsLutTex1 : texture_2d<f32>;\n\n@group(0) @binding(10) var areaLightsLutTex1_sampler : sampler;\n\nvar<private> ccFresnel : f32;\n\nvar<private> ccSpecularLight : vec3<f32>;\n\nvar<private> ccReflection : vec3<f32>;\n\nvar<private> dViewDirW : vec3<f32>;\n\nvar<private> dReflDirW : vec3<f32>;\n\n@group(1) @binding(3) var lightsTexture8 : texture_2d<f32>;\n\n@group(1) @binding(1) var lightsTextureFloat : texture_2d<f32>;\n\n@group(0) @binding(13) var clusterWorldTexture : texture_2d<f32>;\n\nvar<private> ccReflDirW : vec3<f32>;\n\nvar<private> dVertexNormalW : vec3<f32>;\n\nvar<private> pc_fragColor : vec4<f32>;\n\nvar<private> gl_FrontFacing : bool;\n\nvar<private> dTangentW : vec3<f32>;\n\nvar<private> dBinormalW : vec3<f32>;\n\n@group(1) @binding(0) var<uniform> x_3034 : ub_mesh;\n\n@group(1) @binding(2) var lightsTextureFloat_sampler : sampler;\n\n@group(1) @binding(4) var lightsTexture8_sampler : sampler;\n\n@group(0) @binding(14) var clusterWorldTexture_sampler : sampler;\n\nvar<private> dShadowCoord : vec3<f32>;\n\nvar<private> sSpecularLight : vec3<f32>;\n\nvar<private> sReflection : vec3<f32>;\n\nvar<private> lightProjectionMatrix : mat4x4<f32>;\n\nfn getViewDir_() {\n  let x_2209 : vec3<f32> = x_546.view_position;\n  let x_2210 : vec3<f32> = vPositionW;\n  dViewDirW = normalize((x_2209 - x_2210));\n  return;\n}\n\nfn getTBN_vf3_vf3_vf3_(tangent : ptr<function, vec3<f32>>, binormal : ptr<function, vec3<f32>>, normal : ptr<function, vec3<f32>>) {\n  var uv_4 : vec2<f32>;\n  var dp1 : vec3<f32>;\n  var dp2 : vec3<f32>;\n  var duv1 : vec2<f32>;\n  var duv2 : vec2<f32>;\n  var dp2perp : vec3<f32>;\n  var dp1perp : vec3<f32>;\n  var T : vec3<f32>;\n  var B : vec3<f32>;\n  var denom : f32;\n  var invmax : f32;\n  var x_539 : f32;\n  let x_483 : vec2<f32> = vUv0;\n  uv_4 = x_483;\n  let x_485 : vec3<f32> = vPositionW;\n  dp1 = dpdx(x_485);\n  let x_488 : vec3<f32> = vPositionW;\n  dp2 = dpdy(x_488);\n  let x_491 : vec2<f32> = uv_4;\n  duv1 = dpdx(x_491);\n  let x_494 : vec2<f32> = uv_4;\n  duv2 = dpdy(x_494);\n  let x_497 : vec3<f32> = dp2;\n  let x_498 : vec3<f32> = *(normal);\n  dp2perp = cross(x_497, x_498);\n  let x_501 : vec3<f32> = *(normal);\n  let x_502 : vec3<f32> = dp1;\n  dp1perp = cross(x_501, x_502);\n  let x_505 : vec3<f32> = dp2perp;\n  let x_509 : f32 = duv1.x;\n  let x_511 : vec3<f32> = dp1perp;\n  let x_513 : f32 = duv2.x;\n  T = ((x_505 * x_509) + (x_511 * x_513));\n  let x_517 : vec3<f32> = dp2perp;\n  let x_520 : f32 = duv1.y;\n  let x_522 : vec3<f32> = dp1perp;\n  let x_524 : f32 = duv2.y;\n  B = ((x_517 * x_520) + (x_522 * x_524));\n  let x_528 : vec3<f32> = T;\n  let x_529 : vec3<f32> = T;\n  let x_531 : vec3<f32> = B;\n  let x_532 : vec3<f32> = B;\n  denom = max(dot(x_528, x_529), dot(x_531, x_532));\n  let x_536 : f32 = denom;\n  if ((x_536 == 0.0f)) {\n    x_539 = 0.0f;\n  } else {\n    let x_550 : f32 = x_546.tbnBasis;\n    let x_551 : f32 = denom;\n    x_539 = (x_550 / sqrt(x_551));\n  }\n  let x_554 : f32 = x_539;\n  invmax = x_554;\n  let x_557 : vec3<f32> = T;\n  let x_558 : f32 = invmax;\n  let x_559 : vec3<f32> = (x_557 * x_558);\n  let x_560 : vec3<f32> = B;\n  let x_562 : f32 = invmax;\n  let x_563 : vec3<f32> = (-(x_560) * x_562);\n  let x_564 : vec3<f32> = *(normal);\n  dTBN = mat3x3<f32>(vec3<f32>(x_559.x, x_559.y, x_559.z), vec3<f32>(x_563.x, x_563.y, x_563.z), vec3<f32>(x_564.x, x_564.y, x_564.z));\n  return;\n}\n\nfn unpackNormal_vf4_(nmap : ptr<function, vec4<f32>>) -> vec3<f32> {\n  let x_635 : vec4<f32> = *(nmap);\n  return ((vec3<f32>(x_635.x, x_635.y, x_635.z) * 2.0f) - vec3<f32>(1.0f, 1.0f, 1.0f));\n}\n\nfn addNormalDetail_vf3_(normalMap : ptr<function, vec3<f32>>) -> vec3<f32> {\n  let x_643 : vec3<f32> = *(normalMap);\n  return x_643;\n}\n\nfn getNormal_() {\n  var normalMap_1 : vec3<f32>;\n  var param_8 : vec4<f32>;\n  var param_9 : vec3<f32>;\n  let x_657 : vec2<f32> = vUv0;\n  let x_660 : f32 = x_546.textureBias;\n  let x_661 : vec4<f32> = textureSampleBias(texture_normalMap, texture_normalMap_sampler, x_657, x_660);\n  param_8 = x_661;\n  let x_663 : vec3<f32> = unpackNormal_vf4_(&(param_8));\n  normalMap_1 = x_663;\n  let x_665 : vec3<f32> = normalMap_1;\n  let x_668 : f32 = x_546.material_bumpiness;\n  normalMap_1 = mix(vec3<f32>(0.0f, 0.0f, 1.0f), x_665, vec3<f32>(x_668, x_668, x_668));\n  let x_672 : mat3x3<f32> = dTBN;\n  let x_674 : vec3<f32> = normalMap_1;\n  param_9 = x_674;\n  let x_675 : vec3<f32> = addNormalDetail_vf3_(&(param_9));\n  dNormalW = normalize((x_672 * x_675));\n  return;\n}\n\nfn decodeGamma_vf4_(raw : ptr<function, vec4<f32>>) -> vec3<f32> {\n  let x_578 : vec4<f32> = *(raw);\n  return pow(vec3<f32>(x_578.x, x_578.y, x_578.z), vec3<f32>(2.200000048f, 2.200000048f, 2.200000048f));\n}\n\nfn addAlbedoDetail_vf3_(albedo : ptr<function, vec3<f32>>) -> vec3<f32> {\n  let x_678 : vec3<f32> = *(albedo);\n  return x_678;\n}\n\nfn getAlbedo_() {\n  var albedoBase : vec3<f32>;\n  var param_10 : vec4<f32>;\n  var param_11 : vec3<f32>;\n  dAlbedo = vec3<f32>(1.0f, 1.0f, 1.0f);\n  let x_689 : vec2<f32> = vUv0;\n  let x_691 : f32 = x_546.textureBias;\n  let x_692 : vec4<f32> = textureSampleBias(texture_diffuseMap, texture_diffuseMap_sampler, x_689, x_691);\n  param_10 = x_692;\n  let x_694 : vec3<f32> = decodeGamma_vf4_(&(param_10));\n  albedoBase = x_694;\n  let x_696 : vec3<f32> = albedoBase;\n  param_11 = x_696;\n  let x_697 : vec3<f32> = addAlbedoDetail_vf3_(&(param_11));\n  let x_698 : vec3<f32> = dAlbedo;\n  dAlbedo = (x_698 * x_697);\n  return;\n}\n\nfn getMetalness_() {\n  var metalness : f32;\n  metalness = 1.0f;\n  let x_706 : vec2<f32> = vUv0;\n  let x_708 : f32 = x_546.textureBias;\n  let x_709 : vec4<f32> = textureSampleBias(texture_metalnessMap, texture_metalnessMap_sampler, x_706, x_708);\n  let x_712 : f32 = metalness;\n  metalness = (x_712 * x_709.z);\n  let x_715 : f32 = metalness;\n  dMetalness = x_715;\n  return;\n}\n\nfn getGlossiness_() {\n  dGlossiness = 1.0f;\n  let x_720 : f32 = x_546.material_gloss;\n  let x_721 : f32 = dGlossiness;\n  dGlossiness = (x_721 * x_720);\n  let x_726 : vec2<f32> = vUv0;\n  let x_728 : f32 = x_546.textureBias;\n  let x_729 : vec4<f32> = textureSampleBias(texture_metalnessMap, texture_metalnessMap_sampler, x_726, x_728);\n  let x_731 : f32 = dGlossiness;\n  dGlossiness = (x_731 * x_729.y);\n  let x_733 : f32 = dGlossiness;\n  dGlossiness = (1.0f - x_733);\n  let x_735 : f32 = dGlossiness;\n  dGlossiness = (x_735 + 0.0000001f);\n  return;\n}\n\nfn getSpecularity_() {\n  dSpecularity = vec3<f32>(1.0f, 1.0f, 1.0f);\n  return;\n}\n\nfn getAO_() {\n  dAo = 1.0f;\n  let x_741 : vec2<f32> = vUv0;\n  let x_743 : f32 = x_546.textureBias;\n  let x_744 : vec4<f32> = textureSampleBias(texture_metalnessMap, texture_metalnessMap_sampler, x_741, x_743);\n  let x_746 : f32 = dAo;\n  dAo = (x_746 * x_744.x);\n  return;\n}\n\nfn getEmission_() {\n  dEmission = vec3<f32>(1.0f, 1.0f, 1.0f);\n  let x_752 : vec3<f32> = x_546.material_emissive;\n  let x_753 : vec3<f32> = dEmission;\n  dEmission = (x_753 * x_752);\n  return;\n}\n\nfn getClearCoat_() {\n  ccSpecularity = 1.0f;\n  let x_758 : f32 = x_546.material_clearCoat;\n  let x_759 : f32 = ccSpecularity;\n  ccSpecularity = (x_759 * x_758);\n  return;\n}\n\nfn getClearCoatGlossiness_() {\n  ccGlossiness = 1.0f;\n  let x_764 : f32 = x_546.material_clearCoatGloss;\n  let x_765 : f32 = ccGlossiness;\n  ccGlossiness = (x_765 * x_764);\n  let x_767 : f32 = ccGlossiness;\n  ccGlossiness = (1.0f - x_767);\n  let x_769 : f32 = ccGlossiness;\n  ccGlossiness = (x_769 + 0.0000001f);\n  return;\n}\n\nfn getClearCoatNormal_() {\n  var normalMap_2 : vec3<f32>;\n  var param_12 : vec4<f32>;\n  let x_778 : vec2<f32> = vUv1;\n  let x_780 : f32 = x_546.textureBias;\n  let x_781 : vec4<f32> = textureSampleBias(texture_clearCoatNormalMap, texture_clearCoatNormalMap_sampler, x_778, x_780);\n  param_12 = x_781;\n  let x_783 : vec3<f32> = unpackNormal_vf4_(&(param_12));\n  normalMap_2 = x_783;\n  let x_784 : vec3<f32> = normalMap_2;\n  let x_787 : f32 = x_546.material_clearCoatBumpiness;\n  normalMap_2 = mix(vec3<f32>(0.0f, 0.0f, 1.0f), x_784, vec3<f32>(x_787, x_787, x_787));\n  let x_791 : mat3x3<f32> = dTBN;\n  let x_792 : vec3<f32> = normalMap_2;\n  ccNormalW = normalize((x_791 * x_792));\n  return;\n}\n\nfn evaluateFrontend_() -> LitShaderArguments {\n  var x_litShaderArgs : LitShaderArguments;\n  getNormal_();\n  getAlbedo_();\n  getMetalness_();\n  getGlossiness_();\n  getSpecularity_();\n  getAO_();\n  getEmission_();\n  getClearCoat_();\n  getClearCoatGlossiness_();\n  getClearCoatNormal_();\n  let x_807 : vec3<f32> = dNormalW;\n  x_litShaderArgs.worldNormal = x_807;\n  let x_810 : vec3<f32> = dAlbedo;\n  x_litShaderArgs.albedo = x_810;\n  let x_812 : f32 = dMetalness;\n  x_litShaderArgs.metalness = x_812;\n  let x_815 : vec3<f32> = dSpecularity;\n  x_litShaderArgs.specularity = x_815;\n  let x_817 : f32 = dGlossiness;\n  x_litShaderArgs.gloss = x_817;\n  let x_819 : f32 = dAo;\n  x_litShaderArgs.ao = x_819;\n  let x_821 : vec3<f32> = dEmission;\n  x_litShaderArgs.emission = x_821;\n  let x_825 : f32 = ccSpecularity;\n  x_litShaderArgs.clearcoat.specularity = x_825;\n  let x_827 : f32 = ccGlossiness;\n  x_litShaderArgs.clearcoat.gloss = x_827;\n  let x_829 : vec3<f32> = ccNormalW;\n  x_litShaderArgs.clearcoat.worldNormal = x_829;\n  let x_831 : LitShaderArguments = x_litShaderArgs;\n  return x_831;\n}\n\nfn getReflDir_vf3_vf3_f1_mf33_(worldNormal_15 : ptr<function, vec3<f32>>, viewDir_13 : ptr<function, vec3<f32>>, gloss_6 : ptr<function, f32>, tbn_1 : ptr<function, mat3x3<f32>>) {\n  let x_2214 : vec3<f32> = *(viewDir_13);\n  let x_2215 : vec3<f32> = *(worldNormal_15);\n  dReflDirW = normalize(-(reflect(x_2214, x_2215)));\n  return;\n}\n\nfn getMetalnessModulate_struct_LitShaderArguments_f1_vf3_vf3_f1_f1_vf3_f1_f1_f1_f1_vf3_vf3_vf3_struct_IridescenceArgs_f1_f11_struct_ClearcoatArgs_f1_f1_vf31_struct_SheenArgs_f1_vf311_(litShaderArgs : ptr<function, LitShaderArguments>) {\n  var dielectricF0 : vec3<f32>;\n  let x_836 : f32 = x_546.material_f0;\n  let x_838 : vec3<f32> = (*(litShaderArgs)).specularity;\n  dielectricF0 = (x_838 * x_836);\n  let x_840 : vec3<f32> = dielectricF0;\n  let x_842 : vec3<f32> = (*(litShaderArgs)).albedo;\n  let x_844 : f32 = (*(litShaderArgs)).metalness;\n  (*(litShaderArgs)).specularity = mix(x_840, x_842, vec3<f32>(x_844, x_844, x_844));\n  let x_849 : f32 = (*(litShaderArgs)).metalness;\n  let x_852 : vec3<f32> = (*(litShaderArgs)).albedo;\n  (*(litShaderArgs)).albedo = (x_852 * (1.0f - x_849));\n  return;\n}\n\nfn addAmbient_vf3_(worldNormal_14 : ptr<function, vec3<f32>>) {\n  let x_2204 : vec3<f32> = x_546.light_globalAmbient;\n  let x_2205 : vec3<f32> = dDiffuseLight;\n  dDiffuseLight = (x_2205 + x_2204);\n  return;\n}\n\nfn occludeDiffuse_f1_(ao : ptr<function, f32>) {\n  let x_892 : f32 = *(ao);\n  let x_893 : vec3<f32> = dDiffuseLight;\n  dDiffuseLight = (x_893 * x_892);\n  return;\n}\n\nfn saturate_f1_(x_1 : ptr<function, f32>) -> f32 {\n  let x_390 : f32 = *(x_1);\n  return clamp(x_390, 0.0f, 1.0f);\n}\n\nfn LTC_Uv_vf3_vf3_f1_(N : vec3<f32>, V : vec3<f32>, roughness : f32) -> vec2<f32> {\n  var dotNV : f32;\n  var param_13 : f32;\n  var uv_5 : vec2<f32>;\n  param_13 = dot(N, V);\n  let x_933 : f32 = saturate_f1_(&(param_13));\n  dotNV = x_933;\n  let x_935 : f32 = dotNV;\n  uv_5 = vec2<f32>(roughness, sqrt((1.0f - x_935)));\n  let x_939 : vec2<f32> = uv_5;\n  uv_5 = ((x_939 * 0.984375f) + vec2<f32>(0.0078125f, 0.0078125f));\n  let x_945 : vec2<f32> = uv_5;\n  return x_945;\n}\n\nfn getLTCLightUV_f1_vf3_vf3_(gloss_2 : ptr<function, f32>, worldNormal_2 : ptr<function, vec3<f32>>, viewDir_2 : ptr<function, vec3<f32>>) -> vec2<f32> {\n  var roughness_1 : f32;\n  let x_1203 : f32 = *(gloss_2);\n  let x_1205 : f32 = *(gloss_2);\n  roughness_1 = max(((1.0f - x_1203) * (1.0f - x_1205)), 0.001f);\n  let x_1210 : vec3<f32> = *(worldNormal_2);\n  let x_1211 : vec3<f32> = *(viewDir_2);\n  let x_1212 : f32 = roughness_1;\n  let x_1213 : vec2<f32> = LTC_Uv_vf3_vf3_f1_(x_1210, x_1211, x_1212);\n  return x_1213;\n}\n\nfn getLTCLightSpecFres_vf2_vf3_(uv : ptr<function, vec2<f32>>, specularity_1 : ptr<function, vec3<f32>>) -> vec3<f32> {\n  var t2 : vec4<f32>;\n  let x_1222 : vec2<f32> = *(uv);\n  let x_1223 : vec4<f32> = textureSampleLevel(areaLightsLutTex2, areaLightsLutTex2_sampler, x_1222, 0.0f);\n  t2 = x_1223;\n  let x_1226 : vec4<f32> = t2;\n  t2 = (x_1226 * vec4<f32>(0.693103015f, 1.0f, 1.0f, 1.0f));\n  let x_1230 : vec4<f32> = t2;\n  t2 = (x_1230 + vec4<f32>(0.306897014f, 0.0f, 0.0f, 0.0f));\n  let x_1232 : vec3<f32> = *(specularity_1);\n  let x_1234 : f32 = t2.x;\n  let x_1236 : vec3<f32> = *(specularity_1);\n  let x_1239 : f32 = t2.y;\n  return ((x_1232 * x_1234) + ((vec3<f32>(1.0f, 1.0f, 1.0f) - x_1236) * x_1239));\n}\n\nfn calcLTCLightValues_f1_vf3_vf3_vf3_f1_vf3_f1_(gloss_3 : ptr<function, f32>, worldNormal_3 : ptr<function, vec3<f32>>, viewDir_3 : ptr<function, vec3<f32>>, specularity_2 : ptr<function, vec3<f32>>, clearcoatGloss : ptr<function, f32>, clearcoatWorldNormal : ptr<function, vec3<f32>>, clearcoatSpecularity : ptr<function, f32>) {\n  var param_17 : f32;\n  var param_18 : vec3<f32>;\n  var param_19 : vec3<f32>;\n  var param_20 : vec2<f32>;\n  var param_21 : vec3<f32>;\n  var param_22 : f32;\n  var param_23 : vec3<f32>;\n  var param_24 : vec3<f32>;\n  var param_25 : vec2<f32>;\n  var param_26 : vec3<f32>;\n  let x_1247 : f32 = *(gloss_3);\n  param_17 = x_1247;\n  let x_1249 : vec3<f32> = *(worldNormal_3);\n  param_18 = x_1249;\n  let x_1251 : vec3<f32> = *(viewDir_3);\n  param_19 = x_1251;\n  let x_1252 : vec2<f32> = getLTCLightUV_f1_vf3_vf3_(&(param_17), &(param_18), &(param_19));\n  dLTCUV = x_1252;\n  let x_1255 : vec2<f32> = dLTCUV;\n  param_20 = x_1255;\n  let x_1257 : vec3<f32> = *(specularity_2);\n  param_21 = x_1257;\n  let x_1258 : vec3<f32> = getLTCLightSpecFres_vf2_vf3_(&(param_20), &(param_21));\n  dLTCSpecFres = x_1258;\n  let x_1261 : f32 = *(clearcoatGloss);\n  param_22 = x_1261;\n  let x_1263 : vec3<f32> = *(clearcoatWorldNormal);\n  param_23 = x_1263;\n  let x_1265 : vec3<f32> = *(viewDir_3);\n  param_24 = x_1265;\n  let x_1266 : vec2<f32> = getLTCLightUV_f1_vf3_vf3_(&(param_22), &(param_23), &(param_24));\n  ccLTCUV = x_1266;\n  let x_1268 : f32 = *(clearcoatSpecularity);\n  let x_1271 : vec2<f32> = ccLTCUV;\n  param_25 = x_1271;\n  param_26 = vec3<f32>(x_1268, x_1268, x_1268);\n  let x_1273 : vec3<f32> = getLTCLightSpecFres_vf2_vf3_(&(param_25), &(param_26));\n  ccLTCSpecFres = x_1273;\n  return;\n}\n\nfn sampleLightsTexture8_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_i1_(clusterLightData : ClusterLightData, index : ptr<function, i32>) -> vec4<f32> {\n  let x_2227 : i32 = *(index);\n  let x_2231 : vec4<f32> = textureLoad(lightsTexture8, vec2<i32>(x_2227, clusterLightData.lightIndex), 0i);\n  return x_2231;\n}\n\nfn bytes2float2_vf2_(data : ptr<function, vec2<f32>>) -> f32 {\n  let x_2219 : vec2<f32> = *(data);\n  return dot(x_2219, vec2<f32>(1.0f, 0.003921569f));\n}\n\nfn sampleLightTextureF_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_i1_(clusterLightData_1 : ClusterLightData, index_1 : ptr<function, i32>) -> vec4<f32> {\n  let x_2236 : i32 = *(index_1);\n  let x_2239 : vec4<f32> = textureLoad(lightsTextureFloat, vec2<i32>(x_2236, clusterLightData_1.lightIndex), 0i);\n  return x_2239;\n}\n\nfn decodeClusterLightCore_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_f1_(clusterLightData_2 : ptr<function, ClusterLightData>, lightIndex : ptr<function, f32>) {\n  var lightInfo : vec4<f32>;\n  var param_65 : i32;\n  var colorA : vec4<f32>;\n  var param_66 : i32;\n  var colorB : vec4<f32>;\n  var param_67 : i32;\n  var param_68 : vec2<f32>;\n  var param_69 : vec2<f32>;\n  var param_70 : vec2<f32>;\n  var lightPosRange : vec4<f32>;\n  var param_71 : i32;\n  var lightDir_Unused : vec4<f32>;\n  var param_72 : i32;\n  let x_2242 : f32 = *(lightIndex);\n  (*(clusterLightData_2)).lightIndex = i32(x_2242);\n  let x_2246 : ClusterLightData = *(clusterLightData_2);\n  param_65 = 0i;\n  let x_2248 : vec4<f32> = sampleLightsTexture8_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_i1_(x_2246, &(param_65));\n  lightInfo = x_2248;\n  let x_2250 : f32 = lightInfo.x;\n  (*(clusterLightData_2)).lightType = x_2250;\n  let x_2253 : f32 = lightInfo.y;\n  (*(clusterLightData_2)).shape = x_2253;\n  let x_2256 : f32 = lightInfo.z;\n  (*(clusterLightData_2)).falloffMode = x_2256;\n  let x_2259 : f32 = lightInfo.w;\n  (*(clusterLightData_2)).shadowIntensity = x_2259;\n  let x_2262 : ClusterLightData = *(clusterLightData_2);\n  param_66 = 1i;\n  let x_2264 : vec4<f32> = sampleLightsTexture8_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_i1_(x_2262, &(param_66));\n  colorA = x_2264;\n  let x_2266 : ClusterLightData = *(clusterLightData_2);\n  param_67 = 2i;\n  let x_2268 : vec4<f32> = sampleLightsTexture8_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_i1_(x_2266, &(param_67));\n  colorB = x_2268;\n  let x_2270 : vec4<f32> = colorA;\n  param_68 = vec2<f32>(x_2270.x, x_2270.y);\n  let x_2272 : f32 = bytes2float2_vf2_(&(param_68));\n  let x_2274 : vec4<f32> = colorA;\n  param_69 = vec2<f32>(x_2274.z, x_2274.w);\n  let x_2276 : f32 = bytes2float2_vf2_(&(param_69));\n  let x_2278 : vec4<f32> = colorB;\n  param_70 = vec2<f32>(x_2278.x, x_2278.y);\n  let x_2280 : f32 = bytes2float2_vf2_(&(param_70));\n  let x_2284 : f32 = x_546.clusterCompressionLimit0.y;\n  (*(clusterLightData_2)).color = (vec3<f32>(x_2272, x_2276, x_2280) * x_2284);\n  let x_2289 : f32 = colorB.z;\n  (*(clusterLightData_2)).cookie = x_2289;\n  let x_2293 : f32 = colorB.w;\n  (*(clusterLightData_2)).mask = x_2293;\n  let x_2296 : ClusterLightData = *(clusterLightData_2);\n  param_71 = 0i;\n  let x_2298 : vec4<f32> = sampleLightTextureF_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_i1_(x_2296, &(param_71));\n  lightPosRange = x_2298;\n  let x_2299 : vec4<f32> = lightPosRange;\n  (*(clusterLightData_2)).position = vec3<f32>(x_2299.x, x_2299.y, x_2299.z);\n  let x_2303 : f32 = lightPosRange.w;\n  (*(clusterLightData_2)).range = x_2303;\n  let x_2306 : ClusterLightData = *(clusterLightData_2);\n  param_72 = 1i;\n  let x_2308 : vec4<f32> = sampleLightTextureF_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_i1_(x_2306, &(param_72));\n  lightDir_Unused = x_2308;\n  let x_2309 : vec4<f32> = lightDir_Unused;\n  (*(clusterLightData_2)).direction = vec3<f32>(x_2309.x, x_2309.y, x_2309.z);\n  return;\n}\n\nfn getLightDirPoint_vf3_(lightPosW : ptr<function, vec3<f32>>) {\n  let x_472 : vec3<f32> = vPositionW;\n  let x_473 : vec3<f32> = *(lightPosW);\n  dLightDirW = (x_472 - x_473);\n  let x_476 : vec3<f32> = dLightDirW;\n  dLightDirNormW = normalize(x_476);\n  let x_479 : vec3<f32> = *(lightPosW);\n  dLightPosW = x_479;\n  return;\n}\n\nfn decodeClusterLightAreaData_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_(clusterLightData_4 : ptr<function, ClusterLightData>) {\n  var param_76 : i32;\n  var param_77 : i32;\n  let x_2332 : ClusterLightData = *(clusterLightData_4);\n  param_76 = 6i;\n  let x_2334 : vec4<f32> = sampleLightTextureF_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_i1_(x_2332, &(param_76));\n  (*(clusterLightData_4)).halfWidth = vec3<f32>(x_2334.x, x_2334.y, x_2334.z);\n  let x_2337 : ClusterLightData = *(clusterLightData_4);\n  param_77 = 7i;\n  let x_2339 : vec4<f32> = sampleLightTextureF_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_i1_(x_2337, &(param_77));\n  (*(clusterLightData_4)).halfHeight = vec3<f32>(x_2339.x, x_2339.y, x_2339.z);\n  return;\n}\n\nfn getLTCLightCoords_vf3_vf3_vf3_(lightPos : ptr<function, vec3<f32>>, halfWidth : ptr<function, vec3<f32>>, halfHeight : ptr<function, vec3<f32>>) -> Coords {\n  var coords_1 : Coords;\n  let x_1137 : vec3<f32> = *(lightPos);\n  let x_1138 : vec3<f32> = *(halfWidth);\n  let x_1140 : vec3<f32> = *(halfHeight);\n  coords_1.coord0 = ((x_1137 + x_1138) - x_1140);\n  let x_1143 : vec3<f32> = *(lightPos);\n  let x_1144 : vec3<f32> = *(halfWidth);\n  let x_1146 : vec3<f32> = *(halfHeight);\n  coords_1.coord1 = ((x_1143 - x_1144) - x_1146);\n  let x_1149 : vec3<f32> = *(lightPos);\n  let x_1150 : vec3<f32> = *(halfWidth);\n  let x_1152 : vec3<f32> = *(halfHeight);\n  coords_1.coord2 = ((x_1149 - x_1150) + x_1152);\n  let x_1155 : vec3<f32> = *(lightPos);\n  let x_1156 : vec3<f32> = *(halfWidth);\n  let x_1158 : vec3<f32> = *(halfHeight);\n  coords_1.coord3 = ((x_1155 + x_1156) + x_1158);\n  let x_1161 : Coords = coords_1;\n  return x_1161;\n}\n\nfn calcRectLightValues_vf3_vf3_vf3_(lightPos_2 : ptr<function, vec3<f32>>, halfWidth_2 : ptr<function, vec3<f32>>, halfHeight_2 : ptr<function, vec3<f32>>) {\n  var param_27 : vec3<f32>;\n  var param_28 : vec3<f32>;\n  var param_29 : vec3<f32>;\n  let x_1277 : vec3<f32> = *(lightPos_2);\n  param_27 = x_1277;\n  let x_1279 : vec3<f32> = *(halfWidth_2);\n  param_28 = x_1279;\n  let x_1281 : vec3<f32> = *(halfHeight_2);\n  param_29 = x_1281;\n  let x_1282 : Coords = getLTCLightCoords_vf3_vf3_vf3_(&(param_27), &(param_28), &(param_29));\n  dLTCCoords = x_1282;\n  return;\n}\n\nfn calcDiskLightValues_vf3_vf3_vf3_(lightPos_3 : ptr<function, vec3<f32>>, halfWidth_3 : ptr<function, vec3<f32>>, halfHeight_3 : ptr<function, vec3<f32>>) {\n  var param_30 : vec3<f32>;\n  var param_31 : vec3<f32>;\n  var param_32 : vec3<f32>;\n  let x_1284 : vec3<f32> = *(lightPos_3);\n  param_30 = x_1284;\n  let x_1286 : vec3<f32> = *(halfWidth_3);\n  param_31 = x_1286;\n  let x_1288 : vec3<f32> = *(halfHeight_3);\n  param_32 = x_1288;\n  calcRectLightValues_vf3_vf3_vf3_(&(param_30), &(param_31), &(param_32));\n  return;\n}\n\nfn getSphereLightCoords_vf3_vf3_vf3_(lightPos_1 : ptr<function, vec3<f32>>, halfWidth_1 : ptr<function, vec3<f32>>, halfHeight_1 : ptr<function, vec3<f32>>) -> Coords {\n  var f_1 : vec3<f32>;\n  var w : vec3<f32>;\n  var h_2 : vec3<f32>;\n  var param_14 : vec3<f32>;\n  var param_15 : vec3<f32>;\n  var param_16 : vec3<f32>;\n  let x_1165 : vec3<f32> = *(halfWidth_1);\n  let x_1167 : vec3<f32> = *(halfHeight_1);\n  dSphereRadius = max(length(x_1165), length(x_1167));\n  let x_1171 : vec3<f32> = *(lightPos_1);\n  let x_1173 : vec3<f32> = x_546.view_position;\n  let x_1175 : vec3<f32> = normalize((x_1171 - x_1173));\n  let x_1177 : vec3<f32> = vNormalW;\n  f_1 = reflect(x_1175, x_1177);\n  let x_1180 : vec3<f32> = f_1;\n  let x_1181 : vec3<f32> = *(halfHeight_1);\n  w = normalize(cross(x_1180, x_1181));\n  let x_1185 : vec3<f32> = f_1;\n  let x_1186 : vec3<f32> = w;\n  h_2 = normalize(cross(x_1185, x_1186));\n  let x_1189 : vec3<f32> = w;\n  let x_1190 : f32 = dSphereRadius;\n  let x_1192 : vec3<f32> = h_2;\n  let x_1193 : f32 = dSphereRadius;\n  let x_1196 : vec3<f32> = *(lightPos_1);\n  param_14 = x_1196;\n  param_15 = (x_1189 * x_1190);\n  param_16 = (x_1192 * x_1193);\n  let x_1199 : Coords = getLTCLightCoords_vf3_vf3_vf3_(&(param_14), &(param_15), &(param_16));\n  return x_1199;\n}\n\nfn calcSphereLightValues_vf3_vf3_vf3_(lightPos_4 : ptr<function, vec3<f32>>, halfWidth_4 : ptr<function, vec3<f32>>, halfHeight_4 : ptr<function, vec3<f32>>) {\n  var param_33 : vec3<f32>;\n  var param_34 : vec3<f32>;\n  var param_35 : vec3<f32>;\n  let x_1291 : vec3<f32> = *(lightPos_4);\n  param_33 = x_1291;\n  let x_1293 : vec3<f32> = *(halfWidth_4);\n  param_34 = x_1293;\n  let x_1295 : vec3<f32> = *(halfHeight_4);\n  param_35 = x_1295;\n  let x_1296 : Coords = getSphereLightCoords_vf3_vf3_vf3_(&(param_33), &(param_34), &(param_35));\n  dLTCCoords = x_1296;\n  return;\n}\n\nfn square_f1_(x : ptr<function, f32>) -> f32 {\n  let x_385 : f32 = *(x);\n  let x_386 : f32 = *(x);\n  return (x_385 * x_386);\n}\n\nfn getFalloffWindow_f1_vf3_(lightRadius : ptr<function, f32>, lightDir : ptr<function, vec3<f32>>) -> f32 {\n  var sqrDist : f32;\n  var invRadius : f32;\n  var param : f32;\n  var param_1 : f32;\n  var param_2 : f32;\n  var param_3 : f32;\n  let x_406 : vec3<f32> = *(lightDir);\n  let x_407 : vec3<f32> = *(lightDir);\n  sqrDist = dot(x_406, x_407);\n  let x_410 : f32 = *(lightRadius);\n  invRadius = (1.0f / x_410);\n  let x_412 : f32 = sqrDist;\n  let x_414 : f32 = invRadius;\n  param = x_414;\n  let x_415 : f32 = square_f1_(&(param));\n  param_1 = (x_412 * x_415);\n  let x_418 : f32 = square_f1_(&(param_1));\n  param_2 = (1.0f - x_418);\n  let x_421 : f32 = saturate_f1_(&(param_2));\n  param_3 = x_421;\n  let x_423 : f32 = square_f1_(&(param_3));\n  return x_423;\n}\n\nfn getFalloffLinear_f1_vf3_(lightRadius_2 : ptr<function, f32>, lightDir_2 : ptr<function, vec3<f32>>) -> f32 {\n  var d : f32;\n  let x_458 : vec3<f32> = *(lightDir_2);\n  d = length(x_458);\n  let x_460 : f32 = *(lightRadius_2);\n  let x_461 : f32 = d;\n  let x_463 : f32 = *(lightRadius_2);\n  return max(((x_460 - x_461) / x_463), 0.0f);\n}\n\nfn getFalloffInvSquared_f1_vf3_(lightRadius_1 : ptr<function, f32>, lightDir_1 : ptr<function, vec3<f32>>) -> f32 {\n  var sqrDist_1 : f32;\n  var falloff : f32;\n  var invRadius_1 : f32;\n  var param_4 : f32;\n  var param_5 : f32;\n  var param_6 : f32;\n  var param_7 : f32;\n  let x_427 : vec3<f32> = *(lightDir_1);\n  let x_428 : vec3<f32> = *(lightDir_1);\n  sqrDist_1 = dot(x_427, x_428);\n  let x_431 : f32 = sqrDist_1;\n  falloff = (1.0f / (x_431 + 1.0f));\n  let x_435 : f32 = *(lightRadius_1);\n  invRadius_1 = (1.0f / x_435);\n  let x_438 : f32 = falloff;\n  falloff = (x_438 * 16.0f);\n  let x_440 : f32 = sqrDist_1;\n  let x_442 : f32 = invRadius_1;\n  param_4 = x_442;\n  let x_443 : f32 = square_f1_(&(param_4));\n  param_5 = (x_440 * x_443);\n  let x_446 : f32 = square_f1_(&(param_5));\n  param_6 = (1.0f - x_446);\n  let x_449 : f32 = saturate_f1_(&(param_6));\n  param_7 = x_449;\n  let x_451 : f32 = square_f1_(&(param_7));\n  let x_452 : f32 = falloff;\n  falloff = (x_452 * x_451);\n  let x_454 : f32 = falloff;\n  return x_454;\n}\n\nfn transposeMat3_mf33_(m : mat3x3<f32>) -> mat3x3<f32> {\n  var tmp : mat3x3<f32>;\n  tmp[0i] = vec3<f32>(m[0u].x, m[1u].x, m[2u].x);\n  tmp[1i] = vec3<f32>(m[0u].y, m[1u].y, m[2u].y);\n  tmp[2i] = vec3<f32>(m[0u].z, m[1u].z, m[2u].z);\n  let x_927 : mat3x3<f32> = tmp;\n  return x_927;\n}\n\nfn LTC_EdgeVectorFormFactor_vf3_vf3_(v1 : vec3<f32>, v2 : vec3<f32>) -> vec3<f32> {\n  var x_3 : f32;\n  var y : f32;\n  var a : f32;\n  var b : f32;\n  var v : f32;\n  var theta_sintheta : f32;\n  var x_991 : f32;\n  x_3 = dot(v1, v2);\n  let x_964 : f32 = x_3;\n  y = abs(x_964);\n  let x_970 : f32 = y;\n  let x_973 : f32 = y;\n  a = (0.854398489f + ((0.496515512f + (0.0145206f * x_970)) * x_973));\n  let x_979 : f32 = y;\n  let x_981 : f32 = y;\n  b = (3.417593956f + ((4.161672592f + x_979) * x_981));\n  let x_985 : f32 = a;\n  let x_986 : f32 = b;\n  v = (x_985 / x_986);\n  let x_989 : f32 = x_3;\n  if ((x_989 > 0.0f)) {\n    let x_994 : f32 = v;\n    x_991 = x_994;\n  } else {\n    let x_997 : f32 = x_3;\n    let x_998 : f32 = x_3;\n    let x_1004 : f32 = v;\n    x_991 = ((0.5f * inverseSqrt(max((1.0f - (x_997 * x_998)), 0.0000001f))) - x_1004);\n  }\n  let x_1006 : f32 = x_991;\n  theta_sintheta = x_1006;\n  let x_1008 : f32 = theta_sintheta;\n  return (cross(v1, v2) * x_1008);\n}\n\nfn LTC_ClippedSphereFormFactor_vf3_(f : vec3<f32>) -> f32 {\n  var l : f32;\n  l = length(f);\n  let x_950 : f32 = l;\n  let x_951 : f32 = l;\n  let x_955 : f32 = l;\n  return max((((x_950 * x_951) + f.z) / (x_955 + 1.0f)), 0.0f);\n}\n\nfn LTC_EvaluateRect_vf3_vf3_vf3_mf33_struct_Coords_vf3_vf3_vf3_vf31_(N_1 : vec3<f32>, V_1 : vec3<f32>, P : vec3<f32>, mInv : mat3x3<f32>, rectCoords : Coords) -> f32 {\n  var v1_1 : vec3<f32>;\n  var v2_1 : vec3<f32>;\n  var lightNormal : vec3<f32>;\n  var factor : f32;\n  var T1 : vec3<f32>;\n  var T2 : vec3<f32>;\n  var mat : mat3x3<f32>;\n  var coords : array<vec3<f32>, 4u>;\n  var vectorFormFactor : vec3<f32>;\n  var result : f32;\n  v1_1 = (rectCoords.coord1 - rectCoords.coord0);\n  v2_1 = (rectCoords.coord3 - rectCoords.coord0);\n  let x_1022 : vec3<f32> = v1_1;\n  let x_1023 : vec3<f32> = v2_1;\n  lightNormal = cross(x_1022, x_1023);\n  let x_1026 : vec3<f32> = lightNormal;\n  factor = sign(-(dot(x_1026, (P - rectCoords.coord0))));\n  T1 = normalize((V_1 - (N_1 * dot(V_1, N_1))));\n  let x_1038 : f32 = factor;\n  let x_1039 : vec3<f32> = T1;\n  T2 = (cross(N_1, x_1039) * x_1038);\n  let x_1043 : vec3<f32> = T1;\n  let x_1044 : vec3<f32> = T2;\n  let x_1058 : mat3x3<f32> = transposeMat3_mf33_(mat3x3<f32>(vec3<f32>(x_1043.x, x_1043.y, x_1043.z), vec3<f32>(x_1044.x, x_1044.y, x_1044.z), vec3<f32>(N_1.x, N_1.y, N_1.z)));\n  mat = (mInv * x_1058);\n  let x_1064 : mat3x3<f32> = mat;\n  coords[0i] = (x_1064 * (rectCoords.coord0 - P));\n  let x_1069 : mat3x3<f32> = mat;\n  coords[1i] = (x_1069 * (rectCoords.coord1 - P));\n  let x_1074 : mat3x3<f32> = mat;\n  coords[2i] = (x_1074 * (rectCoords.coord2 - P));\n  let x_1079 : mat3x3<f32> = mat;\n  coords[3i] = (x_1079 * (rectCoords.coord3 - P));\n  let x_1085 : vec3<f32> = coords[0i];\n  coords[0i] = normalize(x_1085);\n  let x_1089 : vec3<f32> = coords[1i];\n  coords[1i] = normalize(x_1089);\n  let x_1093 : vec3<f32> = coords[2i];\n  coords[2i] = normalize(x_1093);\n  let x_1097 : vec3<f32> = coords[3i];\n  coords[3i] = normalize(x_1097);\n  vectorFormFactor = vec3<f32>(0.0f, 0.0f, 0.0f);\n  let x_1103 : vec3<f32> = coords[0i];\n  let x_1105 : vec3<f32> = coords[1i];\n  let x_1106 : vec3<f32> = LTC_EdgeVectorFormFactor_vf3_vf3_(x_1103, x_1105);\n  let x_1107 : vec3<f32> = vectorFormFactor;\n  vectorFormFactor = (x_1107 + x_1106);\n  let x_1110 : vec3<f32> = coords[1i];\n  let x_1112 : vec3<f32> = coords[2i];\n  let x_1113 : vec3<f32> = LTC_EdgeVectorFormFactor_vf3_vf3_(x_1110, x_1112);\n  let x_1114 : vec3<f32> = vectorFormFactor;\n  vectorFormFactor = (x_1114 + x_1113);\n  let x_1117 : vec3<f32> = coords[2i];\n  let x_1119 : vec3<f32> = coords[3i];\n  let x_1120 : vec3<f32> = LTC_EdgeVectorFormFactor_vf3_vf3_(x_1117, x_1119);\n  let x_1121 : vec3<f32> = vectorFormFactor;\n  vectorFormFactor = (x_1121 + x_1120);\n  let x_1124 : vec3<f32> = coords[3i];\n  let x_1126 : vec3<f32> = coords[0i];\n  let x_1127 : vec3<f32> = LTC_EdgeVectorFormFactor_vf3_vf3_(x_1124, x_1126);\n  let x_1128 : vec3<f32> = vectorFormFactor;\n  vectorFormFactor = (x_1128 + x_1127);\n  let x_1131 : vec3<f32> = vectorFormFactor;\n  let x_1132 : f32 = LTC_ClippedSphereFormFactor_vf3_(x_1131);\n  result = x_1132;\n  let x_1133 : f32 = result;\n  return x_1133;\n}\n\nfn getRectLightDiffuse_vf3_vf3_vf3_vf3_(worldNormal_4 : ptr<function, vec3<f32>>, viewDir_4 : ptr<function, vec3<f32>>, lightDir_4 : ptr<function, vec3<f32>>, lightDirNorm_2 : ptr<function, vec3<f32>>) -> f32 {\n  let x_2000 : vec3<f32> = *(worldNormal_4);\n  let x_2001 : vec3<f32> = *(viewDir_4);\n  let x_2002 : vec3<f32> = vPositionW;\n  let x_2006 : Coords = dLTCCoords;\n  let x_2007 : f32 = LTC_EvaluateRect_vf3_vf3_vf3_mf33_struct_Coords_vf3_vf3_vf3_vf31_(x_2000, x_2001, x_2002, mat3x3<f32>(vec3<f32>(1.0f, 0.0f, 0.0f), vec3<f32>(0.0f, 1.0f, 0.0f), vec3<f32>(0.0f, 0.0f, 1.0f)), x_2006);\n  return x_2007;\n}\n\nfn SolveCubic_vf4_(Coefficient : ptr<function, vec4<f32>>) -> vec3<f32> {\n  var pi : f32;\n  var A : f32;\n  var B_1 : f32;\n  var C : f32;\n  var D : f32;\n  var Delta : vec3<f32>;\n  var Discriminant : f32;\n  var A_a : f32;\n  var C_a : f32;\n  var D_a : f32;\n  var Theta : f32;\n  var x_1a : f32;\n  var x_3a : f32;\n  var xl : f32;\n  var xlc : vec2<f32>;\n  var A_d : f32;\n  var C_d : f32;\n  var D_d : f32;\n  var Theta_1 : f32;\n  var x_1d : f32;\n  var x_3d : f32;\n  var xs : f32;\n  var xsc : vec2<f32>;\n  var E : f32;\n  var F : f32;\n  var G : f32;\n  var xmc : vec2<f32>;\n  var Root : vec3<f32>;\n  var x_1561 : bool;\n  var x_1562 : bool;\n  pi = 3.141590118f;\n  let x_1301 : f32 = (*(Coefficient)).w;\n  let x_1302 : vec4<f32> = *(Coefficient);\n  let x_1305 : vec3<f32> = (vec3<f32>(x_1302.x, x_1302.y, x_1302.z) / vec3<f32>(x_1301, x_1301, x_1301));\n  let x_1306 : vec4<f32> = *(Coefficient);\n  *(Coefficient) = vec4<f32>(x_1305.x, x_1305.y, x_1305.z, x_1306.w);\n  let x_1309 : vec4<f32> = *(Coefficient);\n  let x_1312 : vec2<f32> = (vec2<f32>(x_1309.y, x_1309.z) / vec2<f32>(3.0f, 3.0f));\n  let x_1313 : vec4<f32> = *(Coefficient);\n  *(Coefficient) = vec4<f32>(x_1313.x, x_1312.x, x_1312.y, x_1313.w);\n  let x_1317 : f32 = (*(Coefficient)).w;\n  A = x_1317;\n  let x_1320 : f32 = (*(Coefficient)).z;\n  B_1 = x_1320;\n  let x_1323 : f32 = (*(Coefficient)).y;\n  C = x_1323;\n  let x_1326 : f32 = (*(Coefficient)).x;\n  D = x_1326;\n  let x_1329 : f32 = (*(Coefficient)).z;\n  let x_1332 : f32 = (*(Coefficient)).z;\n  let x_1335 : f32 = (*(Coefficient)).y;\n  let x_1338 : f32 = (*(Coefficient)).y;\n  let x_1341 : f32 = (*(Coefficient)).z;\n  let x_1344 : f32 = (*(Coefficient)).x;\n  let x_1347 : f32 = (*(Coefficient)).z;\n  let x_1349 : f32 = (*(Coefficient)).y;\n  let x_1352 : vec4<f32> = *(Coefficient);\n  Delta = vec3<f32>(((-(x_1329) * x_1332) + x_1335), ((-(x_1338) * x_1341) + x_1344), dot(vec2<f32>(x_1347, -(x_1349)), vec2<f32>(x_1352.x, x_1352.y)));\n  let x_1359 : f32 = Delta.x;\n  let x_1362 : f32 = Delta.y;\n  let x_1365 : vec3<f32> = Delta;\n  Discriminant = dot(vec2<f32>((4.0f * x_1359), -(x_1362)), vec2<f32>(x_1365.z, x_1365.y));\n  A_a = 1.0f;\n  let x_1371 : f32 = Delta.x;\n  C_a = x_1371;\n  let x_1374 : f32 = B_1;\n  let x_1377 : f32 = Delta.x;\n  let x_1380 : f32 = Delta.y;\n  D_a = (((-2.0f * x_1374) * x_1377) + x_1380);\n  let x_1383 : f32 = Discriminant;\n  let x_1385 : f32 = D_a;\n  Theta = (atan2(sqrt(x_1383), -(x_1385)) / 3.0f);\n  let x_1390 : f32 = C_a;\n  let x_1394 : f32 = Theta;\n  x_1a = ((2.0f * sqrt(-(x_1390))) * cos(x_1394));\n  let x_1398 : f32 = C_a;\n  let x_1402 : f32 = Theta;\n  let x_1404 : f32 = pi;\n  x_3a = ((2.0f * sqrt(-(x_1398))) * cos((x_1402 + (0.666666687f * x_1404))));\n  let x_1409 : f32 = x_1a;\n  let x_1410 : f32 = x_3a;\n  let x_1412 : f32 = B_1;\n  if (((x_1409 + x_1410) > (2.0f * x_1412))) {\n    let x_1418 : f32 = x_1a;\n    xl = x_1418;\n  } else {\n    let x_1420 : f32 = x_3a;\n    xl = x_1420;\n  }\n  let x_1422 : f32 = xl;\n  let x_1423 : f32 = B_1;\n  let x_1425 : f32 = A;\n  xlc = vec2<f32>((x_1422 - x_1423), x_1425);\n  let x_1428 : f32 = D;\n  A_d = x_1428;\n  let x_1431 : f32 = Delta.z;\n  C_d = x_1431;\n  let x_1433 : f32 = D;\n  let x_1436 : f32 = Delta.y;\n  let x_1438 : f32 = C;\n  let x_1441 : f32 = Delta.z;\n  D_d = ((-(x_1433) * x_1436) + ((2.0f * x_1438) * x_1441));\n  let x_1445 : f32 = D;\n  let x_1446 : f32 = Discriminant;\n  let x_1449 : f32 = D_d;\n  Theta_1 = (atan2((x_1445 * sqrt(x_1446)), -(x_1449)) / 3.0f);\n  let x_1454 : f32 = C_d;\n  let x_1458 : f32 = Theta_1;\n  x_1d = ((2.0f * sqrt(-(x_1454))) * cos(x_1458));\n  let x_1462 : f32 = C_d;\n  let x_1466 : f32 = Theta_1;\n  let x_1467 : f32 = pi;\n  x_3d = ((2.0f * sqrt(-(x_1462))) * cos((x_1466 + (0.666666687f * x_1467))));\n  let x_1472 : f32 = x_1d;\n  let x_1473 : f32 = x_3d;\n  let x_1475 : f32 = C;\n  if (((x_1472 + x_1473) < (2.0f * x_1475))) {\n    let x_1481 : f32 = x_1d;\n    xs = x_1481;\n  } else {\n    let x_1483 : f32 = x_3d;\n    xs = x_1483;\n  }\n  let x_1485 : f32 = D;\n  let x_1487 : f32 = xs;\n  let x_1488 : f32 = C;\n  xsc = vec2<f32>(-(x_1485), (x_1487 + x_1488));\n  let x_1493 : f32 = xlc.y;\n  let x_1495 : f32 = xsc.y;\n  E = (x_1493 * x_1495);\n  let x_1499 : f32 = xlc.x;\n  let x_1502 : f32 = xsc.y;\n  let x_1505 : f32 = xlc.y;\n  let x_1507 : f32 = xsc.x;\n  F = ((-(x_1499) * x_1502) - (x_1505 * x_1507));\n  let x_1512 : f32 = xlc.x;\n  let x_1514 : f32 = xsc.x;\n  G = (x_1512 * x_1514);\n  let x_1517 : f32 = C;\n  let x_1518 : f32 = F;\n  let x_1520 : f32 = B_1;\n  let x_1521 : f32 = G;\n  let x_1524 : f32 = B_1;\n  let x_1526 : f32 = F;\n  let x_1528 : f32 = C;\n  let x_1529 : f32 = E;\n  xmc = vec2<f32>(((x_1517 * x_1518) - (x_1520 * x_1521)), ((-(x_1524) * x_1526) + (x_1528 * x_1529)));\n  let x_1535 : f32 = xsc.x;\n  let x_1537 : f32 = xsc.y;\n  let x_1540 : f32 = xmc.x;\n  let x_1542 : f32 = xmc.y;\n  let x_1545 : f32 = xlc.x;\n  let x_1547 : f32 = xlc.y;\n  Root = vec3<f32>((x_1535 / x_1537), (x_1540 / x_1542), (x_1545 / x_1547));\n  let x_1551 : f32 = Root.x;\n  let x_1553 : f32 = Root.y;\n  let x_1554 : bool = (x_1551 < x_1553);\n  x_1562 = x_1554;\n  if (x_1554) {\n    let x_1558 : f32 = Root.x;\n    let x_1560 : f32 = Root.z;\n    x_1561 = (x_1558 < x_1560);\n    x_1562 = x_1561;\n  }\n  var x_1579 : bool;\n  var x_1580 : bool;\n  if (x_1562) {\n    let x_1565 : vec3<f32> = Root;\n    Root = vec3<f32>(x_1565.y, x_1565.x, x_1565.z);\n  } else {\n    let x_1569 : f32 = Root.z;\n    let x_1571 : f32 = Root.x;\n    let x_1572 : bool = (x_1569 < x_1571);\n    x_1580 = x_1572;\n    if (x_1572) {\n      let x_1576 : f32 = Root.z;\n      let x_1578 : f32 = Root.y;\n      x_1579 = (x_1576 < x_1578);\n      x_1580 = x_1579;\n    }\n    if (x_1580) {\n      let x_1583 : vec3<f32> = Root;\n      Root = vec3<f32>(x_1583.x, x_1583.z, x_1583.y);\n    }\n  }\n  let x_1585 : vec3<f32> = Root;\n  return x_1585;\n}\n\nfn LTC_EvaluateDisk_vf3_vf3_vf3_mf33_struct_Coords_vf3_vf3_vf3_vf31_(N_2 : ptr<function, vec3<f32>>, V_2 : ptr<function, vec3<f32>>, P_1 : ptr<function, vec3<f32>>, Minv : ptr<function, mat3x3<f32>>, points : ptr<function, Coords>) -> f32 {\n  var T1_1 : vec3<f32>;\n  var T2_1 : vec3<f32>;\n  var R : mat3x3<f32>;\n  var L_ : array<vec3<f32>, 3u>;\n  var Lo_i : vec3<f32>;\n  var C_1 : vec3<f32>;\n  var V1 : vec3<f32>;\n  var V2 : vec3<f32>;\n  var d11 : f32;\n  var d22 : f32;\n  var d12 : f32;\n  var tr : f32;\n  var det : f32;\n  var u : f32;\n  var v_1 : f32;\n  var e_max : f32;\n  var e_min : f32;\n  var V1_ : vec3<f32>;\n  var V2_ : vec3<f32>;\n  var a_1 : f32;\n  var b_1 : f32;\n  var V3 : vec3<f32>;\n  var L : f32;\n  var x0 : f32;\n  var y0 : f32;\n  var E1 : f32;\n  var E2 : f32;\n  var c0 : f32;\n  var c1 : f32;\n  var c2 : f32;\n  var c3 : f32;\n  var roots : vec3<f32>;\n  var param_36 : vec4<f32>;\n  var e1 : f32;\n  var e2 : f32;\n  var e3 : f32;\n  var avgDir : vec3<f32>;\n  var rotate : mat3x3<f32>;\n  var L1 : f32;\n  var L2 : f32;\n  var formFactor : f32;\n  var uv_6 : vec2<f32>;\n  var scale : f32;\n  let x_1589 : vec3<f32> = *(V_2);\n  let x_1590 : vec3<f32> = *(N_2);\n  let x_1591 : vec3<f32> = *(V_2);\n  let x_1592 : vec3<f32> = *(N_2);\n  T1_1 = normalize((x_1589 - (x_1590 * dot(x_1591, x_1592))));\n  let x_1598 : vec3<f32> = *(N_2);\n  let x_1599 : vec3<f32> = T1_1;\n  T2_1 = cross(x_1598, x_1599);\n  let x_1602 : vec3<f32> = T1_1;\n  let x_1603 : vec3<f32> = T2_1;\n  let x_1604 : vec3<f32> = *(N_2);\n  let x_1618 : mat3x3<f32> = transposeMat3_mf33_(mat3x3<f32>(vec3<f32>(x_1602.x, x_1602.y, x_1602.z), vec3<f32>(x_1603.x, x_1603.y, x_1603.z), vec3<f32>(x_1604.x, x_1604.y, x_1604.z)));\n  R = x_1618;\n  let x_1622 : mat3x3<f32> = R;\n  let x_1624 : vec3<f32> = (*(points)).coord0;\n  let x_1625 : vec3<f32> = *(P_1);\n  L_[0i] = (x_1622 * (x_1624 - x_1625));\n  let x_1629 : mat3x3<f32> = R;\n  let x_1631 : vec3<f32> = (*(points)).coord1;\n  let x_1632 : vec3<f32> = *(P_1);\n  L_[1i] = (x_1629 * (x_1631 - x_1632));\n  let x_1636 : mat3x3<f32> = R;\n  let x_1638 : vec3<f32> = (*(points)).coord2;\n  let x_1639 : vec3<f32> = *(P_1);\n  L_[2i] = (x_1636 * (x_1638 - x_1639));\n  Lo_i = vec3<f32>(0.0f, 0.0f, 0.0f);\n  let x_1646 : vec3<f32> = L_[0i];\n  let x_1648 : vec3<f32> = L_[2i];\n  C_1 = ((x_1646 + x_1648) * 0.5f);\n  let x_1653 : vec3<f32> = L_[1i];\n  let x_1655 : vec3<f32> = L_[2i];\n  V1 = ((x_1653 - x_1655) * 0.5f);\n  let x_1660 : vec3<f32> = L_[1i];\n  let x_1662 : vec3<f32> = L_[0i];\n  V2 = ((x_1660 - x_1662) * 0.5f);\n  let x_1665 : mat3x3<f32> = *(Minv);\n  let x_1666 : vec3<f32> = C_1;\n  C_1 = (x_1665 * x_1666);\n  let x_1668 : mat3x3<f32> = *(Minv);\n  let x_1669 : vec3<f32> = V1;\n  V1 = (x_1668 * x_1669);\n  let x_1671 : mat3x3<f32> = *(Minv);\n  let x_1672 : vec3<f32> = V2;\n  V2 = (x_1671 * x_1672);\n  let x_1675 : vec3<f32> = V1;\n  let x_1676 : vec3<f32> = V1;\n  d11 = dot(x_1675, x_1676);\n  let x_1679 : vec3<f32> = V2;\n  let x_1680 : vec3<f32> = V2;\n  d22 = dot(x_1679, x_1680);\n  let x_1683 : vec3<f32> = V1;\n  let x_1684 : vec3<f32> = V2;\n  d12 = dot(x_1683, x_1684);\n  let x_1686 : f32 = d12;\n  let x_1688 : f32 = d11;\n  let x_1689 : f32 = d22;\n  if (((abs(x_1686) / sqrt((x_1688 * x_1689))) > 0.0001f)) {\n    let x_1698 : f32 = d11;\n    let x_1699 : f32 = d22;\n    tr = (x_1698 + x_1699);\n    let x_1702 : f32 = d12;\n    let x_1704 : f32 = d12;\n    let x_1706 : f32 = d11;\n    let x_1707 : f32 = d22;\n    det = ((-(x_1702) * x_1704) + (x_1706 * x_1707));\n    let x_1710 : f32 = det;\n    det = sqrt(x_1710);\n    let x_1713 : f32 = tr;\n    let x_1714 : f32 = det;\n    u = (0.5f * sqrt((x_1713 - (2.0f * x_1714))));\n    let x_1720 : f32 = tr;\n    let x_1721 : f32 = det;\n    v_1 = (0.5f * sqrt((x_1720 + (2.0f * x_1721))));\n    let x_1727 : f32 = u;\n    let x_1728 : f32 = v_1;\n    let x_1730 : f32 = u;\n    let x_1731 : f32 = v_1;\n    e_max = ((x_1727 + x_1728) * (x_1730 + x_1731));\n    let x_1735 : f32 = u;\n    let x_1736 : f32 = v_1;\n    let x_1738 : f32 = u;\n    let x_1739 : f32 = v_1;\n    e_min = ((x_1735 - x_1736) * (x_1738 - x_1739));\n    let x_1742 : f32 = d11;\n    let x_1743 : f32 = d22;\n    if ((x_1742 > x_1743)) {\n      let x_1748 : f32 = d12;\n      let x_1749 : vec3<f32> = V1;\n      let x_1751 : f32 = e_max;\n      let x_1752 : f32 = d11;\n      let x_1754 : vec3<f32> = V2;\n      V1_ = ((x_1749 * x_1748) + (x_1754 * (x_1751 - x_1752)));\n      let x_1758 : f32 = d12;\n      let x_1759 : vec3<f32> = V1;\n      let x_1761 : f32 = e_min;\n      let x_1762 : f32 = d11;\n      let x_1764 : vec3<f32> = V2;\n      V2_ = ((x_1759 * x_1758) + (x_1764 * (x_1761 - x_1762)));\n    } else {\n      let x_1768 : f32 = d12;\n      let x_1769 : vec3<f32> = V2;\n      let x_1771 : f32 = e_max;\n      let x_1772 : f32 = d22;\n      let x_1774 : vec3<f32> = V1;\n      V1_ = ((x_1769 * x_1768) + (x_1774 * (x_1771 - x_1772)));\n      let x_1777 : f32 = d12;\n      let x_1778 : vec3<f32> = V2;\n      let x_1780 : f32 = e_min;\n      let x_1781 : f32 = d22;\n      let x_1783 : vec3<f32> = V1;\n      V2_ = ((x_1778 * x_1777) + (x_1783 * (x_1780 - x_1781)));\n    }\n    let x_1787 : f32 = e_max;\n    a_1 = (1.0f / x_1787);\n    let x_1790 : f32 = e_min;\n    b_1 = (1.0f / x_1790);\n    let x_1792 : vec3<f32> = V1_;\n    V1 = normalize(x_1792);\n    let x_1794 : vec3<f32> = V2_;\n    V2 = normalize(x_1794);\n  } else {\n    let x_1797 : vec3<f32> = V1;\n    let x_1798 : vec3<f32> = V1;\n    a_1 = (1.0f / dot(x_1797, x_1798));\n    let x_1801 : vec3<f32> = V2;\n    let x_1802 : vec3<f32> = V2;\n    b_1 = (1.0f / dot(x_1801, x_1802));\n    let x_1805 : f32 = a_1;\n    let x_1807 : vec3<f32> = V1;\n    V1 = (x_1807 * sqrt(x_1805));\n    let x_1809 : f32 = b_1;\n    let x_1811 : vec3<f32> = V2;\n    V2 = (x_1811 * sqrt(x_1809));\n  }\n  let x_1814 : vec3<f32> = V1;\n  let x_1815 : vec3<f32> = V2;\n  V3 = cross(x_1814, x_1815);\n  let x_1817 : vec3<f32> = C_1;\n  let x_1818 : vec3<f32> = V3;\n  if ((dot(x_1817, x_1818) < 0.0f)) {\n    let x_1824 : vec3<f32> = V3;\n    V3 = (x_1824 * -1.0f);\n  }\n  let x_1827 : vec3<f32> = V3;\n  let x_1828 : vec3<f32> = C_1;\n  L = dot(x_1827, x_1828);\n  let x_1831 : vec3<f32> = V1;\n  let x_1832 : vec3<f32> = C_1;\n  let x_1834 : f32 = L;\n  x0 = (dot(x_1831, x_1832) / x_1834);\n  let x_1837 : vec3<f32> = V2;\n  let x_1838 : vec3<f32> = C_1;\n  let x_1840 : f32 = L;\n  y0 = (dot(x_1837, x_1838) / x_1840);\n  let x_1843 : f32 = a_1;\n  E1 = inverseSqrt(x_1843);\n  let x_1846 : f32 = b_1;\n  E2 = inverseSqrt(x_1846);\n  let x_1848 : f32 = L;\n  let x_1849 : f32 = L;\n  let x_1851 : f32 = a_1;\n  a_1 = (x_1851 * (x_1848 * x_1849));\n  let x_1853 : f32 = L;\n  let x_1854 : f32 = L;\n  let x_1856 : f32 = b_1;\n  b_1 = (x_1856 * (x_1853 * x_1854));\n  let x_1859 : f32 = a_1;\n  let x_1860 : f32 = b_1;\n  c0 = (x_1859 * x_1860);\n  let x_1863 : f32 = a_1;\n  let x_1864 : f32 = b_1;\n  let x_1866 : f32 = x0;\n  let x_1867 : f32 = x0;\n  let x_1870 : f32 = y0;\n  let x_1871 : f32 = y0;\n  let x_1875 : f32 = a_1;\n  let x_1877 : f32 = b_1;\n  c1 = ((((x_1863 * x_1864) * ((1.0f + (x_1866 * x_1867)) + (x_1870 * x_1871))) - x_1875) - x_1877);\n  let x_1880 : f32 = a_1;\n  let x_1881 : f32 = x0;\n  let x_1882 : f32 = x0;\n  let x_1887 : f32 = b_1;\n  let x_1888 : f32 = y0;\n  let x_1889 : f32 = y0;\n  c2 = ((1.0f - (x_1880 * (1.0f + (x_1881 * x_1882)))) - (x_1887 * (1.0f + (x_1888 * x_1889))));\n  c3 = 1.0f;\n  let x_1896 : f32 = c0;\n  let x_1897 : f32 = c1;\n  let x_1898 : f32 = c2;\n  let x_1899 : f32 = c3;\n  param_36 = vec4<f32>(x_1896, x_1897, x_1898, x_1899);\n  let x_1902 : vec3<f32> = SolveCubic_vf4_(&(param_36));\n  roots = x_1902;\n  let x_1905 : f32 = roots.x;\n  e1 = x_1905;\n  let x_1908 : f32 = roots.y;\n  e2 = x_1908;\n  let x_1911 : f32 = roots.z;\n  e3 = x_1911;\n  let x_1913 : f32 = a_1;\n  let x_1914 : f32 = x0;\n  let x_1916 : f32 = a_1;\n  let x_1917 : f32 = e2;\n  let x_1920 : f32 = b_1;\n  let x_1921 : f32 = y0;\n  let x_1923 : f32 = b_1;\n  let x_1924 : f32 = e2;\n  avgDir = vec3<f32>(((x_1913 * x_1914) / (x_1916 - x_1917)), ((x_1920 * x_1921) / (x_1923 - x_1924)), 1.0f);\n  let x_1929 : vec3<f32> = V1;\n  let x_1930 : vec3<f32> = V2;\n  let x_1931 : vec3<f32> = V3;\n  rotate = mat3x3<f32>(vec3<f32>(x_1929.x, x_1929.y, x_1929.z), vec3<f32>(x_1930.x, x_1930.y, x_1930.z), vec3<f32>(x_1931.x, x_1931.y, x_1931.z));\n  let x_1945 : mat3x3<f32> = rotate;\n  let x_1946 : vec3<f32> = avgDir;\n  avgDir = (x_1945 * x_1946);\n  let x_1948 : vec3<f32> = avgDir;\n  avgDir = normalize(x_1948);\n  let x_1951 : f32 = e2;\n  let x_1953 : f32 = e3;\n  L1 = sqrt((-(x_1951) / x_1953));\n  let x_1957 : f32 = e2;\n  let x_1959 : f32 = e1;\n  L2 = sqrt((-(x_1957) / x_1959));\n  let x_1963 : f32 = L1;\n  let x_1964 : f32 = L2;\n  let x_1966 : f32 = L1;\n  let x_1967 : f32 = L1;\n  let x_1970 : f32 = L2;\n  let x_1971 : f32 = L2;\n  formFactor = ((x_1963 * x_1964) * inverseSqrt(((1.0f + (x_1966 * x_1967)) * (1.0f + (x_1970 * x_1971)))));\n  let x_1979 : f32 = avgDir.z;\n  let x_1982 : f32 = formFactor;\n  uv_6 = vec2<f32>(((x_1979 * 0.5f) + 0.5f), x_1982);\n  let x_1984 : vec2<f32> = uv_6;\n  uv_6 = ((x_1984 * 0.984375f) + vec2<f32>(0.0078125f, 0.0078125f));\n  let x_1992 : vec2<f32> = uv_6;\n  let x_1993 : vec4<f32> = textureSampleLevel(areaLightsLutTex2, areaLightsLutTex2_sampler, x_1992, 0.0f);\n  scale = x_1993.w;\n  let x_1995 : f32 = formFactor;\n  let x_1996 : f32 = scale;\n  return (x_1995 * x_1996);\n}\n\nfn getDiskLightDiffuse_vf3_vf3_vf3_vf3_(worldNormal_5 : ptr<function, vec3<f32>>, viewDir_5 : ptr<function, vec3<f32>>, lightDir_5 : ptr<function, vec3<f32>>, lightDirNorm_3 : ptr<function, vec3<f32>>) -> f32 {\n  var param_37 : vec3<f32>;\n  var param_38 : vec3<f32>;\n  var param_39 : vec3<f32>;\n  var param_40 : mat3x3<f32>;\n  var param_41 : Coords;\n  let x_2011 : vec3<f32> = *(worldNormal_5);\n  param_37 = x_2011;\n  let x_2013 : vec3<f32> = *(viewDir_5);\n  param_38 = x_2013;\n  let x_2015 : vec3<f32> = vPositionW;\n  param_39 = x_2015;\n  param_40 = mat3x3<f32>(vec3<f32>(1.0f, 0.0f, 0.0f), vec3<f32>(0.0f, 1.0f, 0.0f), vec3<f32>(0.0f, 0.0f, 1.0f));\n  let x_2018 : Coords = dLTCCoords;\n  param_41 = x_2018;\n  let x_2019 : f32 = LTC_EvaluateDisk_vf3_vf3_vf3_mf33_struct_Coords_vf3_vf3_vf3_vf31_(&(param_37), &(param_38), &(param_39), &(param_40), &(param_41));\n  return x_2019;\n}\n\nfn getLightDiffuse_vf3_vf3_vf3_vf3_(worldNormal_1 : ptr<function, vec3<f32>>, viewDir_1 : ptr<function, vec3<f32>>, lightDir_3 : ptr<function, vec3<f32>>, lightDirNorm_1 : ptr<function, vec3<f32>>) -> f32 {\n  let x_904 : vec3<f32> = *(worldNormal_1);\n  let x_905 : vec3<f32> = *(lightDirNorm_1);\n  return max(dot(x_904, -(x_905)), 0.0f);\n}\n\nfn getSphereLightDiffuse_vf3_vf3_vf3_vf3_(worldNormal_6 : ptr<function, vec3<f32>>, viewDir_6 : ptr<function, vec3<f32>>, lightDir_6 : ptr<function, vec3<f32>>, lightDirNorm_4 : ptr<function, vec3<f32>>) -> f32 {\n  var falloff_1 : f32;\n  var param_42 : vec3<f32>;\n  var param_43 : vec3<f32>;\n  var param_44 : vec3<f32>;\n  var param_45 : vec3<f32>;\n  let x_2023 : f32 = dSphereRadius;\n  let x_2024 : vec3<f32> = *(lightDir_6);\n  let x_2025 : vec3<f32> = *(lightDir_6);\n  let x_2027 : f32 = dSphereRadius;\n  falloff_1 = (x_2023 / (dot(x_2024, x_2025) + x_2027));\n  let x_2031 : vec3<f32> = *(worldNormal_6);\n  param_42 = x_2031;\n  let x_2033 : vec3<f32> = *(viewDir_6);\n  param_43 = x_2033;\n  let x_2035 : vec3<f32> = *(lightDir_6);\n  param_44 = x_2035;\n  let x_2037 : vec3<f32> = *(lightDirNorm_4);\n  param_45 = x_2037;\n  let x_2038 : f32 = getLightDiffuse_vf3_vf3_vf3_vf3_(&(param_42), &(param_43), &(param_44), &(param_45));\n  let x_2039 : f32 = falloff_1;\n  return (x_2038 * x_2039);\n}\n\nfn decodeClusterLightSpot_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_(clusterLightData_3 : ptr<function, ClusterLightData>) {\n  var coneAngle : vec4<f32>;\n  var param_73 : i32;\n  var param_74 : vec2<f32>;\n  var param_75 : vec2<f32>;\n  let x_2313 : ClusterLightData = *(clusterLightData_3);\n  param_73 = 3i;\n  let x_2315 : vec4<f32> = sampleLightsTexture8_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_i1_(x_2313, &(param_73));\n  coneAngle = x_2315;\n  let x_2318 : vec4<f32> = coneAngle;\n  param_74 = vec2<f32>(x_2318.x, x_2318.y);\n  let x_2320 : f32 = bytes2float2_vf2_(&(param_74));\n  (*(clusterLightData_3)).innerConeAngleCos = ((x_2320 * 2.0f) - 1.0f);\n  let x_2326 : vec4<f32> = coneAngle;\n  param_75 = vec2<f32>(x_2326.z, x_2326.w);\n  let x_2328 : f32 = bytes2float2_vf2_(&(param_75));\n  (*(clusterLightData_3)).outerConeAngleCos = ((x_2328 * 2.0f) - 1.0f);\n  return;\n}\n\nfn getSpotEffect_vf3_f1_f1_vf3_(lightSpotDirW : ptr<function, vec3<f32>>, lightInnerConeAngle : ptr<function, f32>, lightOuterConeAngle : ptr<function, f32>, lightDirNorm : ptr<function, vec3<f32>>) -> f32 {\n  var cosAngle : f32;\n  let x_396 : vec3<f32> = *(lightDirNorm);\n  let x_397 : vec3<f32> = *(lightSpotDirW);\n  cosAngle = dot(x_396, x_397);\n  let x_399 : f32 = *(lightOuterConeAngle);\n  let x_400 : f32 = *(lightInnerConeAngle);\n  let x_401 : f32 = cosAngle;\n  return smoothstep(x_399, x_400, x_401);\n}\n\nfn getLTCLightInvMat_vf2_(uv_1 : ptr<function, vec2<f32>>) -> mat3x3<f32> {\n  var t1 : vec4<f32>;\n  let x_2049 : vec2<f32> = *(uv_1);\n  let x_2050 : vec4<f32> = textureSampleLevel(areaLightsLutTex1, areaLightsLutTex1_sampler, x_2049, 0.0f);\n  t1 = x_2050;\n  let x_2055 : vec4<f32> = t1;\n  t1 = (x_2055 * vec4<f32>(1.001000047f, 0.323900014f, 0.60437566f, 1.0f));\n  let x_2060 : vec4<f32> = t1;\n  t1 = (x_2060 + vec4<f32>(0.0f, -0.297600001f, -0.01381f, 0.0f));\n  let x_2063 : f32 = t1.x;\n  let x_2065 : f32 = t1.y;\n  let x_2066 : vec3<f32> = vec3<f32>(x_2063, 0.0f, x_2065);\n  let x_2068 : f32 = t1.z;\n  let x_2070 : f32 = t1.w;\n  let x_2071 : vec3<f32> = vec3<f32>(x_2068, 0.0f, x_2070);\n  return mat3x3<f32>(vec3<f32>(x_2066.x, x_2066.y, x_2066.z), vec3<f32>(vec3<f32>(0.0f, 1.0f, 0.0f).x, vec3<f32>(0.0f, 1.0f, 0.0f).y, vec3<f32>(0.0f, 1.0f, 0.0f).z), vec3<f32>(x_2071.x, x_2071.y, x_2071.z));\n}\n\nfn calcRectLightSpecular_vf3_vf3_vf2_(worldNormal_7 : ptr<function, vec3<f32>>, viewDir_7 : ptr<function, vec3<f32>>, uv_2 : ptr<function, vec2<f32>>) -> f32 {\n  var mInv_1 : mat3x3<f32>;\n  var param_46 : vec2<f32>;\n  let x_2089 : vec2<f32> = *(uv_2);\n  param_46 = x_2089;\n  let x_2090 : mat3x3<f32> = getLTCLightInvMat_vf2_(&(param_46));\n  mInv_1 = x_2090;\n  let x_2091 : vec3<f32> = *(worldNormal_7);\n  let x_2092 : vec3<f32> = *(viewDir_7);\n  let x_2093 : vec3<f32> = vPositionW;\n  let x_2094 : mat3x3<f32> = mInv_1;\n  let x_2095 : Coords = dLTCCoords;\n  let x_2096 : f32 = LTC_EvaluateRect_vf3_vf3_vf3_mf33_struct_Coords_vf3_vf3_vf3_vf31_(x_2091, x_2092, x_2093, x_2094, x_2095);\n  return x_2096;\n}\n\nfn getRectLightSpecular_vf3_vf3_(worldNormal_8 : ptr<function, vec3<f32>>, viewDir_8 : ptr<function, vec3<f32>>) -> f32 {\n  var param_47 : vec3<f32>;\n  var param_48 : vec3<f32>;\n  var param_49 : vec2<f32>;\n  let x_2100 : vec3<f32> = *(worldNormal_8);\n  param_47 = x_2100;\n  let x_2102 : vec3<f32> = *(viewDir_8);\n  param_48 = x_2102;\n  let x_2104 : vec2<f32> = dLTCUV;\n  param_49 = x_2104;\n  let x_2105 : f32 = calcRectLightSpecular_vf3_vf3_vf2_(&(param_47), &(param_48), &(param_49));\n  return x_2105;\n}\n\nfn calcDiskLightSpecular_vf3_vf3_vf2_(worldNormal_9 : ptr<function, vec3<f32>>, viewDir_9 : ptr<function, vec3<f32>>, uv_3 : ptr<function, vec2<f32>>) -> f32 {\n  var mInv_2 : mat3x3<f32>;\n  var param_50 : vec2<f32>;\n  var param_51 : vec3<f32>;\n  var param_52 : vec3<f32>;\n  var param_53 : vec3<f32>;\n  var param_54 : mat3x3<f32>;\n  var param_55 : Coords;\n  let x_2110 : vec2<f32> = *(uv_3);\n  param_50 = x_2110;\n  let x_2111 : mat3x3<f32> = getLTCLightInvMat_vf2_(&(param_50));\n  mInv_2 = x_2111;\n  let x_2113 : vec3<f32> = *(worldNormal_9);\n  param_51 = x_2113;\n  let x_2115 : vec3<f32> = *(viewDir_9);\n  param_52 = x_2115;\n  let x_2117 : vec3<f32> = vPositionW;\n  param_53 = x_2117;\n  let x_2119 : mat3x3<f32> = mInv_2;\n  param_54 = x_2119;\n  let x_2121 : Coords = dLTCCoords;\n  param_55 = x_2121;\n  let x_2122 : f32 = LTC_EvaluateDisk_vf3_vf3_vf3_mf33_struct_Coords_vf3_vf3_vf3_vf31_(&(param_51), &(param_52), &(param_53), &(param_54), &(param_55));\n  return x_2122;\n}\n\nfn getDiskLightSpecular_vf3_vf3_(worldNormal_10 : ptr<function, vec3<f32>>, viewDir_10 : ptr<function, vec3<f32>>) -> f32 {\n  var param_56 : vec3<f32>;\n  var param_57 : vec3<f32>;\n  var param_58 : vec2<f32>;\n  let x_2126 : vec3<f32> = *(worldNormal_10);\n  param_56 = x_2126;\n  let x_2128 : vec3<f32> = *(viewDir_10);\n  param_57 = x_2128;\n  let x_2130 : vec2<f32> = dLTCUV;\n  param_58 = x_2130;\n  let x_2131 : f32 = calcDiskLightSpecular_vf3_vf3_vf2_(&(param_56), &(param_57), &(param_58));\n  return x_2131;\n}\n\nfn getSphereLightSpecular_vf3_vf3_(worldNormal_11 : ptr<function, vec3<f32>>, viewDir_11 : ptr<function, vec3<f32>>) -> f32 {\n  var param_59 : vec3<f32>;\n  var param_60 : vec3<f32>;\n  var param_61 : vec2<f32>;\n  let x_2135 : vec3<f32> = *(worldNormal_11);\n  param_59 = x_2135;\n  let x_2137 : vec3<f32> = *(viewDir_11);\n  param_60 = x_2137;\n  let x_2139 : vec2<f32> = dLTCUV;\n  param_61 = x_2139;\n  let x_2140 : f32 = calcDiskLightSpecular_vf3_vf3_vf2_(&(param_59), &(param_60), &(param_61));\n  return x_2140;\n}\n\nfn calcLightSpecular_f1_vf3_vf3_(gloss_4 : ptr<function, f32>, worldNormal_12 : ptr<function, vec3<f32>>, h : ptr<function, vec3<f32>>) -> f32 {\n  var nh : f32;\n  var specPow : f32;\n  let x_2144 : vec3<f32> = *(h);\n  let x_2145 : vec3<f32> = *(worldNormal_12);\n  nh = max(dot(x_2144, x_2145), 0.0f);\n  let x_2149 : f32 = *(gloss_4);\n  specPow = exp2((x_2149 * 11.0f));\n  let x_2153 : f32 = specPow;\n  specPow = max(x_2153, 0.0001f);\n  let x_2155 : f32 = nh;\n  let x_2156 : f32 = specPow;\n  let x_2158 : f32 = specPow;\n  return ((pow(x_2155, x_2156) * (x_2158 + 2.0f)) / 8.0f);\n}\n\nfn getLightSpecular_vf3_vf3_vf3_vf3_vf3_f1_mf33_(h_1 : ptr<function, vec3<f32>>, reflDir : ptr<function, vec3<f32>>, worldNormal_13 : ptr<function, vec3<f32>>, viewDir_12 : ptr<function, vec3<f32>>, lightDirNorm_5 : ptr<function, vec3<f32>>, gloss_5 : ptr<function, f32>, tbn : ptr<function, mat3x3<f32>>) -> f32 {\n  var param_62 : f32;\n  var param_63 : vec3<f32>;\n  var param_64 : vec3<f32>;\n  let x_2166 : f32 = *(gloss_5);\n  param_62 = x_2166;\n  let x_2168 : vec3<f32> = *(worldNormal_13);\n  param_63 = x_2168;\n  let x_2170 : vec3<f32> = *(h_1);\n  param_64 = x_2170;\n  let x_2171 : f32 = calcLightSpecular_f1_vf3_vf3_(&(param_62), &(param_63), &(param_64));\n  return x_2171;\n}\n\nfn getFresnel_f1_f1_vf3_(cosTheta : ptr<function, f32>, gloss : ptr<function, f32>, specularity : ptr<function, vec3<f32>>) -> vec3<f32> {\n  var fresnel : f32;\n  var glossSq : f32;\n  var ret : vec3<f32>;\n  let x_856 : f32 = *(cosTheta);\n  fresnel = pow((1.0f - max(x_856, 0.0f)), 5.0f);\n  let x_862 : f32 = *(gloss);\n  let x_863 : f32 = *(gloss);\n  glossSq = (x_862 * x_863);\n  let x_866 : vec3<f32> = *(specularity);\n  let x_867 : f32 = glossSq;\n  let x_869 : vec3<f32> = *(specularity);\n  let x_871 : vec3<f32> = *(specularity);\n  let x_873 : f32 = fresnel;\n  ret = (x_866 + ((max(vec3<f32>(x_867, x_867, x_867), x_869) - x_871) * x_873));\n  let x_876 : vec3<f32> = ret;\n  return x_876;\n}\n\nfn getFresnelCC_f1_(cosTheta_1 : ptr<function, f32>) -> f32 {\n  var fresnel_1 : f32;\n  let x_880 : f32 = *(cosTheta_1);\n  fresnel_1 = pow((1.0f - max(x_880, 0.0f)), 5.0f);\n  let x_886 : f32 = fresnel_1;\n  return (0.039999999f + (0.959999979f * x_886));\n}\n\nfn evaluateLight_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_vf3_vf3_vf3_vf3_f1_vf3_vf3_mf33_struct_ClearcoatArgs_f1_f1_vf31_struct_SheenArgs_f1_vf31_struct_IridescenceArgs_f1_f11_(light : ptr<function, ClusterLightData>, worldNormal_16 : ptr<function, vec3<f32>>, viewDir_14 : ptr<function, vec3<f32>>, reflectionDir : ptr<function, vec3<f32>>, clearcoatReflectionDir : ptr<function, vec3<f32>>, gloss_7 : ptr<function, f32>, specularity_3 : ptr<function, vec3<f32>>, geometricNormal : ptr<function, vec3<f32>>, tbn_2 : ptr<function, mat3x3<f32>>, clearcoat : ptr<function, ClearcoatArgs>, sheen : ptr<function, SheenArgs>, iridescence : ptr<function, IridescenceArgs>) {\n  var cookieAttenuation : vec3<f32>;\n  var diffuseAttenuation : f32;\n  var falloffAttenuation : f32;\n  var param_78 : vec3<f32>;\n  var param_79 : ClusterLightData;\n  var param_80 : vec3<f32>;\n  var param_81 : vec3<f32>;\n  var param_82 : vec3<f32>;\n  var param_83 : vec3<f32>;\n  var param_84 : vec3<f32>;\n  var param_85 : vec3<f32>;\n  var param_86 : vec3<f32>;\n  var param_87 : vec3<f32>;\n  var param_88 : vec3<f32>;\n  var param_89 : f32;\n  var param_90 : vec3<f32>;\n  var param_91 : f32;\n  var param_92 : vec3<f32>;\n  var param_93 : f32;\n  var param_94 : vec3<f32>;\n  var param_95 : vec3<f32>;\n  var param_96 : vec3<f32>;\n  var param_97 : vec3<f32>;\n  var param_98 : vec3<f32>;\n  var param_99 : vec3<f32>;\n  var param_100 : vec3<f32>;\n  var param_101 : vec3<f32>;\n  var param_102 : vec3<f32>;\n  var param_103 : vec3<f32>;\n  var param_104 : vec3<f32>;\n  var param_105 : vec3<f32>;\n  var param_106 : vec3<f32>;\n  var param_107 : vec3<f32>;\n  var param_108 : vec3<f32>;\n  var param_109 : vec3<f32>;\n  var param_110 : vec3<f32>;\n  var param_111 : ClusterLightData;\n  var param_112 : vec3<f32>;\n  var param_113 : f32;\n  var param_114 : f32;\n  var param_115 : vec3<f32>;\n  var areaDiffuse : vec3<f32>;\n  var areaLightSpecular : f32;\n  var param_116 : vec3<f32>;\n  var param_117 : vec3<f32>;\n  var param_118 : vec3<f32>;\n  var param_119 : vec3<f32>;\n  var param_120 : vec3<f32>;\n  var param_121 : vec3<f32>;\n  var areaLightSpecularCC : f32;\n  var param_122 : vec3<f32>;\n  var param_123 : vec3<f32>;\n  var param_124 : vec3<f32>;\n  var param_125 : vec3<f32>;\n  var param_126 : vec3<f32>;\n  var param_127 : vec3<f32>;\n  var punctualDiffuse : vec3<f32>;\n  var halfDir : vec3<f32>;\n  var param_128 : vec3<f32>;\n  var param_129 : vec3<f32>;\n  var param_130 : vec3<f32>;\n  var param_131 : vec3<f32>;\n  var param_132 : vec3<f32>;\n  var param_133 : f32;\n  var param_134 : mat3x3<f32>;\n  var param_135 : f32;\n  var param_136 : f32;\n  var param_137 : vec3<f32>;\n  var param_138 : vec3<f32>;\n  var param_139 : vec3<f32>;\n  var param_140 : vec3<f32>;\n  var param_141 : vec3<f32>;\n  var param_142 : vec3<f32>;\n  var param_143 : f32;\n  var param_144 : mat3x3<f32>;\n  var param_145 : f32;\n  cookieAttenuation = vec3<f32>(1.0f, 1.0f, 1.0f);\n  diffuseAttenuation = 1.0f;\n  falloffAttenuation = 1.0f;\n  let x_2347 : vec3<f32> = (*(light)).position;\n  param_78 = x_2347;\n  getLightDirPoint_vf3_(&(param_78));\n  let x_2350 : f32 = (*(light)).shape;\n  if ((x_2350 > 0.100000001f)) {\n    let x_2356 : ClusterLightData = *(light);\n    param_79 = x_2356;\n    decodeClusterLightAreaData_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_(&(param_79));\n    let x_2358 : ClusterLightData = param_79;\n    *(light) = x_2358;\n    let x_2360 : f32 = (*(light)).shape;\n    if ((x_2360 < 0.300000012f)) {\n      let x_2367 : vec3<f32> = (*(light)).position;\n      param_80 = x_2367;\n      let x_2370 : vec3<f32> = (*(light)).halfWidth;\n      param_81 = x_2370;\n      let x_2373 : vec3<f32> = (*(light)).halfHeight;\n      param_82 = x_2373;\n      calcRectLightValues_vf3_vf3_vf3_(&(param_80), &(param_81), &(param_82));\n    } else {\n      let x_2377 : f32 = (*(light)).shape;\n      if ((x_2377 < 0.600000024f)) {\n        let x_2384 : vec3<f32> = (*(light)).position;\n        param_83 = x_2384;\n        let x_2387 : vec3<f32> = (*(light)).halfWidth;\n        param_84 = x_2387;\n        let x_2390 : vec3<f32> = (*(light)).halfHeight;\n        param_85 = x_2390;\n        calcDiskLightValues_vf3_vf3_vf3_(&(param_83), &(param_84), &(param_85));\n      } else {\n        let x_2395 : vec3<f32> = (*(light)).position;\n        param_86 = x_2395;\n        let x_2398 : vec3<f32> = (*(light)).halfWidth;\n        param_87 = x_2398;\n        let x_2401 : vec3<f32> = (*(light)).halfHeight;\n        param_88 = x_2401;\n        calcSphereLightValues_vf3_vf3_vf3_(&(param_86), &(param_87), &(param_88));\n      }\n    }\n    let x_2405 : f32 = (*(light)).range;\n    param_89 = x_2405;\n    let x_2407 : vec3<f32> = dLightDirW;\n    param_90 = x_2407;\n    let x_2408 : f32 = getFalloffWindow_f1_vf3_(&(param_89), &(param_90));\n    falloffAttenuation = x_2408;\n  } else {\n    let x_2411 : f32 = (*(light)).falloffMode;\n    if ((x_2411 < 0.5f)) {\n      let x_2417 : f32 = (*(light)).range;\n      param_91 = x_2417;\n      let x_2419 : vec3<f32> = dLightDirW;\n      param_92 = x_2419;\n      let x_2420 : f32 = getFalloffLinear_f1_vf3_(&(param_91), &(param_92));\n      falloffAttenuation = x_2420;\n    } else {\n      let x_2424 : f32 = (*(light)).range;\n      param_93 = x_2424;\n      let x_2426 : vec3<f32> = dLightDirW;\n      param_94 = x_2426;\n      let x_2427 : f32 = getFalloffInvSquared_f1_vf3_(&(param_93), &(param_94));\n      falloffAttenuation = x_2427;\n    }\n  }\n  let x_2428 : f32 = falloffAttenuation;\n  if ((x_2428 > 0.00001f)) {\n    let x_2434 : f32 = (*(light)).shape;\n    if ((x_2434 > 0.100000001f)) {\n      let x_2439 : f32 = (*(light)).shape;\n      if ((x_2439 < 0.300000012f)) {\n        let x_2444 : vec3<f32> = *(worldNormal_16);\n        param_95 = x_2444;\n        let x_2446 : vec3<f32> = *(viewDir_14);\n        param_96 = x_2446;\n        let x_2448 : vec3<f32> = dLightDirW;\n        param_97 = x_2448;\n        let x_2450 : vec3<f32> = dLightDirNormW;\n        param_98 = x_2450;\n        let x_2451 : f32 = getRectLightDiffuse_vf3_vf3_vf3_vf3_(&(param_95), &(param_96), &(param_97), &(param_98));\n        diffuseAttenuation = (x_2451 * 16.0f);\n      } else {\n        let x_2455 : f32 = (*(light)).shape;\n        if ((x_2455 < 0.600000024f)) {\n          let x_2460 : vec3<f32> = *(worldNormal_16);\n          param_99 = x_2460;\n          let x_2462 : vec3<f32> = *(viewDir_14);\n          param_100 = x_2462;\n          let x_2464 : vec3<f32> = dLightDirW;\n          param_101 = x_2464;\n          let x_2466 : vec3<f32> = dLightDirNormW;\n          param_102 = x_2466;\n          let x_2467 : f32 = getDiskLightDiffuse_vf3_vf3_vf3_vf3_(&(param_99), &(param_100), &(param_101), &(param_102));\n          diffuseAttenuation = (x_2467 * 16.0f);\n        } else {\n          let x_2471 : vec3<f32> = *(worldNormal_16);\n          param_103 = x_2471;\n          let x_2473 : vec3<f32> = *(viewDir_14);\n          param_104 = x_2473;\n          let x_2475 : vec3<f32> = dLightDirW;\n          param_105 = x_2475;\n          let x_2477 : vec3<f32> = dLightDirNormW;\n          param_106 = x_2477;\n          let x_2478 : f32 = getSphereLightDiffuse_vf3_vf3_vf3_vf3_(&(param_103), &(param_104), &(param_105), &(param_106));\n          diffuseAttenuation = (x_2478 * 16.0f);\n        }\n      }\n    } else {\n      let x_2482 : vec3<f32> = *(worldNormal_16);\n      param_107 = x_2482;\n      let x_2484 : vec3<f32> = *(viewDir_14);\n      param_108 = x_2484;\n      let x_2486 : vec3<f32> = dLightDirW;\n      param_109 = x_2486;\n      let x_2488 : vec3<f32> = dLightDirNormW;\n      param_110 = x_2488;\n      let x_2489 : f32 = getLightDiffuse_vf3_vf3_vf3_vf3_(&(param_107), &(param_108), &(param_109), &(param_110));\n      let x_2490 : f32 = falloffAttenuation;\n      falloffAttenuation = (x_2490 * x_2489);\n    }\n    let x_2493 : f32 = (*(light)).lightType;\n    if ((x_2493 > 0.5f)) {\n      let x_2498 : ClusterLightData = *(light);\n      param_111 = x_2498;\n      decodeClusterLightSpot_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_(&(param_111));\n      let x_2500 : ClusterLightData = param_111;\n      *(light) = x_2500;\n      let x_2503 : vec3<f32> = (*(light)).direction;\n      param_112 = x_2503;\n      let x_2506 : f32 = (*(light)).innerConeAngleCos;\n      param_113 = x_2506;\n      let x_2509 : f32 = (*(light)).outerConeAngleCos;\n      param_114 = x_2509;\n      let x_2511 : vec3<f32> = dLightDirNormW;\n      param_115 = x_2511;\n      let x_2512 : f32 = getSpotEffect_vf3_f1_f1_vf3_(&(param_112), &(param_113), &(param_114), &(param_115));\n      let x_2513 : f32 = falloffAttenuation;\n      falloffAttenuation = (x_2513 * x_2512);\n    }\n    let x_2516 : f32 = (*(light)).shape;\n    if ((x_2516 > 0.100000001f)) {\n      let x_2521 : f32 = diffuseAttenuation;\n      let x_2522 : f32 = falloffAttenuation;\n      let x_2525 : vec3<f32> = (*(light)).color;\n      let x_2527 : vec3<f32> = cookieAttenuation;\n      areaDiffuse = ((x_2525 * (x_2521 * x_2522)) * x_2527);\n      let x_2529 : vec3<f32> = areaDiffuse;\n      let x_2530 : vec3<f32> = dLTCSpecFres;\n      areaDiffuse = mix(x_2529, vec3<f32>(0.0f, 0.0f, 0.0f), x_2530);\n      let x_2532 : vec3<f32> = areaDiffuse;\n      let x_2533 : vec3<f32> = dDiffuseLight;\n      dDiffuseLight = (x_2533 + x_2532);\n      let x_2536 : f32 = (*(light)).shape;\n      if ((x_2536 < 0.300000012f)) {\n        let x_2542 : vec3<f32> = *(worldNormal_16);\n        param_116 = x_2542;\n        let x_2544 : vec3<f32> = *(viewDir_14);\n        param_117 = x_2544;\n        let x_2545 : f32 = getRectLightSpecular_vf3_vf3_(&(param_116), &(param_117));\n        areaLightSpecular = x_2545;\n      } else {\n        let x_2548 : f32 = (*(light)).shape;\n        if ((x_2548 < 0.600000024f)) {\n          let x_2553 : vec3<f32> = *(worldNormal_16);\n          param_118 = x_2553;\n          let x_2555 : vec3<f32> = *(viewDir_14);\n          param_119 = x_2555;\n          let x_2556 : f32 = getDiskLightSpecular_vf3_vf3_(&(param_118), &(param_119));\n          areaLightSpecular = x_2556;\n        } else {\n          let x_2559 : vec3<f32> = *(worldNormal_16);\n          param_120 = x_2559;\n          let x_2561 : vec3<f32> = *(viewDir_14);\n          param_121 = x_2561;\n          let x_2562 : f32 = getSphereLightSpecular_vf3_vf3_(&(param_120), &(param_121));\n          areaLightSpecular = x_2562;\n        }\n      }\n      let x_2563 : vec3<f32> = dLTCSpecFres;\n      let x_2564 : f32 = areaLightSpecular;\n      let x_2566 : f32 = falloffAttenuation;\n      let x_2569 : vec3<f32> = (*(light)).color;\n      let x_2571 : vec3<f32> = cookieAttenuation;\n      let x_2573 : vec3<f32> = dSpecularLight;\n      dSpecularLight = (x_2573 + ((((x_2563 * x_2564) * x_2566) * x_2569) * x_2571));\n      let x_2576 : f32 = (*(light)).shape;\n      if ((x_2576 < 0.300000012f)) {\n        let x_2583 : vec3<f32> = (*(clearcoat)).worldNormal;\n        param_122 = x_2583;\n        let x_2585 : vec3<f32> = *(viewDir_14);\n        param_123 = x_2585;\n        let x_2586 : f32 = getRectLightSpecular_vf3_vf3_(&(param_122), &(param_123));\n        areaLightSpecularCC = x_2586;\n      } else {\n        let x_2589 : f32 = (*(light)).shape;\n        if ((x_2589 < 0.600000024f)) {\n          let x_2595 : vec3<f32> = (*(clearcoat)).worldNormal;\n          param_124 = x_2595;\n          let x_2597 : vec3<f32> = *(viewDir_14);\n          param_125 = x_2597;\n          let x_2598 : f32 = getDiskLightSpecular_vf3_vf3_(&(param_124), &(param_125));\n          areaLightSpecularCC = x_2598;\n        } else {\n          let x_2602 : vec3<f32> = (*(clearcoat)).worldNormal;\n          param_126 = x_2602;\n          let x_2604 : vec3<f32> = *(viewDir_14);\n          param_127 = x_2604;\n          let x_2605 : f32 = getSphereLightSpecular_vf3_vf3_(&(param_126), &(param_127));\n          areaLightSpecularCC = x_2605;\n        }\n      }\n      let x_2606 : vec3<f32> = ccLTCSpecFres;\n      let x_2607 : f32 = areaLightSpecularCC;\n      let x_2609 : f32 = falloffAttenuation;\n      let x_2612 : vec3<f32> = (*(light)).color;\n      let x_2614 : vec3<f32> = cookieAttenuation;\n      let x_2616 : vec3<f32> = ccSpecularLight;\n      ccSpecularLight = (x_2616 + ((((x_2606 * x_2607) * x_2609) * x_2612) * x_2614));\n    } else {\n      let x_2620 : f32 = falloffAttenuation;\n      let x_2622 : vec3<f32> = (*(light)).color;\n      let x_2624 : vec3<f32> = cookieAttenuation;\n      punctualDiffuse = ((x_2622 * x_2620) * x_2624);\n      let x_2626 : vec3<f32> = punctualDiffuse;\n      let x_2627 : vec3<f32> = *(specularity_3);\n      punctualDiffuse = mix(x_2626, vec3<f32>(0.0f, 0.0f, 0.0f), x_2627);\n      let x_2629 : vec3<f32> = punctualDiffuse;\n      let x_2630 : vec3<f32> = dDiffuseLight;\n      dDiffuseLight = (x_2630 + x_2629);\n      let x_2633 : vec3<f32> = dLightDirNormW;\n      let x_2635 : vec3<f32> = *(viewDir_14);\n      halfDir = normalize((-(x_2633) + x_2635));\n      let x_2639 : vec3<f32> = halfDir;\n      param_128 = x_2639;\n      let x_2641 : vec3<f32> = *(reflectionDir);\n      param_129 = x_2641;\n      let x_2643 : vec3<f32> = *(worldNormal_16);\n      param_130 = x_2643;\n      let x_2645 : vec3<f32> = *(viewDir_14);\n      param_131 = x_2645;\n      let x_2647 : vec3<f32> = dLightDirNormW;\n      param_132 = x_2647;\n      let x_2649 : f32 = *(gloss_7);\n      param_133 = x_2649;\n      let x_2651 : mat3x3<f32> = *(tbn_2);\n      param_134 = x_2651;\n      let x_2652 : f32 = getLightSpecular_vf3_vf3_vf3_vf3_vf3_f1_mf33_(&(param_128), &(param_129), &(param_130), &(param_131), &(param_132), &(param_133), &(param_134));\n      let x_2653 : f32 = falloffAttenuation;\n      let x_2656 : vec3<f32> = (*(light)).color;\n      let x_2658 : vec3<f32> = cookieAttenuation;\n      let x_2660 : vec3<f32> = *(viewDir_14);\n      let x_2661 : vec3<f32> = halfDir;\n      param_135 = dot(x_2660, x_2661);\n      let x_2665 : f32 = *(gloss_7);\n      param_136 = x_2665;\n      let x_2667 : vec3<f32> = *(specularity_3);\n      param_137 = x_2667;\n      let x_2668 : vec3<f32> = getFresnel_f1_f1_vf3_(&(param_135), &(param_136), &(param_137));\n      let x_2670 : vec3<f32> = dSpecularLight;\n      dSpecularLight = (x_2670 + (((x_2656 * (x_2652 * x_2653)) * x_2658) * x_2668));\n      let x_2673 : vec3<f32> = halfDir;\n      param_138 = x_2673;\n      let x_2675 : vec3<f32> = *(clearcoatReflectionDir);\n      param_139 = x_2675;\n      let x_2678 : vec3<f32> = (*(clearcoat)).worldNormal;\n      param_140 = x_2678;\n      let x_2680 : vec3<f32> = *(viewDir_14);\n      param_141 = x_2680;\n      let x_2682 : vec3<f32> = dLightDirNormW;\n      param_142 = x_2682;\n      let x_2685 : f32 = (*(clearcoat)).gloss;\n      param_143 = x_2685;\n      let x_2687 : mat3x3<f32> = *(tbn_2);\n      param_144 = x_2687;\n      let x_2688 : f32 = getLightSpecular_vf3_vf3_vf3_vf3_vf3_f1_mf33_(&(param_138), &(param_139), &(param_140), &(param_141), &(param_142), &(param_143), &(param_144));\n      let x_2689 : f32 = falloffAttenuation;\n      let x_2692 : vec3<f32> = (*(light)).color;\n      let x_2694 : vec3<f32> = cookieAttenuation;\n      let x_2696 : vec3<f32> = *(viewDir_14);\n      let x_2697 : vec3<f32> = halfDir;\n      param_145 = dot(x_2696, x_2697);\n      let x_2700 : f32 = getFresnelCC_f1_(&(param_145));\n      let x_2702 : vec3<f32> = ccSpecularLight;\n      ccSpecularLight = (x_2702 + (((x_2692 * (x_2688 * x_2689)) * x_2694) * x_2700));\n    }\n  }\n  return;\n}\n\nfn evaluateClusterLight_f1_vf3_vf3_vf3_vf3_f1_vf3_vf3_mf33_struct_ClearcoatArgs_f1_f1_vf31_struct_SheenArgs_f1_vf31_struct_IridescenceArgs_f1_f11_(lightIndex_1 : ptr<function, f32>, worldNormal_17 : ptr<function, vec3<f32>>, viewDir_15 : ptr<function, vec3<f32>>, reflectionDir_1 : ptr<function, vec3<f32>>, clearcoatReflectionDir_1 : ptr<function, vec3<f32>>, gloss_8 : ptr<function, f32>, specularity_4 : ptr<function, vec3<f32>>, geometricNormal_1 : ptr<function, vec3<f32>>, tbn_3 : ptr<function, mat3x3<f32>>, clearcoat_1 : ptr<function, ClearcoatArgs>, sheen_1 : ptr<function, SheenArgs>, iridescence_1 : ptr<function, IridescenceArgs>) {\n  var clusterLightData_5 : ClusterLightData;\n  var param_146 : ClusterLightData;\n  var param_147 : f32;\n  var param_148 : ClusterLightData;\n  var param_149 : vec3<f32>;\n  var param_150 : vec3<f32>;\n  var param_151 : vec3<f32>;\n  var param_152 : vec3<f32>;\n  var param_153 : f32;\n  var param_154 : vec3<f32>;\n  var param_155 : vec3<f32>;\n  var param_156 : mat3x3<f32>;\n  var param_157 : ClearcoatArgs;\n  var param_158 : SheenArgs;\n  var param_159 : IridescenceArgs;\n  let x_2706 : ClusterLightData = clusterLightData_5;\n  param_146 = x_2706;\n  let x_2708 : f32 = *(lightIndex_1);\n  param_147 = x_2708;\n  decodeClusterLightCore_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_f1_(&(param_146), &(param_147));\n  let x_2710 : ClusterLightData = param_146;\n  clusterLightData_5 = x_2710;\n  let x_2712 : f32 = clusterLightData_5.mask;\n  if ((x_2712 < 0.75f)) {\n    let x_2718 : ClusterLightData = clusterLightData_5;\n    param_148 = x_2718;\n    let x_2720 : vec3<f32> = *(worldNormal_17);\n    param_149 = x_2720;\n    let x_2722 : vec3<f32> = *(viewDir_15);\n    param_150 = x_2722;\n    let x_2724 : vec3<f32> = *(reflectionDir_1);\n    param_151 = x_2724;\n    let x_2726 : vec3<f32> = *(clearcoatReflectionDir_1);\n    param_152 = x_2726;\n    let x_2728 : f32 = *(gloss_8);\n    param_153 = x_2728;\n    let x_2730 : vec3<f32> = *(specularity_4);\n    param_154 = x_2730;\n    let x_2732 : vec3<f32> = *(geometricNormal_1);\n    param_155 = x_2732;\n    let x_2734 : mat3x3<f32> = *(tbn_3);\n    param_156 = x_2734;\n    let x_2736 : ClearcoatArgs = *(clearcoat_1);\n    param_157 = x_2736;\n    let x_2738 : SheenArgs = *(sheen_1);\n    param_158 = x_2738;\n    let x_2740 : IridescenceArgs = *(iridescence_1);\n    param_159 = x_2740;\n    evaluateLight_struct_ClusterLightData_vf3_f1_vf3_i1_vf3_f1_vf3_f1_vf3_f1_vf3_f1_vf4_f1_f1_f1_f1_f1_f1_f1_f11_vf3_vf3_vf3_vf3_f1_vf3_vf3_mf33_struct_ClearcoatArgs_f1_f1_vf31_struct_SheenArgs_f1_vf31_struct_IridescenceArgs_f1_f11_(&(param_148), &(param_149), &(param_150), &(param_151), &(param_152), &(param_153), &(param_154), &(param_155), &(param_156), &(param_157), &(param_158), &(param_159));\n  }\n  return;\n}\n\nfn addClusteredLights_vf3_vf3_vf3_vf3_f1_vf3_vf3_mf33_struct_ClearcoatArgs_f1_f1_vf31_struct_SheenArgs_f1_vf31_struct_IridescenceArgs_f1_f11_(worldNormal_18 : ptr<function, vec3<f32>>, viewDir_16 : ptr<function, vec3<f32>>, reflectionDir_2 : ptr<function, vec3<f32>>, clearcoatReflectionDir_2 : ptr<function, vec3<f32>>, gloss_9 : ptr<function, f32>, specularity_5 : ptr<function, vec3<f32>>, geometricNormal_2 : ptr<function, vec3<f32>>, tbn_4 : ptr<function, mat3x3<f32>>, clearcoat_2 : ptr<function, ClearcoatArgs>, sheen_2 : ptr<function, SheenArgs>, iridescence_2 : ptr<function, IridescenceArgs>) {\n  var cellCoords : vec3<f32>;\n  var cellIndex : f32;\n  var clusterV : f32;\n  var clusterU : f32;\n  var lightCellIndex : i32;\n  var lightIndex_2 : f32;\n  var param_160 : f32;\n  var param_161 : vec3<f32>;\n  var param_162 : vec3<f32>;\n  var param_163 : vec3<f32>;\n  var param_164 : vec3<f32>;\n  var param_165 : f32;\n  var param_166 : vec3<f32>;\n  var param_167 : vec3<f32>;\n  var param_168 : mat3x3<f32>;\n  var param_169 : ClearcoatArgs;\n  var param_170 : SheenArgs;\n  var param_171 : IridescenceArgs;\n  var x_2770 : bool;\n  var x_2771 : bool;\n  let x_2743 : f32 = x_546.clusterSkip;\n  if ((x_2743 > 0.5f)) {\n    return;\n  }\n  let x_2749 : vec3<f32> = vPositionW;\n  let x_2752 : vec3<f32> = x_546.clusterBoundsMin;\n  let x_2755 : vec3<f32> = x_546.clusterCellsCountByBoundsSize;\n  cellCoords = floor(((x_2749 - x_2752) * x_2755));\n  let x_2758 : vec3<f32> = cellCoords;\n  let x_2761 : bool = any((x_2758 < vec3<f32>(0.0f, 0.0f, 0.0f)));\n  x_2771 = x_2761;\n  if (!(x_2761)) {\n    let x_2765 : vec3<f32> = cellCoords;\n    let x_2768 : vec3<f32> = x_546.clusterCellsMax;\n    x_2770 = any((x_2765 >= x_2768));\n    x_2771 = x_2770;\n  }\n  if (!(x_2771)) {\n    let x_2778 : vec3<f32> = x_546.clusterCellsDot;\n    let x_2779 : vec3<f32> = cellCoords;\n    cellIndex = dot(x_2778, x_2779);\n    let x_2782 : f32 = cellIndex;\n    let x_2785 : f32 = x_546.clusterTextureSize.y;\n    clusterV = floor((x_2782 * x_2785));\n    let x_2789 : f32 = cellIndex;\n    let x_2790 : f32 = clusterV;\n    let x_2792 : f32 = x_546.clusterTextureSize.x;\n    clusterU = (x_2789 - (x_2790 * x_2792));\n    lightCellIndex = 0i;\n    loop {\n      let x_2801 : i32 = lightCellIndex;\n      let x_2804 : i32 = x_546.clusterMaxCells;\n      if ((x_2801 < x_2804)) {\n      } else {\n        break;\n      }\n      let x_2809 : f32 = clusterU;\n      let x_2811 : i32 = lightCellIndex;\n      let x_2813 : f32 = clusterV;\n      let x_2816 : vec4<f32> = textureLoad(clusterWorldTexture, vec2<i32>((i32(x_2809) + x_2811), i32(x_2813)), 0i);\n      lightIndex_2 = x_2816.x;\n      let x_2818 : f32 = lightIndex_2;\n      if ((x_2818 <= 0.0f)) {\n        return;\n      }\n      let x_2823 : f32 = lightIndex_2;\n      param_160 = (x_2823 * 255.0f);\n      let x_2828 : vec3<f32> = *(worldNormal_18);\n      param_161 = x_2828;\n      let x_2830 : vec3<f32> = *(viewDir_16);\n      param_162 = x_2830;\n      let x_2832 : vec3<f32> = *(reflectionDir_2);\n      param_163 = x_2832;\n      let x_2834 : vec3<f32> = *(clearcoatReflectionDir_2);\n      param_164 = x_2834;\n      let x_2836 : f32 = *(gloss_9);\n      param_165 = x_2836;\n      let x_2838 : vec3<f32> = *(specularity_5);\n      param_166 = x_2838;\n      let x_2840 : vec3<f32> = *(geometricNormal_2);\n      param_167 = x_2840;\n      let x_2842 : mat3x3<f32> = *(tbn_4);\n      param_168 = x_2842;\n      let x_2844 : ClearcoatArgs = *(clearcoat_2);\n      param_169 = x_2844;\n      let x_2846 : SheenArgs = *(sheen_2);\n      param_170 = x_2846;\n      let x_2848 : IridescenceArgs = *(iridescence_2);\n      param_171 = x_2848;\n      evaluateClusterLight_f1_vf3_vf3_vf3_vf3_f1_vf3_vf3_mf33_struct_ClearcoatArgs_f1_f1_vf31_struct_SheenArgs_f1_vf31_struct_IridescenceArgs_f1_f11_(&(param_160), &(param_161), &(param_162), &(param_163), &(param_164), &(param_165), &(param_166), &(param_167), &(param_168), &(param_169), &(param_170), &(param_171));\n\n      continuing {\n        let x_2850 : i32 = lightCellIndex;\n        lightCellIndex = (x_2850 + 1i);\n      }\n    }\n  }\n  return;\n}\n\nfn occludeSpecular_f1_f1_vf3_vf3_(gloss_1 : ptr<function, f32>, ao_1 : ptr<function, f32>, worldNormal : ptr<function, vec3<f32>>, viewDir : ptr<function, vec3<f32>>) {\n  let x_896 : f32 = *(ao_1);\n  let x_897 : vec3<f32> = dSpecularLight;\n  dSpecularLight = (x_897 * x_896);\n  let x_901 : f32 = *(ao_1);\n  let x_902 : vec4<f32> = dReflection;\n  dReflection = (x_902 * x_901);\n  return;\n}\n\nfn combineColor_vf3_vf3_f1_(albedo_1 : ptr<function, vec3<f32>>, sheenSpecularity : ptr<function, vec3<f32>>, clearcoatSpecularity_1 : ptr<function, f32>) -> vec3<f32> {\n  var ret_1 : vec3<f32>;\n  var clearCoatScaling : f32;\n  ret_1 = vec3<f32>(0.0f, 0.0f, 0.0f);\n  let x_2175 : vec3<f32> = *(albedo_1);\n  let x_2176 : vec3<f32> = dDiffuseLight;\n  let x_2178 : vec3<f32> = ret_1;\n  ret_1 = (x_2178 + (x_2175 * x_2176));\n  let x_2180 : vec3<f32> = dSpecularLight;\n  let x_2181 : vec3<f32> = ret_1;\n  ret_1 = (x_2181 + x_2180);\n  let x_2185 : f32 = ccFresnel;\n  let x_2186 : f32 = *(clearcoatSpecularity_1);\n  clearCoatScaling = (1.0f - (x_2185 * x_2186));\n  let x_2189 : vec3<f32> = ret_1;\n  let x_2190 : f32 = clearCoatScaling;\n  let x_2193 : vec3<f32> = ccSpecularLight;\n  let x_2195 : vec3<f32> = ccReflection;\n  let x_2197 : f32 = *(clearcoatSpecularity_1);\n  ret_1 = ((x_2189 * x_2190) + ((x_2193 + x_2195) * x_2197));\n  let x_2200 : vec3<f32> = ret_1;\n  return x_2200;\n}\n\nfn addFog_vf3_(color_2 : ptr<function, vec3<f32>>) -> vec3<f32> {\n  let x_632 : vec3<f32> = *(color_2);\n  return x_632;\n}\n\nfn toneMap_vf3_(color_1 : ptr<function, vec3<f32>>) -> vec3<f32> {\n  var tA : f32;\n  var tB : f32;\n  var tC : f32;\n  var tD : f32;\n  var tE : f32;\n  var x_2 : vec3<f32>;\n  tA = 2.50999999f;\n  tB = 0.029999999f;\n  tC = 2.430000067f;\n  tD = 0.589999974f;\n  tE = 0.140000001f;\n  let x_605 : vec3<f32> = *(color_1);\n  let x_608 : f32 = x_546.exposure;\n  x_2 = (x_605 * x_608);\n  let x_610 : vec3<f32> = x_2;\n  let x_611 : f32 = tA;\n  let x_612 : vec3<f32> = x_2;\n  let x_614 : f32 = tB;\n  let x_618 : vec3<f32> = x_2;\n  let x_619 : f32 = tC;\n  let x_620 : vec3<f32> = x_2;\n  let x_622 : f32 = tD;\n  let x_626 : f32 = tE;\n  return ((x_610 * ((x_612 * x_611) + vec3<f32>(x_614, x_614, x_614))) / ((x_618 * ((x_620 * x_619) + vec3<f32>(x_622, x_622, x_622))) + vec3<f32>(x_626, x_626, x_626)));\n}\n\nfn gammaCorrectOutput_vf3_(color : ptr<function, vec3<f32>>) -> vec3<f32> {\n  let x_585 : vec3<f32> = *(color);\n  return pow((x_585 + vec3<f32>(0.0000001f, 0.0000001f, 0.0000001f)), vec3<f32>(0.454545468f, 0.454545468f, 0.454545468f));\n}\n\nfn evaluateBackend_struct_LitShaderArguments_f1_vf3_vf3_f1_f1_vf3_f1_f1_f1_f1_vf3_vf3_vf3_struct_IridescenceArgs_f1_f11_struct_ClearcoatArgs_f1_f1_vf31_struct_SheenArgs_f1_vf311_(litShaderArgs_1 : ptr<function, LitShaderArguments>) {\n  var param_172 : vec3<f32>;\n  var param_173 : vec3<f32>;\n  var param_174 : f32;\n  var param_175 : mat3x3<f32>;\n  var param_176 : LitShaderArguments;\n  var param_177 : vec3<f32>;\n  var param_178 : f32;\n  var param_179 : f32;\n  var param_180 : vec3<f32>;\n  var param_181 : vec3<f32>;\n  var param_182 : vec3<f32>;\n  var param_183 : f32;\n  var param_184 : vec3<f32>;\n  var param_185 : f32;\n  var param_186 : vec3<f32>;\n  var param_187 : vec3<f32>;\n  var param_188 : vec3<f32>;\n  var param_189 : vec3<f32>;\n  var param_190 : f32;\n  var param_191 : vec3<f32>;\n  var param_192 : vec3<f32>;\n  var param_193 : mat3x3<f32>;\n  var param_194 : ClearcoatArgs;\n  var param_195 : SheenArgs;\n  var param_196 : IridescenceArgs;\n  var param_197 : f32;\n  var param_198 : f32;\n  var param_199 : vec3<f32>;\n  var param_200 : vec3<f32>;\n  var param_201 : vec3<f32>;\n  var param_202 : vec3<f32>;\n  var param_203 : f32;\n  var param_204 : vec3<f32>;\n  var param_205 : vec3<f32>;\n  var param_206 : vec3<f32>;\n  let x_2854 : vec3<f32> = (*(litShaderArgs_1)).worldNormal;\n  param_172 = x_2854;\n  let x_2856 : vec3<f32> = dViewDirW;\n  param_173 = x_2856;\n  let x_2859 : f32 = (*(litShaderArgs_1)).gloss;\n  param_174 = x_2859;\n  let x_2861 : mat3x3<f32> = dTBN;\n  param_175 = x_2861;\n  getReflDir_vf3_vf3_f1_mf33_(&(param_172), &(param_173), &(param_174), &(param_175));\n  let x_2864 : vec3<f32> = dViewDirW;\n  let x_2866 : vec3<f32> = (*(litShaderArgs_1)).clearcoat.worldNormal;\n  ccReflDirW = normalize(-(reflect(x_2864, x_2866)));\n  let x_2871 : LitShaderArguments = *(litShaderArgs_1);\n  param_176 = x_2871;\n  getMetalnessModulate_struct_LitShaderArguments_f1_vf3_vf3_f1_f1_vf3_f1_f1_f1_f1_vf3_vf3_vf3_struct_IridescenceArgs_f1_f11_struct_ClearcoatArgs_f1_f1_vf31_struct_SheenArgs_f1_vf311_(&(param_176));\n  let x_2873 : LitShaderArguments = param_176;\n  *(litShaderArgs_1) = x_2873;\n  let x_2876 : vec3<f32> = (*(litShaderArgs_1)).worldNormal;\n  param_177 = x_2876;\n  addAmbient_vf3_(&(param_177));\n  let x_2878 : vec3<f32> = dDiffuseLight;\n  let x_2880 : vec3<f32> = (*(litShaderArgs_1)).specularity;\n  dDiffuseLight = (x_2878 * (vec3<f32>(1.0f, 1.0f, 1.0f) - x_2880));\n  let x_2886 : f32 = (*(litShaderArgs_1)).ao;\n  param_178 = x_2886;\n  occludeDiffuse_f1_(&(param_178));\n  let x_2889 : vec3<f32> = (*(litShaderArgs_1)).specularity;\n  let x_2890 : vec3<f32> = dSpecularLight;\n  dSpecularLight = (x_2890 * x_2889);\n  let x_2894 : f32 = (*(litShaderArgs_1)).gloss;\n  param_179 = x_2894;\n  let x_2897 : vec3<f32> = (*(litShaderArgs_1)).worldNormal;\n  param_180 = x_2897;\n  let x_2899 : vec3<f32> = dViewDirW;\n  param_181 = x_2899;\n  let x_2902 : vec3<f32> = (*(litShaderArgs_1)).specularity;\n  param_182 = x_2902;\n  let x_2905 : f32 = (*(litShaderArgs_1)).clearcoat.gloss;\n  param_183 = x_2905;\n  let x_2908 : vec3<f32> = (*(litShaderArgs_1)).clearcoat.worldNormal;\n  param_184 = x_2908;\n  let x_2911 : f32 = (*(litShaderArgs_1)).clearcoat.specularity;\n  param_185 = x_2911;\n  calcLTCLightValues_f1_vf3_vf3_vf3_f1_vf3_f1_(&(param_179), &(param_180), &(param_181), &(param_182), &(param_183), &(param_184), &(param_185));\n  let x_2916 : vec3<f32> = (*(litShaderArgs_1)).worldNormal;\n  param_186 = x_2916;\n  let x_2918 : vec3<f32> = dViewDirW;\n  param_187 = x_2918;\n  let x_2920 : vec3<f32> = dReflDirW;\n  param_188 = x_2920;\n  let x_2922 : vec3<f32> = ccReflDirW;\n  param_189 = x_2922;\n  let x_2925 : f32 = (*(litShaderArgs_1)).gloss;\n  param_190 = x_2925;\n  let x_2928 : vec3<f32> = (*(litShaderArgs_1)).specularity;\n  param_191 = x_2928;\n  let x_2930 : vec3<f32> = dVertexNormalW;\n  param_192 = x_2930;\n  let x_2932 : mat3x3<f32> = dTBN;\n  param_193 = x_2932;\n  let x_2935 : ClearcoatArgs = (*(litShaderArgs_1)).clearcoat;\n  param_194 = x_2935;\n  let x_2938 : SheenArgs = (*(litShaderArgs_1)).sheen;\n  param_195 = x_2938;\n  let x_2941 : IridescenceArgs = (*(litShaderArgs_1)).iridescence;\n  param_196 = x_2941;\n  addClusteredLights_vf3_vf3_vf3_vf3_f1_vf3_vf3_mf33_struct_ClearcoatArgs_f1_f1_vf31_struct_SheenArgs_f1_vf31_struct_IridescenceArgs_f1_f11_(&(param_186), &(param_187), &(param_188), &(param_189), &(param_190), &(param_191), &(param_192), &(param_193), &(param_194), &(param_195), &(param_196));\n  (*(litShaderArgs_1)).clearcoat.specularity = 1.0f;\n  (*(litShaderArgs_1)).specularity = vec3<f32>(1.0f, 1.0f, 1.0f);\n  let x_2947 : f32 = (*(litShaderArgs_1)).gloss;\n  param_197 = x_2947;\n  let x_2950 : f32 = (*(litShaderArgs_1)).ao;\n  param_198 = x_2950;\n  let x_2953 : vec3<f32> = (*(litShaderArgs_1)).worldNormal;\n  param_199 = x_2953;\n  let x_2955 : vec3<f32> = dViewDirW;\n  param_200 = x_2955;\n  occludeSpecular_f1_f1_vf3_vf3_(&(param_197), &(param_198), &(param_199), &(param_200));\n  let x_2961 : vec3<f32> = (*(litShaderArgs_1)).albedo;\n  param_201 = x_2961;\n  let x_2964 : vec3<f32> = (*(litShaderArgs_1)).sheen.specularity;\n  param_202 = x_2964;\n  let x_2967 : f32 = (*(litShaderArgs_1)).clearcoat.specularity;\n  param_203 = x_2967;\n  let x_2968 : vec3<f32> = combineColor_vf3_vf3_f1_(&(param_201), &(param_202), &(param_203));\n  let x_2969 : vec4<f32> = pc_fragColor;\n  pc_fragColor = vec4<f32>(x_2968.x, x_2968.y, x_2968.z, x_2969.w);\n  let x_2972 : vec3<f32> = (*(litShaderArgs_1)).emission;\n  let x_2973 : vec4<f32> = pc_fragColor;\n  let x_2975 : vec3<f32> = (vec3<f32>(x_2973.x, x_2973.y, x_2973.z) + x_2972);\n  let x_2976 : vec4<f32> = pc_fragColor;\n  pc_fragColor = vec4<f32>(x_2975.x, x_2975.y, x_2975.z, x_2976.w);\n  let x_2979 : vec4<f32> = pc_fragColor;\n  param_204 = vec3<f32>(x_2979.x, x_2979.y, x_2979.z);\n  let x_2981 : vec3<f32> = addFog_vf3_(&(param_204));\n  let x_2982 : vec4<f32> = pc_fragColor;\n  pc_fragColor = vec4<f32>(x_2981.x, x_2981.y, x_2981.z, x_2982.w);\n  let x_2985 : vec4<f32> = pc_fragColor;\n  param_205 = vec3<f32>(x_2985.x, x_2985.y, x_2985.z);\n  let x_2987 : vec3<f32> = toneMap_vf3_(&(param_205));\n  let x_2988 : vec4<f32> = pc_fragColor;\n  pc_fragColor = vec4<f32>(x_2987.x, x_2987.y, x_2987.z, x_2988.w);\n  let x_2991 : vec4<f32> = pc_fragColor;\n  param_206 = vec3<f32>(x_2991.x, x_2991.y, x_2991.z);\n  let x_2993 : vec3<f32> = gammaCorrectOutput_vf3_(&(param_206));\n  let x_2994 : vec4<f32> = pc_fragColor;\n  pc_fragColor = vec4<f32>(x_2993.x, x_2993.y, x_2993.z, x_2994.w);\n  pc_fragColor.w = 1.0f;\n  return;\n}\n\nfn main_1() {\n  var x_3002 : vec3<f32>;\n  var param_207 : vec3<f32>;\n  var param_208 : vec3<f32>;\n  var param_209 : vec3<f32>;\n  var litShaderArgs_2 : LitShaderArguments;\n  var param_210 : LitShaderArguments;\n  dAlpha = 1.0f;\n  dBlendModeFogFactor = 1.0f;\n  dReflection = vec4<f32>(0.0f, 0.0f, 0.0f, 0.0f);\n  ccSpecularLight = vec3<f32>(0.0f, 0.0f, 0.0f);\n  ccReflection = vec3<f32>(0.0f, 0.0f, 0.0f);\n  let x_3001 : bool = gl_FrontFacing;\n  if (x_3001) {\n    let x_3005 : vec3<f32> = vNormalW;\n    let x_3007 : f32 = x_546.twoSidedLightingNegScaleFactor;\n    x_3002 = (x_3005 * x_3007);\n  } else {\n    let x_3010 : vec3<f32> = vNormalW;\n    let x_3013 : f32 = x_546.twoSidedLightingNegScaleFactor;\n    x_3002 = (-(x_3010) * x_3013);\n  }\n  let x_3015 : vec3<f32> = x_3002;\n  dVertexNormalW = normalize(x_3015);\n  getViewDir_();\n  let x_3021 : vec3<f32> = dTangentW;\n  param_207 = x_3021;\n  let x_3023 : vec3<f32> = dBinormalW;\n  param_208 = x_3023;\n  let x_3025 : vec3<f32> = dVertexNormalW;\n  param_209 = x_3025;\n  getTBN_vf3_vf3_vf3_(&(param_207), &(param_208), &(param_209));\n  let x_3028 : LitShaderArguments = evaluateFrontend_();\n  litShaderArgs_2 = x_3028;\n  let x_3030 : LitShaderArguments = litShaderArgs_2;\n  param_210 = x_3030;\n  evaluateBackend_struct_LitShaderArguments_f1_vf3_vf3_f1_f1_vf3_f1_f1_f1_f1_vf3_vf3_vf3_struct_IridescenceArgs_f1_f11_struct_ClearcoatArgs_f1_f1_vf31_struct_SheenArgs_f1_vf311_(&(param_210));\n  return;\n}\n\nstruct main_out {\n  @location(0)\n  pc_fragColor_1 : vec4<f32>,\n}\n\n@fragment\nfn main(@location(0) vPositionW_param : vec3<f32>, @location(2) vUv0_param : vec2<f32>, @location(3) vUv1_param : vec2<f32>, @location(1) vNormalW_param : vec3<f32>, @builtin(front_facing) gl_FrontFacing_param : bool) -> main_out {\n  vPositionW = vPositionW_param;\n  vUv0 = vUv0_param;\n  vUv1 = vUv1_param;\n  vNormalW = vNormalW_param;\n  gl_FrontFacing = gl_FrontFacing_param;\n  main_1();\n  return main_out(pc_fragColor);\n}\n"
      },
      "entryPoint": "main",
      "targets": [
          {
              "format": "rgba8unorm",
              "writeMask": 15
          }
      ]
  }
}