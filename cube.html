<!doctype html>

<html>
  <head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
    <meta name='mobile-web-app-capable' content='yes'>
    <meta name='apple-mobile-web-app-capable' content='yes'>

    <title>WebGPU test</title>

    <style>
      html, body {
        height: 100%;
        margin: 0;
        background-color: #000066;
      }
    </style>
  </head>
  <body>
    <canvas></canvas>
    <button>Download Screenshot</button>
    <script type="module">
      import {mat4, vec3} from './js/third-party/gl-matrix/src/gl-matrix.js';

      const depthFormat = "depth24plus";
      const sampleCount = 4;

      const uniformBufferSize = 4 * 16; // 4x4 matrix

      const shaderSrc = `#version 450
        [[block]] struct Uniforms {
          [[offset(0)]] modelViewProjectionMatrix : mat4x4<f32>;
        };
        [[set(0), binding(0)]] var<uniform> uniforms : Uniforms;

        [[location(0)]] var<in> position : vec4<f32>;
        [[location(1)]] var<in> color : vec4<f32>;

        [[location(0)]] var<out> outColor : vec4<f32>;
        [[builtin(position)]] var<out> vertPosition : vec4<f32>;

        [[stage(vertex)]]
        fn vertMain() -> void {
          outColor = color;
          vertPosition = uniforms.modelViewProjectionMatrix * position;
        }

        [[location(0)]] var<in> inColor : vec4<f32>;
        [[location(0)]] var<out> fragColor : vec4<f32>;

        [[stage(fragment)]]
        fn fragMain() -> void {
          fragColor = inColor;
        }
      `;

      const Cube = {
        layout: {
          arrayStride: 4 * 10, // Byte size of one cube vertex
          attributes: [{
            // position
            shaderLocation: 0,
            offset: 0,
            format: "float4"
          }, {
            // color
            shaderLocation: 1,
            offset: 4 * 4,
            format: "float4"
          },
          {
            // UV
            shaderLocation: 2,
            offset: 4 * 8,
            format: "float2"
          }]
        },
        vertexCount: 36,
        vertexArray: new Float32Array([
          // float4 position, float4 color, float2 uv,
          1, -1, 1, 1,   1, 0, 1, 1,  1, 1,
          -1, -1, 1, 1,  0, 0, 1, 1,  0, 1,
          -1, -1, -1, 1, 0, 0, 0, 1,  0, 0,
          1, -1, -1, 1,  1, 0, 0, 1,  1, 0,
          1, -1, 1, 1,   1, 0, 1, 1,  1, 1,
          -1, -1, -1, 1, 0, 0, 0, 1,  0, 0,

          1, 1, 1, 1,    1, 1, 1, 1,  1, 1,
          1, -1, 1, 1,   1, 0, 1, 1,  0, 1,
          1, -1, -1, 1,  1, 0, 0, 1,  0, 0,
          1, 1, -1, 1,   1, 1, 0, 1,  1, 0,
          1, 1, 1, 1,    1, 1, 1, 1,  1, 1,
          1, -1, -1, 1,  1, 0, 0, 1,  0, 0,

          -1, 1, 1, 1,   0, 1, 1, 1,  1, 1,
          1, 1, 1, 1,    1, 1, 1, 1,  0, 1,
          1, 1, -1, 1,   1, 1, 0, 1,  0, 0,
          -1, 1, -1, 1,  0, 1, 0, 1,  1, 0,
          -1, 1, 1, 1,   0, 1, 1, 1,  1, 1,
          1, 1, -1, 1,   1, 1, 0, 1,  0, 0,

          -1, -1, 1, 1,  0, 0, 1, 1,  1, 1,
          -1, 1, 1, 1,   0, 1, 1, 1,  0, 1,
          -1, 1, -1, 1,  0, 1, 0, 1,  0, 0,
          -1, -1, -1, 1, 0, 0, 0, 1,  1, 0,
          -1, -1, 1, 1,  0, 0, 1, 1,  1, 1,
          -1, 1, -1, 1,  0, 1, 0, 1,  0, 0,

          1, 1, 1, 1,    1, 1, 1, 1,  1, 1,
          -1, 1, 1, 1,   0, 1, 1, 1,  0, 1,
          -1, -1, 1, 1,  0, 0, 1, 1,  0, 0,
          -1, -1, 1, 1,  0, 0, 1, 1,  0, 0,
          1, -1, 1, 1,   1, 0, 1, 1,  1, 0,
          1, 1, 1, 1,    1, 1, 1, 1,  1, 1,

          1, -1, -1, 1,  1, 0, 0, 1,  1, 1,
          -1, -1, -1, 1, 0, 0, 0, 1,  0, 1,
          -1, 1, -1, 1,  0, 1, 0, 1,  0, 0,
          1, 1, -1, 1,   1, 1, 0, 1,  1, 0,
          1, -1, -1, 1,  1, 0, 0, 1,  1, 1,
          -1, 1, -1, 1,  0, 1, 0, 1,  0, 0,
        ])
      };

      let canvas;
      let context;
      let adapter;
      let device;
      let swapChainFormat;
      let swapChain;
      let vertexBuffer;
      let colorTexture;
      let depthTexture;
      let pipeline;
      let renderPassDescriptor;
      let uniformBuffer;
      let uniformBindGroup;

      let viewMatrix = mat4.create();
      let projectionMatrix = mat4.create();
      let modelViewProjectionMatrix = mat4.create();

      async function initWebGPU() {
        canvas = document.querySelector('canvas');

        adapter = await navigator.gpu.requestAdapter();
        device = await adapter.requestDevice();
        // Resize after getting the device to avoid Chrome bug.
        canvas.width = canvas.height = 300;

        context = canvas.getContext('gpupresent');
        swapChainFormat = context.getSwapChainPreferredFormat(adapter);
        swapChain = context.configureSwapChain({
          device,
          format: swapChainFormat,
          usage: GPUTextureUsage.OUTPUT_ATTACHMENT | GPUTextureUsage.COPY_SRC
        });

        vertexBuffer = device.createBuffer({
          size: Cube.vertexArray.byteLength,
          usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST
        });
        device.defaultQueue.writeBuffer(vertexBuffer, 0, Cube.vertexArray);

        const shaderModule = device.createShaderModule({ code: shaderSrc });

        pipeline = device.createRenderPipeline({
          vertexStage: {
            module: shaderModule,
            entryPoint: 'vertMain'
          },
          fragmentStage: {
            module: shaderModule,
            entryPoint: 'fragMain'
          },

          primitiveTopology: 'triangle-list',
          vertexState: {
            vertexBuffers: [Cube.layout],
          },

          rasterizationState: {
            cullMode: 'back',
          },

          colorStates: [{
            format: swapChainFormat,
          }],
          depthStencilState: {
            depthWriteEnabled: true,
            depthCompare: 'less',
            format: depthFormat,
          },
          sampleCount,
        });

        renderPassDescriptor = {
          colorAttachments: [{
            // attachment is acquired and set in render loop.
            attachment: undefined,
            resolveTarget: undefined,

            loadValue: { r: 0.0, g: 0.5, b: 0.0, a: 1.0 },
          }],
          depthStencilAttachment: {
            // attachment is acquired and set in render loop.
            attachment: undefined,

            depthLoadValue: 1.0,
            depthStoreOp: 'store',
            stencilLoadValue: 0,
            stencilStoreOp: 'store',
          }
        };

        uniformBuffer = device.createBuffer({
          size: uniformBufferSize,
          usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
        });

        uniformBindGroup = device.createBindGroup({
          layout: pipeline.getBindGroupLayout(0),
          entries: [{
            binding: 0,
            resource: {
              buffer: uniformBuffer,
            },
          }],
        });

        function onResize() {
          colorTexture = device.createTexture({
            size: {
              width: canvas.width,
              height: canvas.height,
              depth: 1,
            },
            sampleCount,
            format: swapChainFormat,
            usage: GPUTextureUsage.OUTPUT_ATTACHMENT,
          });
          renderPassDescriptor.colorAttachments[0].attachment = colorTexture.createView();

          depthTexture = device.createTexture({
            size: {
              width: canvas.width,
              height: canvas.height,
              depth: 1
            },
            sampleCount,
            format: depthFormat,
            usage: GPUTextureUsage.OUTPUT_ATTACHMENT
          });
          renderPassDescriptor.depthStencilAttachment.attachment = depthTexture.createView();

          const aspect = Math.abs(canvas.width / canvas.height);
          mat4.perspective(projectionMatrix, Math.PI * 0.5, aspect, 0.1, 1000.0);
        }
        window.addEventListener('resize', onResize);
        onResize();

        window.requestAnimationFrame(onFrame);
      }

      function takeScreenshot(commandEncoder, swapTexture) {

      }

      function getTransformationMatrix() {
        mat4.identity(viewMatrix);
        mat4.translate(viewMatrix, viewMatrix, vec3.fromValues(0, 0, -5));
        let now = Date.now() / 1000;
        mat4.rotate(viewMatrix, viewMatrix, 1, vec3.fromValues(Math.sin(now), Math.cos(now), 0));

        mat4.multiply(modelViewProjectionMatrix, projectionMatrix, viewMatrix);

        return modelViewProjectionMatrix;
      }

      async function imageBufferToPng(buffer, width, height) {
        await buffer.mapAsync(GPUMapMode.READ);
        const bufferArray = buffer.getMappedRange();
        const imageData = new ImageData(new Uint8ClampedArray(bufferArray), width, height);

        // Create a new canvas with the image data
        const canvas2D = document.createElement('canvas');
        canvas2D.width = width;
        canvas2D.height = height;
        const ctx = canvas2D.getContext('2d');
        ctx.putImageData(imageData, 0, 0);
        // Useful for debugging
        // document.body.appendChild(canvas2D);

        // Create a download link
        const a = document.createElement('a');
        a.href = canvas2D.toDataURL();
        a.download = 'screenshot.png';
        a.innerText = 'Download';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
      }

      let screenshot = false;
      function onFrame() {
        window.requestAnimationFrame(onFrame);

        device.defaultQueue.writeBuffer(uniformBuffer, 0, getTransformationMatrix());

        const commandEncoder = device.createCommandEncoder({});

        const swapTexture = swapChain.getCurrentTexture();
        renderPassDescriptor.colorAttachments[0].resolveTarget = swapTexture.createView();
        const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);

        passEncoder.setPipeline(pipeline);
        passEncoder.setBindGroup(0, uniformBindGroup);
        passEncoder.setVertexBuffer(0, vertexBuffer);
        passEncoder.draw(Cube.vertexCount, 1, 0, 0);
        passEncoder.endPass();

        let screenshotBuffer = null;
        let bytesPerRow;
        if (screenshot) {
          screenshot = false;

          bytesPerRow = Math.ceil((canvas.width * 4)/256) * 256;
          const alignedSize = bytesPerRow * canvas.height;
          screenshotBuffer = device.createBuffer({
            size: alignedSize,
            usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
          });

          commandEncoder.copyTextureToBuffer(
            { texture: swapTexture },
            { buffer: screenshotBuffer, bytesPerRow, rowsPerImage: canvas.height },
            { width: canvas.width, height: canvas.height });
        }

        device.defaultQueue.submit([commandEncoder.finish()]);

        if (screenshotBuffer) {
          imageBufferToPng(screenshotBuffer, bytesPerRow / 4, canvas.height);
        }
      }

      initWebGPU();

      const button = document.querySelector('button');
      button.addEventListener('click', () => { screenshot = true;});
    </script>
  </body>
</html>